{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/payway/alipay.jpg","path":"images/payway/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/images/payway/wechatpay.jpg","path":"images/payway/wechatpay.jpg","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1534063472116},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1534063472117},{"_id":"source/CNAME","hash":"40f5326962ae3d5a25304617df5afac115c66b62","modified":1539589588567},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1534063472116},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1534063472116},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1534063472117},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1534063472117},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1534063472117},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1534063472118},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1534063472118},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1534063472118},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1534063472119},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1534063472119},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1534063472118},{"_id":"themes/next/_config.yml","hash":"641e0fa1996fc15fcfa8b01543fa964a299bd194","modified":1541658744876},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1534063472118},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1534063472135},{"_id":"source/_posts/dataStructure-AVL.md","hash":"3a605858b89e315006088510faa286f5bc410e67","modified":1542964885231},{"_id":"source/_posts/java-BTrace.md","hash":"217b3eb25b0ba1f871dac614f7d82003afccb529","modified":1539257467314},{"_id":"source/_posts/java-AQS-01.md","hash":"b5d7d75588ae14fb1a73459759df9e4d5fe03397","modified":1541485027838},{"_id":"source/_posts/java-ThisEscape.md","hash":"38dfc2bf6ab88527416dc8e8d2e8ccfbe0576f89","modified":1541663149430},{"_id":"source/_posts/java-IdentityHashmap.md","hash":"4cf69fc3e6697464cbf1aa633322bf2278c53ba1","modified":1539257107193},{"_id":"source/_posts/java-AQS-02.md","hash":"8db758a1e6df1395138c9fd742581dc1a289d4d2","modified":1540799636909},{"_id":"source/_posts/java-EnumMap.md","hash":"c52f442de0956ea4586b4700fc26b88d07d78b19","modified":1539257033626},{"_id":"source/_posts/java-WeakHashMap.md","hash":"e299860fc805177970bfeb644afb3c87d1d8a495","modified":1539257107196},{"_id":"source/_posts/java-ThreadLocalExecutor.md","hash":"ad88ade342beb037e8c2e303cadf0c7997a7a5ee","modified":1539255082124},{"_id":"source/_posts/java-stateMachine.md","hash":"1fb15f4f00b22928992536e26c6a2c2d95d2d954","modified":1534063472083},{"_id":"source/about/index.md","hash":"2a09ddc7b81e3081cad4f7577d371a81f0444d8f","modified":1534063472083},{"_id":"source/_posts/spring-IOC.md","hash":"160ba8a5c919f66fb480502b0c036e0806d47a51","modified":1534753770571},{"_id":"source/categories/index.md","hash":"b10826c80365903af8ad9c3a560101444789476a","modified":1534063472083},{"_id":"source/tags/index.md","hash":"77a1e4167b9d70b4bbe9b7d1409eacfc2f33b187","modified":1534063472092},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1534063472116},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1534063472116},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1534063472117},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1534063472117},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1534063472119},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1534063472120},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1534063472120},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1534063472120},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1534063472120},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1534063472120},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1534063472120},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1534063472120},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1534063472121},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1534063472121},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1534063472121},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1534063472121},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1534063472121},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1534063472121},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1534063472122},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1534063472121},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1534063472122},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1534063472134},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1534063472134},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1534063472134},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1534063472135},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1534063472135},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1534063472135},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1534063472135},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1534063472135},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1534063472136},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1534063472185},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1534063472185},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1534063472185},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472156},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1534063472122},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1534063472122},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1534063472123},{"_id":"themes/next/layout/_macro/my-copyright.swig","hash":"7b2710bf55b7961dd9a39c0f6e0c847e0bd3e381","modified":1534063472123},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1534063472123},{"_id":"themes/next/layout/_macro/passage-end-tag.swig","hash":"f29b50d83bcdc9e70696b6a8a8917d8b2ad4be10","modified":1534063472123},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1534063472124},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1534063472124},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1534063472124},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1534063472124},{"_id":"themes/next/layout/_partials/footer.swig","hash":"5ce60c9dde042bac0c393fa37c830cf2dd29ea68","modified":1534063472124},{"_id":"themes/next/layout/_macro/post.swig","hash":"c80caed88b110640e280b70ca4503a1ddd15f7e1","modified":1534063472123},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1534063472125},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1534063472125},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1534063472125},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1534063472124},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1534063472125},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1534063472127},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1534063472127},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1534063472128},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1534063472132},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1534063472132},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1534063472132},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1534063472132},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1534063472132},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1534063472133},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1534063472133},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1534063472136},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1534063472136},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1534063472136},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1534063472137},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1534063472137},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1534063472137},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1534063472137},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1534063472137},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1534063472137},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1534063472157},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1534063472156},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1534063472157},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1534063472157},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1534063472157},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1534063472157},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1534063472157},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1534063472158},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1534063472158},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1534063472158},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1534063472158},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1534063472158},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1534063472158},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1534063472159},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1534063472158},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1534063472160},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1534063472160},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1534063472160},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1534063472160},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472128},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472128},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472151},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472151},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472152},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472156},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1534063472156},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1534063472125},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1534063472125},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1534063472126},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1534063472126},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1534063472126},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1534063472126},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1534063472126},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1534063472126},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1534063472127},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1534063472127},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1534063472127},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1534063472128},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1534063472128},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1534063472128},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1534063472128},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1534063472129},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1534063472129},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1534063472129},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1534063472129},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1534063472129},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1534063472129},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1534063472130},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1534063472130},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1534063472130},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1534063472130},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1534063472130},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1534063472130},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1534063472131},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1534063472131},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1534063472131},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1534063472131},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1534063472131},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1534063472132},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"3b51dc50ea210a2de99da8f5663d7aceb372e766","modified":1541582786556},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1534063472133},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1534063472134},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1534063472134},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1534063472134},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1534063472151},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1534063472151},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1534063472151},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1534063472152},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1534063472156},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1534063472156},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1534063472156},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1534063472156},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1534063472160},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1534063472161},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1534063472161},{"_id":"themes/next/source/images/payway/alipay.jpg","hash":"fe3c33a8e3c185d62d89e64b5ca50eb6b769290e","modified":1534063472159},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1534063472161},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1534063472161},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1534063472161},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1534063472161},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1534063472161},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1534063472162},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1534063472162},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1534063472162},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1534063472167},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1534063472167},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1534063472165},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1534063472170},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1534063472170},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1534063472170},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1534063472170},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1534063472171},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1534063472171},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1534063472171},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1534063472171},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1534063472171},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1534063472176},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1534063472176},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1534063472175},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1534063472176},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1534063472177},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1534063472176},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1534063472177},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1534063472177},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1534063472178},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1534063472177},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1534063472177},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1534063472179},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1534063472178},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1534063472179},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1534063472179},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1534063472179},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1534063472179},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1534063472179},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1534063472180},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1534063472180},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1534063472183},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1534063472183},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1534063472180},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1534063472185},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1534063472185},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1534063472185},{"_id":"themes/next/source/images/payway/wechatpay.jpg","hash":"b741074ddafaf0d7c8c81921f28cc01b794b77b3","modified":1534063472160},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1534063472176},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1534063472133},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1534063472133},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1534063472138},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1534063472138},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1534063472150},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1534063472138},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1534063472138},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1534063472138},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1534063472141},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1534063472146},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1534063472150},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1534063472150},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1534063472150},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1534063472150},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1534063472151},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1534063472150},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1534063472152},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1534063472152},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1534063472152},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1534063472153},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1534063472152},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1534063472153},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1534063472153},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1534063472153},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1534063472154},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1534063472154},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1534063472154},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1534063472154},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1534063472155},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1534063472155},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1534063472155},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1534063472155},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1534063472155},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1534063472155},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1534063472156},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1534063472162},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1534063472164},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1534063472163},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1534063472167},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1534063472167},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1534063472164},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1534063472167},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1534063472169},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1534063472169},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1534063472169},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1534063472170},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1534063472170},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1534063472171},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1534063472171},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1534063472172},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1534063472183},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1534063472183},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1534063472164},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1534063472175},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1534063472175},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1534063472184},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1534063472139},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1534063472139},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1534063472139},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1534063472139},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1534063472140},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1534063472139},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1534063472139},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1534063472140},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1534063472140},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1534063472141},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1534063472140},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1534063472141},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1534063472141},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1534063472141},{"_id":"themes/next/source/css/_common/components/post/my-post-copyright.styl","hash":"1a510f995e665b28d85ba4d169b824276c40e4f3","modified":1534063472141},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1534063472142},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1534063472142},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1534063472142},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1534063472142},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1534063472142},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1534063472142},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1534063472143},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1534063472143},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1534063472143},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1534063472143},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1534063472143},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1534063472143},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1534063472144},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1534063472144},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"90d78b7270739eaab5b054226b684631a319011a","modified":1534063472144},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1534063472144},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1534063472144},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1534063472144},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1534063472145},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1534063472145},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1534063472145},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1534063472145},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1534063472146},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1534063472145},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1534063472146},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1534063472146},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1534063472146},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1534063472146},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1534063472147},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1534063472147},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1534063472147},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1534063472147},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1534063472147},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1534063472147},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1534063472148},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1534063472148},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1534063472148},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1534063472148},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1534063472148},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1534063472148},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1534063472149},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1534063472149},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1534063472149},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1534063472149},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1534063472153},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1534063472154},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1534063472155},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1534063472163},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1534063472163},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1534063472163},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1534063472163},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1534063472163},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1534063472168},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1534063472169},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1534063472169},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1534063472173},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1534063472174},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1534063472172},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1534063472166},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1534063472182},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1534063472174},{"_id":"public/about/index.html","hash":"2dee1e67a328e612abd22f63a90f274c8c73a8ec","modified":1542964997371},{"_id":"public/categories/index.html","hash":"b75377a457375137cb4ebdc9c3c970eefa4cbd08","modified":1542964997371},{"_id":"public/tags/index.html","hash":"e108917513926f3a449fecc75bc8ed65b8b438bd","modified":1542964997371},{"_id":"public/archives/page/2/index.html","hash":"5e20c44b5127790bee419b0ce2aa9183d5a61d63","modified":1542964997371},{"_id":"public/archives/2018/page/2/index.html","hash":"55e129619a4c8af89c44cbdfaa443e6f1a2bd846","modified":1542964997371},{"_id":"public/archives/2018/04/index.html","hash":"182fe374d1278fa6a941e4ada90fc1fa7849b339","modified":1542964997371},{"_id":"public/archives/2018/05/index.html","hash":"537694ff3c75cb65de5d024ad85562fba58e1960","modified":1542964997371},{"_id":"public/archives/2018/08/index.html","hash":"71df020344225a934c1bda4ed9c7df22fefbbf73","modified":1542964997371},{"_id":"public/archives/2018/10/index.html","hash":"89674dd06a7ec4c7f51486b08a74bb7fc630944a","modified":1542964997371},{"_id":"public/archives/2018/11/index.html","hash":"31f9ad91130999344d7061625bb21b6b1d112d3e","modified":1542964997371},{"_id":"public/categories/dataStructure/index.html","hash":"75d1feeb6e460c66ce494e981d7fb83964f75582","modified":1542964997371},{"_id":"public/categories/spring/index.html","hash":"143c9ca42dc60c5365eea2cd05cc59df4e23b69d","modified":1542964997372},{"_id":"public/page/2/index.html","hash":"78a81f021a992b93502f3c37cad65ed87d7532e3","modified":1542964997372},{"_id":"public/tags/dataStructure/index.html","hash":"37a758ea864af12e80c9008ab56691f8a7e97ba0","modified":1542964997372},{"_id":"public/tags/spring/index.html","hash":"c35389fd704222624f2b6a34bd486209d45e737c","modified":1542964997372},{"_id":"public/2018/11/23/dataStructure-AVL/index.html","hash":"7f7cc7873a9894955c594f2f761c98b379df8baf","modified":1542964997372},{"_id":"public/2018/11/08/java-ThisEscape/index.html","hash":"2127b502096dba3bbe9ec6470e548074f37cb9a5","modified":1542964997372},{"_id":"public/2018/10/29/java-AQS-02/index.html","hash":"88e49efe0b94baf0c2c47f1e599c4a4de2b59540","modified":1542964997373},{"_id":"public/2018/10/15/java-AQS-01/index.html","hash":"d42560377db15de0ad6a844e74a39e1c28eaaf3f","modified":1542964997373},{"_id":"public/2018/08/20/spring-IOC/index.html","hash":"0b2b554cb4959045aed803c44e2437a0e513d299","modified":1542964997373},{"_id":"public/2018/08/12/java-ThreadLocalExecutor/index.html","hash":"f114227e74e32773d51b062e169d1baae63a8cca","modified":1542964997373},{"_id":"public/2018/08/05/java-BTrace/index.html","hash":"68f7f0accb8d8126ae39d7902ec4e587e98a7263","modified":1542964997373},{"_id":"public/2018/05/05/java-WeakHashMap/index.html","hash":"cfd060e76eb22333799709a5959165ae7d5c6ee0","modified":1542964997373},{"_id":"public/2018/04/30/java-IdentityHashmap/index.html","hash":"ebf2c78e4caf1df9e060788b358a4a47161cc160","modified":1542964997373},{"_id":"public/2018/04/22/java-stateMachine/index.html","hash":"5f0e96f99a839f3853ff9421e8981862e24aceaa","modified":1542964997373},{"_id":"public/2018/04/19/java-EnumMap/index.html","hash":"b3c033e7d7f7ed3dcde3789dc3f09c117ffe0bed","modified":1542964997373},{"_id":"public/archives/index.html","hash":"10c04c74312afdb66dae6076f5472f0ff15b5e86","modified":1542964997373},{"_id":"public/archives/2018/index.html","hash":"0044e659eb8df583e8298db394581db9d6e83f57","modified":1542964997373},{"_id":"public/categories/java/index.html","hash":"7a716eeffcd810cc62bd706b408f901659ce49e0","modified":1542964997373},{"_id":"public/index.html","hash":"f051c1dd82f79d9a38110b9d9847c5a12927f5f7","modified":1542964997374},{"_id":"public/tags/java/index.html","hash":"8cd6b6e6b3b12a1dbf3fa04c768503b0e4f47aa8","modified":1542964997374},{"_id":"public/CNAME","hash":"40f5326962ae3d5a25304617df5afac115c66b62","modified":1542964997410},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1542964997410},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1542964997410},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1542964997410},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1542964997410},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1542964997410},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1542964997410},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1542964997411},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1542964997411},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1542964997411},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1542964997411},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1542964997411},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1542964997411},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1542964997411},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542964997411},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1542964997411},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1542964997411},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1542964997411},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1542964997411},{"_id":"public/images/payway/alipay.jpg","hash":"fe3c33a8e3c185d62d89e64b5ca50eb6b769290e","modified":1542964997411},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1542964997411},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1542964997411},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1542964997411},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1542964997411},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1542964997412},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1542964997412},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1542964997412},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1542964997412},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1542964997412},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1542964997412},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1542964997412},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1542964997412},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1542964997412},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1542964997412},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1542964997412},{"_id":"public/images/payway/wechatpay.jpg","hash":"b741074ddafaf0d7c8c81921f28cc01b794b77b3","modified":1542964997798},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1542964997801},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1542964997807},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1542964997815},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1542964997815},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1542964997815},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1542964997815},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1542964997815},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1542964997815},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1542964997816},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1542964997816},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1542964997816},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1542964997816},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1542964997816},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1542964997816},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1542964997816},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1542964997816},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1542964997816},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1542964997816},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1542964997816},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1542964997816},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1542964997816},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1542964997816},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1542964997816},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1542964997816},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1542964997816},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1542964997817},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1542964997817},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1542964997817},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1542964997817},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1542964997817},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1542964997817},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1542964997817},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1542964997817},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1542964997817},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1542964997817},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1542964997817},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1542964997817},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1542964997817},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1542964997817},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1542964997817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1542964997817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1542964997817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1542964997817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1542964997817},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1542964997817},{"_id":"public/css/main.css","hash":"496d782d38b2032644ba2dd95f63f3f0fdcee7cb","modified":1542964997817},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1542964997817},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1542964997817},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1542964997818},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1542964997818},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1542964997818},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1542964997818},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1542964997818},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1542964997818},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1542964997818},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1542964997818},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1542964997818},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1542964997818},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1542964997818},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1542964997818},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1542964997818},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1542964997818},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1542964997818},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1542964997819},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1542964997819},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1542964997819},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1542964997819},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1542964997819},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1542964997819},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1542964997827}],"Category":[{"name":"dataStructure","_id":"cjottiq2b0001m9cgyjs8ylfl"},{"name":"java","_id":"cjottiq690009m9cg80vrs96h"},{"name":"spring","_id":"cjottiq6p000zm9cgp2tw77e2"}],"Data":[],"Page":[{"title":"关于我","date":"2018-04-14T03:46:20.000Z","type":"about","_content":"\n### About\n> 博主现在是一名大四学生，现是北京某互联网金融公司一名服务端开发实习生，主要从事支付相关业务的开发。搭建此博客的目的主要是想和大家一起分享自己的一些收获，本人现在是小白一个，文章如有不正之处，还望各位大神多多指教。\n> 微博:Xander·Xu\n\n### Education\n\n> 2014 - 2018, 青岛科技大学, 本科, 物联网工程\n\n\n### Work Experience\n\n> 借贷宝 (2018年2月 - 至今) \n  服务端研发实习 \n  支付应用研发部 \n   \n> 青岛孔雀网络科技有限公司(2017年4月 - 2017年10月)\n  服务端研发实习\n  孔雀云平台   \n  \n\n### Gmail\n> xuxiaofei4519@gmail.com\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2018-04-14 11:46:20\ntype: \"about\"\n---\n\n### About\n> 博主现在是一名大四学生，现是北京某互联网金融公司一名服务端开发实习生，主要从事支付相关业务的开发。搭建此博客的目的主要是想和大家一起分享自己的一些收获，本人现在是小白一个，文章如有不正之处，还望各位大神多多指教。\n> 微博:Xander·Xu\n\n### Education\n\n> 2014 - 2018, 青岛科技大学, 本科, 物联网工程\n\n\n### Work Experience\n\n> 借贷宝 (2018年2月 - 至今) \n  服务端研发实习 \n  支付应用研发部 \n   \n> 青岛孔雀网络科技有限公司(2017年4月 - 2017年10月)\n  服务端研发实习\n  孔雀云平台   \n  \n\n### Gmail\n> xuxiaofei4519@gmail.com\n\n\n","updated":"2018-08-12T08:44:32.083Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjottiq650006m9cgx8jq7rpj","content":"<h3 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h3><blockquote>\n<p>博主现在是一名大四学生，现是北京某互联网金融公司一名服务端开发实习生，主要从事支付相关业务的开发。搭建此博客的目的主要是想和大家一起分享自己的一些收获，本人现在是小白一个，文章如有不正之处，还望各位大神多多指教。<br>微博:Xander·Xu</p>\n</blockquote>\n<h3 id=\"Education\"><a href=\"#Education\" class=\"headerlink\" title=\"Education\"></a>Education</h3><blockquote>\n<p>2014 - 2018, 青岛科技大学, 本科, 物联网工程</p>\n</blockquote>\n<h3 id=\"Work-Experience\"><a href=\"#Work-Experience\" class=\"headerlink\" title=\"Work Experience\"></a>Work Experience</h3><blockquote>\n<p>借贷宝 (2018年2月 - 至今)<br>  服务端研发实习<br>  支付应用研发部 </p>\n</blockquote>\n<blockquote>\n<p>青岛孔雀网络科技有限公司(2017年4月 - 2017年10月)<br>  服务端研发实习<br>  孔雀云平台   </p>\n</blockquote>\n<h3 id=\"Gmail\"><a href=\"#Gmail\" class=\"headerlink\" title=\"Gmail\"></a>Gmail</h3><blockquote>\n<p><a href=\"mailto:xuxiaofei4519@gmail.com\" target=\"_blank\" rel=\"noopener\">xuxiaofei4519@gmail.com</a></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"About\"><a href=\"#About\" class=\"headerlink\" title=\"About\"></a>About</h3><blockquote>\n<p>博主现在是一名大四学生，现是北京某互联网金融公司一名服务端开发实习生，主要从事支付相关业务的开发。搭建此博客的目的主要是想和大家一起分享自己的一些收获，本人现在是小白一个，文章如有不正之处，还望各位大神多多指教。<br>微博:Xander·Xu</p>\n</blockquote>\n<h3 id=\"Education\"><a href=\"#Education\" class=\"headerlink\" title=\"Education\"></a>Education</h3><blockquote>\n<p>2014 - 2018, 青岛科技大学, 本科, 物联网工程</p>\n</blockquote>\n<h3 id=\"Work-Experience\"><a href=\"#Work-Experience\" class=\"headerlink\" title=\"Work Experience\"></a>Work Experience</h3><blockquote>\n<p>借贷宝 (2018年2月 - 至今)<br>  服务端研发实习<br>  支付应用研发部 </p>\n</blockquote>\n<blockquote>\n<p>青岛孔雀网络科技有限公司(2017年4月 - 2017年10月)<br>  服务端研发实习<br>  孔雀云平台   </p>\n</blockquote>\n<h3 id=\"Gmail\"><a href=\"#Gmail\" class=\"headerlink\" title=\"Gmail\"></a>Gmail</h3><blockquote>\n<p><a href=\"mailto:xuxiaofei4519@gmail.com\" target=\"_blank\" rel=\"noopener\">xuxiaofei4519@gmail.com</a></p>\n</blockquote>\n"},{"title":"分类","date":"2018-04-14T02:53:49.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2018-04-14 10:53:49\ntype: \"categories\"\n---\n","updated":"2018-08-12T08:44:32.083Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjottiq670008m9cgg1q6yhh7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2018-04-14T02:46:38.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2018-04-14 10:46:38\ntype: \"tags\"\n---\n","updated":"2018-08-12T08:44:32.092Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjottiq6b000cm9cge4nb5qoi","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"手写平衡二叉树(AVL)","date":"2018-11-23T09:12:09.000Z","copyright":true,"_content":"\n\n{% cq %} \n最近看到纯洁的微笑在微信公众号分享了一篇平衡二叉树（AVL）的博客，正好之前想要学习这一块，因此就一遍学习一遍手写平衡二叉树，\n在注释中加入自己的理解，学习过程中发现这篇博客实现的二叉树有问题，查阅相关资料，最终手写成功。编程之道：光靠脑子编程只能是别人的编程，只有自己手动实现的才叫自己的编程。\n{% endcq %}\n<!-- more -->\n\n* * *\n\n>以下代码纯手动实现，如有问题，及时留言。\n\n#### 手动实现源码\n```java\n/**\n * 平衡二叉树 AVL实现\n */\npublic class AVLBalanceTree {\n\n    //根节点\n    private AVLNode root;\n    //节点数\n    private Integer size;\n\n    public AVLBalanceTree() {\n    }\n\n    public AVLBalanceTree(AVLNode root) {\n        this.root = root;\n    }\n\n\n    /**\n     * 节点类\n     */\n    @Data\n    private static class AVLNode{\n        //节点值\n        private Integer value;\n        //节点高度\n        private Integer height;\n        //左子节点\n        private AVLNode leftNode;\n        //右子节点\n        private AVLNode rightNode;\n\n        public AVLNode(Integer value) {\n            //新节点的高度默认是0\n            new AVLNode(value,0,null,null);\n        }\n\n        public AVLNode(Integer value, Integer height, AVLNode leftNode, AVLNode rightNode) {\n            this.value = value;\n            this.height = height;\n            this.leftNode = leftNode;\n            this.rightNode = rightNode;\n        }\n\n    }\n\n    /**\n     * 插入操作\n     * @param value  插入值为Integer类型\n     */\n    public void insert(Integer value) throws Exception {\n        if (null == this.root){\n            initRoot(value);\n            size++;\n            return;\n        }\n        if (!constains(value))\n            throw new Exception(\"该值已经存在\");\n\n\n    }\n\n    /**\n     * 初始化根节点\n     */\n    private void initRoot(Integer value){\n        this.root = new AVLNode(value);\n        System.out.println(\"root:\" + this.root.getValue());\n    }\n\n\n    /**\n     * 查询是否包含该val\n     * @param val\n     * @return boolean值\n     */\n    private boolean constains(Integer val){\n        AVLNode currentNode = root;\n        if (null == currentNode)\n            return false;\n\n        while (null != currentNode){\n            if (val > currentNode.getValue()){\n                currentNode = currentNode.getRightNode();\n            } else if (val < currentNode.getValue()){\n                currentNode = currentNode.getLeftNode();\n            } else {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * 插入操作\n     */\n    private AVLNode insert(AVLNode parent,Integer val){\n        if (parent == null){\n            return createSimpleNode(val);\n        }\n\n        if (val < parent.getValue()){\n            parent.setLeftNode(insert(parent.getLeftNode(), val));\n\n            //在每一个递归层级上都要进行节点的平衡判断\n            // 左子节点添加节点，左子节点高度减去右子节点高度来判断是否平衡。仔细思考不可能出现负值\n            if (height(parent.getLeftNode()) - height(parent.getRightNode()) > 1){\n                //使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。\n                Integer compareVal = parent.getLeftNode().getValue();\n\n\n                if (val < compareVal){ // val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转\n                    leftLeftRotate(parent);\n                }else { // val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转\n                    leftRightRotate(parent);\n                }\n            }\n        }\n        if (val > parent.getValue()){\n            parent.setRightNode(insert(parent.getRightNode(), val));\n            // 右子节点添加节点，右子节点高度减去左子节点高度来判断是否平衡。仔细思考不可能出现负值\n            if (height(parent.getRightNode()) - height(parent.getLeftNode()) > 1){\n                //使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。\n                Integer compareVal = parent.getRightNode().getValue();\n\n\n                if (val > compareVal){  // val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转\n                    rightRightRotate(parent);\n                }else { // val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转\n                    rightLeftRotate(parent);\n                }\n            }\n        }\n\n        /**\n         * 插入成功以后都要递归将parent的节点高度加1\n         */\n        parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n        return parent;\n    }\n\n    public AVLNode remove(AVLNode parent, Integer val){\n        if (val < parent.getValue()){\n            //递归左节点\n            parent.setLeftNode(remove(parent.getLeftNode(), val));\n            //重新计算当前节点高度\n            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n            //只有左节点的高度低于右节点的高度的时候，删除左节点会导致不平衡。左节点比右节点最多高1，因此不可能出现负值。\n            if (height(parent.getRightNode()) - height(parent.getLeftNode()) > 1){\n                //进入到该if条件说明删除左节点后，右节点高度变高。parent节点失衡\n\n                //获取parent的右节点\n                AVLNode tempNode = parent.getRightNode();\n                if (height(tempNode.getLeftNode()) > height(tempNode.getRightNode())){\n                    rightLeftRotate(parent);\n                }else {\n                    rightRightRotate(parent);\n                }\n            }\n            //因为是删除左节点，调整右节点因此高度不用++\n        }else if (val > parent.getValue()){\n            //遍历右子树\n            parent.setRightNode(remove(parent.getRightNode(), val));\n            //重新计算当前节点高度\n            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n            //右节点\n            if (height(parent.getLeftNode()) - height(parent.getRightNode()) > 1){\n                //进入到该if条件说明删除右节点后，左节点高度变高。parent节点失衡\n\n                //获取parent的左节点\n                AVLNode tempNode = parent.getLeftNode();\n                if (height(tempNode.getRightNode()) > height(tempNode.getLeftNode())){\n                    leftRightRotate(parent);\n                }else {\n                    leftLeftRotate(parent);\n                }\n            }\n            //因为是删除右节点，调整左节点因此高度不用++\n        }else {\n            //找到该节点，匹配成功\n\n            //如果该节点的左右子节点都不为空\n            if (parent.getLeftNode() != null && parent.getRightNode() != null){\n                // 选择替代节点的条件：\n                // 1.小于parent(即将被删除)节点，大于parent(即将被删除)左树节点中任意节点.\n                // 2.大于parent(即将被删除)节点，小于parent(即将被删除)右树节点中任意节点。\n                // 满足上述任意条件即可吗，那么就是选择删除左树和右树节点的问题了。为了平衡，左树，右树哪个高度最高就从中选择替代节点。\n                // 步骤：\n                //    先查找满足条件的节点赋值给替代节点保留，然后删除左树或右树中的该节点，设置替代节点的左右节点，重新计算左右节点高度，\n                //    返回给外部(上一层级)递归层级，外部递归层级中会将该重新赋值为替代节点。\n\n\n\n                if (height(parent.getLeftNode()) > height(parent.getRightNode())){\n                    //要删除节点即parent，如果它的左节点的高度>右节点高度，那就选出左树节点最大的节点作为parent节点的替代节点，\n                    //该替代节点(maxNode)一定小于要被删除的节点(parent)。正好满足替代条件\n\n                    //获取替代节点并保留\n                    AVLNode maxValue = getMaxNode(parent.getLeftNode());\n                    //递归删除左树中的替代节点\n                    parent.setLeftNode(remove(parent.getLeftNode(), maxValue.getValue()));\n                    //设置替代节点的左右节点为parent的左右节点\n                    maxValue.setLeftNode(parent.getLeftNode());\n                    maxValue.setRightNode(parent.getRightNode());\n                    //重新计算替代节点的高度\n                    maxValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n                    //返回给外部递归层级\n                    return maxValue;\n                }else {\n                    //要删除节点即parent，如果它的左节点的高度<=右节点高度，那就选出右树节点最小的节点作为parent节点的替代节点，\n                    //该替代节点(minNode)一定大于要被删除的节点(parent)。正好满足替代条件\n\n                    //获取替代节点并保留\n                    AVLNode minValue = getMinNode(parent.getRightNode());\n                    //递归删除右树中的替代节点\n                    parent.setRightNode(remove(parent.getRightNode(), minValue.getValue()));\n                    //设置替代节点的左右节点为parent的左右节点\n                    minValue.setLeftNode(parent.getLeftNode());\n                    minValue.setRightNode(parent.getRightNode());\n                    //重新计算替代节点的高度\n                    minValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n                    //返回给外部递归层级\n                    return minValue;\n                }\n            }else {\n                // 如果左右节点中有任意一个为空\n                if (parent.getLeftNode() != null || parent.getRightNode() != null) {\n                    parent = parent.getLeftNode() == null ? parent.getRightNode() : parent.getLeftNode();\n                }else {\n                    parent = null;\n                }\n            }\n        }\n\n        return parent;\n    }\n\n    /**\n     * 获取值最大节点\n     */\n    private AVLNode getMaxNode(AVLNode currentNode){\n        if (currentNode != null){\n            currentNode = getMaxNode(currentNode.getRightNode());\n        }\n        return currentNode;\n    }\n\n    /**\n     * 获取值最小节点\n     */\n    private AVLNode getMinNode(AVLNode currentNode){\n        if (currentNode != null) {\n            currentNode = getMinNode(currentNode.getLeftNode());\n        }\n        return currentNode;\n    }\n\n    private AVLNode createSimpleNode(Integer val){\n        return new AVLNode(val);\n    }\n\n    /**\n     * 求一个节点的高度\n     * @param avlNode 节点对象\n     * @return 返回高度值\n     */\n    private Integer height(AVLNode avlNode){\n        //空节点高度默认是-1\n        return avlNode == null ? -1 : avlNode.getHeight();\n    }\n\n    /**\n     * 获取左右节点中高度最大的值\n     * @param leftNodo 左节点\n     * @param rightNode 右节点\n     * @return 最大节点的高度\n     */\n    private Integer maxHeight(AVLNode leftNodo, AVLNode rightNode){\n        return height(leftNodo) > height(rightNode) ? height(leftNodo) : height(rightNode);\n    }\n\n    /**\n     * 左左旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode leftLeftRotate(AVLNode avlNode){\n        //让node节点的\n        AVLNode newAvlNode = avlNode.getLeftNode();\n        avlNode.setLeftNode(newAvlNode.getRightNode());\n        newAvlNode.setRightNode(avlNode);\n\n        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + 1);\n        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + 1);\n        return newAvlNode;\n    }\n\n    /**\n     * 右右旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode rightRightRotate(AVLNode avlNode){\n        AVLNode newAvlNode = avlNode.getRightNode();\n        avlNode.setRightNode(newAvlNode.getLeftNode());\n        newAvlNode.setLeftNode(newAvlNode);\n\n        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + 1);\n        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + 1);\n        return newAvlNode;\n    }\n\n    /**\n     * 左右旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode leftRightRotate(AVLNode avlNode){\n        avlNode.setLeftNode(rightRightRotate(avlNode.getLeftNode()));\n        return leftLeftRotate(avlNode);\n    }\n\n    /**\n     * 右左旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode rightLeftRotate(AVLNode avlNode){\n        avlNode.setRightNode(leftLeftRotate(avlNode.getRightNode()));\n        return rightRightRotate(avlNode);\n    }\n\n}\n\n```","source":"_posts/dataStructure-AVL.md","raw":"---\ntitle: 手写平衡二叉树(AVL)\ndate: 2018-11-23 17:12:09\ncopyright: true\ntags:\n - dataStructure\ncategories:\n - dataStructure\n---\n\n\n{% cq %} \n最近看到纯洁的微笑在微信公众号分享了一篇平衡二叉树（AVL）的博客，正好之前想要学习这一块，因此就一遍学习一遍手写平衡二叉树，\n在注释中加入自己的理解，学习过程中发现这篇博客实现的二叉树有问题，查阅相关资料，最终手写成功。编程之道：光靠脑子编程只能是别人的编程，只有自己手动实现的才叫自己的编程。\n{% endcq %}\n<!-- more -->\n\n* * *\n\n>以下代码纯手动实现，如有问题，及时留言。\n\n#### 手动实现源码\n```java\n/**\n * 平衡二叉树 AVL实现\n */\npublic class AVLBalanceTree {\n\n    //根节点\n    private AVLNode root;\n    //节点数\n    private Integer size;\n\n    public AVLBalanceTree() {\n    }\n\n    public AVLBalanceTree(AVLNode root) {\n        this.root = root;\n    }\n\n\n    /**\n     * 节点类\n     */\n    @Data\n    private static class AVLNode{\n        //节点值\n        private Integer value;\n        //节点高度\n        private Integer height;\n        //左子节点\n        private AVLNode leftNode;\n        //右子节点\n        private AVLNode rightNode;\n\n        public AVLNode(Integer value) {\n            //新节点的高度默认是0\n            new AVLNode(value,0,null,null);\n        }\n\n        public AVLNode(Integer value, Integer height, AVLNode leftNode, AVLNode rightNode) {\n            this.value = value;\n            this.height = height;\n            this.leftNode = leftNode;\n            this.rightNode = rightNode;\n        }\n\n    }\n\n    /**\n     * 插入操作\n     * @param value  插入值为Integer类型\n     */\n    public void insert(Integer value) throws Exception {\n        if (null == this.root){\n            initRoot(value);\n            size++;\n            return;\n        }\n        if (!constains(value))\n            throw new Exception(\"该值已经存在\");\n\n\n    }\n\n    /**\n     * 初始化根节点\n     */\n    private void initRoot(Integer value){\n        this.root = new AVLNode(value);\n        System.out.println(\"root:\" + this.root.getValue());\n    }\n\n\n    /**\n     * 查询是否包含该val\n     * @param val\n     * @return boolean值\n     */\n    private boolean constains(Integer val){\n        AVLNode currentNode = root;\n        if (null == currentNode)\n            return false;\n\n        while (null != currentNode){\n            if (val > currentNode.getValue()){\n                currentNode = currentNode.getRightNode();\n            } else if (val < currentNode.getValue()){\n                currentNode = currentNode.getLeftNode();\n            } else {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * 插入操作\n     */\n    private AVLNode insert(AVLNode parent,Integer val){\n        if (parent == null){\n            return createSimpleNode(val);\n        }\n\n        if (val < parent.getValue()){\n            parent.setLeftNode(insert(parent.getLeftNode(), val));\n\n            //在每一个递归层级上都要进行节点的平衡判断\n            // 左子节点添加节点，左子节点高度减去右子节点高度来判断是否平衡。仔细思考不可能出现负值\n            if (height(parent.getLeftNode()) - height(parent.getRightNode()) > 1){\n                //使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。\n                Integer compareVal = parent.getLeftNode().getValue();\n\n\n                if (val < compareVal){ // val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转\n                    leftLeftRotate(parent);\n                }else { // val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转\n                    leftRightRotate(parent);\n                }\n            }\n        }\n        if (val > parent.getValue()){\n            parent.setRightNode(insert(parent.getRightNode(), val));\n            // 右子节点添加节点，右子节点高度减去左子节点高度来判断是否平衡。仔细思考不可能出现负值\n            if (height(parent.getRightNode()) - height(parent.getLeftNode()) > 1){\n                //使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。\n                Integer compareVal = parent.getRightNode().getValue();\n\n\n                if (val > compareVal){  // val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转\n                    rightRightRotate(parent);\n                }else { // val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转\n                    rightLeftRotate(parent);\n                }\n            }\n        }\n\n        /**\n         * 插入成功以后都要递归将parent的节点高度加1\n         */\n        parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n        return parent;\n    }\n\n    public AVLNode remove(AVLNode parent, Integer val){\n        if (val < parent.getValue()){\n            //递归左节点\n            parent.setLeftNode(remove(parent.getLeftNode(), val));\n            //重新计算当前节点高度\n            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n            //只有左节点的高度低于右节点的高度的时候，删除左节点会导致不平衡。左节点比右节点最多高1，因此不可能出现负值。\n            if (height(parent.getRightNode()) - height(parent.getLeftNode()) > 1){\n                //进入到该if条件说明删除左节点后，右节点高度变高。parent节点失衡\n\n                //获取parent的右节点\n                AVLNode tempNode = parent.getRightNode();\n                if (height(tempNode.getLeftNode()) > height(tempNode.getRightNode())){\n                    rightLeftRotate(parent);\n                }else {\n                    rightRightRotate(parent);\n                }\n            }\n            //因为是删除左节点，调整右节点因此高度不用++\n        }else if (val > parent.getValue()){\n            //遍历右子树\n            parent.setRightNode(remove(parent.getRightNode(), val));\n            //重新计算当前节点高度\n            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n            //右节点\n            if (height(parent.getLeftNode()) - height(parent.getRightNode()) > 1){\n                //进入到该if条件说明删除右节点后，左节点高度变高。parent节点失衡\n\n                //获取parent的左节点\n                AVLNode tempNode = parent.getLeftNode();\n                if (height(tempNode.getRightNode()) > height(tempNode.getLeftNode())){\n                    leftRightRotate(parent);\n                }else {\n                    leftLeftRotate(parent);\n                }\n            }\n            //因为是删除右节点，调整左节点因此高度不用++\n        }else {\n            //找到该节点，匹配成功\n\n            //如果该节点的左右子节点都不为空\n            if (parent.getLeftNode() != null && parent.getRightNode() != null){\n                // 选择替代节点的条件：\n                // 1.小于parent(即将被删除)节点，大于parent(即将被删除)左树节点中任意节点.\n                // 2.大于parent(即将被删除)节点，小于parent(即将被删除)右树节点中任意节点。\n                // 满足上述任意条件即可吗，那么就是选择删除左树和右树节点的问题了。为了平衡，左树，右树哪个高度最高就从中选择替代节点。\n                // 步骤：\n                //    先查找满足条件的节点赋值给替代节点保留，然后删除左树或右树中的该节点，设置替代节点的左右节点，重新计算左右节点高度，\n                //    返回给外部(上一层级)递归层级，外部递归层级中会将该重新赋值为替代节点。\n\n\n\n                if (height(parent.getLeftNode()) > height(parent.getRightNode())){\n                    //要删除节点即parent，如果它的左节点的高度>右节点高度，那就选出左树节点最大的节点作为parent节点的替代节点，\n                    //该替代节点(maxNode)一定小于要被删除的节点(parent)。正好满足替代条件\n\n                    //获取替代节点并保留\n                    AVLNode maxValue = getMaxNode(parent.getLeftNode());\n                    //递归删除左树中的替代节点\n                    parent.setLeftNode(remove(parent.getLeftNode(), maxValue.getValue()));\n                    //设置替代节点的左右节点为parent的左右节点\n                    maxValue.setLeftNode(parent.getLeftNode());\n                    maxValue.setRightNode(parent.getRightNode());\n                    //重新计算替代节点的高度\n                    maxValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n                    //返回给外部递归层级\n                    return maxValue;\n                }else {\n                    //要删除节点即parent，如果它的左节点的高度<=右节点高度，那就选出右树节点最小的节点作为parent节点的替代节点，\n                    //该替代节点(minNode)一定大于要被删除的节点(parent)。正好满足替代条件\n\n                    //获取替代节点并保留\n                    AVLNode minValue = getMinNode(parent.getRightNode());\n                    //递归删除右树中的替代节点\n                    parent.setRightNode(remove(parent.getRightNode(), minValue.getValue()));\n                    //设置替代节点的左右节点为parent的左右节点\n                    minValue.setLeftNode(parent.getLeftNode());\n                    minValue.setRightNode(parent.getRightNode());\n                    //重新计算替代节点的高度\n                    minValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + 1);\n                    //返回给外部递归层级\n                    return minValue;\n                }\n            }else {\n                // 如果左右节点中有任意一个为空\n                if (parent.getLeftNode() != null || parent.getRightNode() != null) {\n                    parent = parent.getLeftNode() == null ? parent.getRightNode() : parent.getLeftNode();\n                }else {\n                    parent = null;\n                }\n            }\n        }\n\n        return parent;\n    }\n\n    /**\n     * 获取值最大节点\n     */\n    private AVLNode getMaxNode(AVLNode currentNode){\n        if (currentNode != null){\n            currentNode = getMaxNode(currentNode.getRightNode());\n        }\n        return currentNode;\n    }\n\n    /**\n     * 获取值最小节点\n     */\n    private AVLNode getMinNode(AVLNode currentNode){\n        if (currentNode != null) {\n            currentNode = getMinNode(currentNode.getLeftNode());\n        }\n        return currentNode;\n    }\n\n    private AVLNode createSimpleNode(Integer val){\n        return new AVLNode(val);\n    }\n\n    /**\n     * 求一个节点的高度\n     * @param avlNode 节点对象\n     * @return 返回高度值\n     */\n    private Integer height(AVLNode avlNode){\n        //空节点高度默认是-1\n        return avlNode == null ? -1 : avlNode.getHeight();\n    }\n\n    /**\n     * 获取左右节点中高度最大的值\n     * @param leftNodo 左节点\n     * @param rightNode 右节点\n     * @return 最大节点的高度\n     */\n    private Integer maxHeight(AVLNode leftNodo, AVLNode rightNode){\n        return height(leftNodo) > height(rightNode) ? height(leftNodo) : height(rightNode);\n    }\n\n    /**\n     * 左左旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode leftLeftRotate(AVLNode avlNode){\n        //让node节点的\n        AVLNode newAvlNode = avlNode.getLeftNode();\n        avlNode.setLeftNode(newAvlNode.getRightNode());\n        newAvlNode.setRightNode(avlNode);\n\n        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + 1);\n        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + 1);\n        return newAvlNode;\n    }\n\n    /**\n     * 右右旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode rightRightRotate(AVLNode avlNode){\n        AVLNode newAvlNode = avlNode.getRightNode();\n        avlNode.setRightNode(newAvlNode.getLeftNode());\n        newAvlNode.setLeftNode(newAvlNode);\n\n        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + 1);\n        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + 1);\n        return newAvlNode;\n    }\n\n    /**\n     * 左右旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode leftRightRotate(AVLNode avlNode){\n        avlNode.setLeftNode(rightRightRotate(avlNode.getLeftNode()));\n        return leftLeftRotate(avlNode);\n    }\n\n    /**\n     * 右左旋转\n     * @param avlNode 旋转之前的父节点\n     * @return 旋转之后的父节点\n     */\n    private AVLNode rightLeftRotate(AVLNode avlNode){\n        avlNode.setRightNode(leftLeftRotate(avlNode.getRightNode()));\n        return rightRightRotate(avlNode);\n    }\n\n}\n\n```","slug":"dataStructure-AVL","published":1,"updated":"2018-11-23T09:21:25.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq270000m9cg0scxozmf","content":"<blockquote class=\"blockquote-center\"><p>最近看到纯洁的微笑在微信公众号分享了一篇平衡二叉树（AVL）的博客，正好之前想要学习这一块，因此就一遍学习一遍手写平衡二叉树，<br>在注释中加入自己的理解，学习过程中发现这篇博客实现的二叉树有问题，查阅相关资料，最终手写成功。编程之道：光靠脑子编程只能是别人的编程，只有自己手动实现的才叫自己的编程。</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<blockquote>\n<p>以下代码纯手动实现，如有问题，及时留言。</p>\n</blockquote>\n<h4 id=\"手动实现源码\"><a href=\"#手动实现源码\" class=\"headerlink\" title=\"手动实现源码\"></a>手动实现源码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 平衡二叉树 AVL实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLBalanceTree</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AVLNode root;</span><br><span class=\"line\">    <span class=\"comment\">//节点数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLBalanceTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLBalanceTree</span><span class=\"params\">(AVLNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 节点类</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Data</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLNode</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//节点值</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer value;</span><br><span class=\"line\">        <span class=\"comment\">//节点高度</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer height;</span><br><span class=\"line\">        <span class=\"comment\">//左子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> AVLNode leftNode;</span><br><span class=\"line\">        <span class=\"comment\">//右子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> AVLNode rightNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLNode</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//新节点的高度默认是0</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> AVLNode(value,<span class=\"number\">0</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLNode</span><span class=\"params\">(Integer value, Integer height, AVLNode leftNode, AVLNode rightNode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.leftNode = leftNode;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.rightNode = rightNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入操作</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value  插入值为Integer类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Integer value)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.root)&#123;</span><br><span class=\"line\">            initRoot(value);</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!constains(value))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"该值已经存在\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化根节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initRoot</span><span class=\"params\">(Integer value)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> AVLNode(value);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"root:\"</span> + <span class=\"keyword\">this</span>.root.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询是否包含该val</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> val</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> boolean值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">constains</span><span class=\"params\">(Integer val)</span></span>&#123;</span><br><span class=\"line\">        AVLNode currentNode = root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == currentNode)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">null</span> != currentNode)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; currentNode.getValue())&#123;</span><br><span class=\"line\">                currentNode = currentNode.getRightNode();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; currentNode.getValue())&#123;</span><br><span class=\"line\">                currentNode = currentNode.getLeftNode();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入操作</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">insert</span><span class=\"params\">(AVLNode parent,Integer val)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createSimpleNode(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &lt; parent.getValue())&#123;</span><br><span class=\"line\">            parent.setLeftNode(insert(parent.getLeftNode(), val));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//在每一个递归层级上都要进行节点的平衡判断</span></span><br><span class=\"line\">            <span class=\"comment\">// 左子节点添加节点，左子节点高度减去右子节点高度来判断是否平衡。仔细思考不可能出现负值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getLeftNode()) - height(parent.getRightNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。</span></span><br><span class=\"line\">                Integer compareVal = parent.getLeftNode().getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val &lt; compareVal)&#123; <span class=\"comment\">// val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转</span></span><br><span class=\"line\">                    leftLeftRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转</span></span><br><span class=\"line\">                    leftRightRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &gt; parent.getValue())&#123;</span><br><span class=\"line\">            parent.setRightNode(insert(parent.getRightNode(), val));</span><br><span class=\"line\">            <span class=\"comment\">// 右子节点添加节点，右子节点高度减去左子节点高度来判断是否平衡。仔细思考不可能出现负值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getRightNode()) - height(parent.getLeftNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。</span></span><br><span class=\"line\">                Integer compareVal = parent.getRightNode().getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val &gt; compareVal)&#123;  <span class=\"comment\">// val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转</span></span><br><span class=\"line\">                    rightRightRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转</span></span><br><span class=\"line\">                    rightLeftRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 插入成功以后都要递归将parent的节点高度加1</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AVLNode <span class=\"title\">remove</span><span class=\"params\">(AVLNode parent, Integer val)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &lt; parent.getValue())&#123;</span><br><span class=\"line\">            <span class=\"comment\">//递归左节点</span></span><br><span class=\"line\">            parent.setLeftNode(remove(parent.getLeftNode(), val));</span><br><span class=\"line\">            <span class=\"comment\">//重新计算当前节点高度</span></span><br><span class=\"line\">            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//只有左节点的高度低于右节点的高度的时候，删除左节点会导致不平衡。左节点比右节点最多高1，因此不可能出现负值。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getRightNode()) - height(parent.getLeftNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进入到该if条件说明删除左节点后，右节点高度变高。parent节点失衡</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//获取parent的右节点</span></span><br><span class=\"line\">                AVLNode tempNode = parent.getRightNode();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height(tempNode.getLeftNode()) &gt; height(tempNode.getRightNode()))&#123;</span><br><span class=\"line\">                    rightLeftRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    rightRightRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//因为是删除左节点，调整右节点因此高度不用++</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &gt; parent.getValue())&#123;</span><br><span class=\"line\">            <span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">            parent.setRightNode(remove(parent.getRightNode(), val));</span><br><span class=\"line\">            <span class=\"comment\">//重新计算当前节点高度</span></span><br><span class=\"line\">            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//右节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getLeftNode()) - height(parent.getRightNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进入到该if条件说明删除右节点后，左节点高度变高。parent节点失衡</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//获取parent的左节点</span></span><br><span class=\"line\">                AVLNode tempNode = parent.getLeftNode();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height(tempNode.getRightNode()) &gt; height(tempNode.getLeftNode()))&#123;</span><br><span class=\"line\">                    leftRightRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    leftLeftRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//因为是删除右节点，调整左节点因此高度不用++</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到该节点，匹配成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果该节点的左右子节点都不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent.getLeftNode() != <span class=\"keyword\">null</span> &amp;&amp; parent.getRightNode() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 选择替代节点的条件：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1.小于parent(即将被删除)节点，大于parent(即将被删除)左树节点中任意节点.</span></span><br><span class=\"line\">                <span class=\"comment\">// 2.大于parent(即将被删除)节点，小于parent(即将被删除)右树节点中任意节点。</span></span><br><span class=\"line\">                <span class=\"comment\">// 满足上述任意条件即可吗，那么就是选择删除左树和右树节点的问题了。为了平衡，左树，右树哪个高度最高就从中选择替代节点。</span></span><br><span class=\"line\">                <span class=\"comment\">// 步骤：</span></span><br><span class=\"line\">                <span class=\"comment\">//    先查找满足条件的节点赋值给替代节点保留，然后删除左树或右树中的该节点，设置替代节点的左右节点，重新计算左右节点高度，</span></span><br><span class=\"line\">                <span class=\"comment\">//    返回给外部(上一层级)递归层级，外部递归层级中会将该重新赋值为替代节点。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height(parent.getLeftNode()) &gt; height(parent.getRightNode()))&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//要删除节点即parent，如果它的左节点的高度&gt;右节点高度，那就选出左树节点最大的节点作为parent节点的替代节点，</span></span><br><span class=\"line\">                    <span class=\"comment\">//该替代节点(maxNode)一定小于要被删除的节点(parent)。正好满足替代条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//获取替代节点并保留</span></span><br><span class=\"line\">                    AVLNode maxValue = getMaxNode(parent.getLeftNode());</span><br><span class=\"line\">                    <span class=\"comment\">//递归删除左树中的替代节点</span></span><br><span class=\"line\">                    parent.setLeftNode(remove(parent.getLeftNode(), maxValue.getValue()));</span><br><span class=\"line\">                    <span class=\"comment\">//设置替代节点的左右节点为parent的左右节点</span></span><br><span class=\"line\">                    maxValue.setLeftNode(parent.getLeftNode());</span><br><span class=\"line\">                    maxValue.setRightNode(parent.getRightNode());</span><br><span class=\"line\">                    <span class=\"comment\">//重新计算替代节点的高度</span></span><br><span class=\"line\">                    maxValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//返回给外部递归层级</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> maxValue;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//要删除节点即parent，如果它的左节点的高度&lt;=右节点高度，那就选出右树节点最小的节点作为parent节点的替代节点，</span></span><br><span class=\"line\">                    <span class=\"comment\">//该替代节点(minNode)一定大于要被删除的节点(parent)。正好满足替代条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//获取替代节点并保留</span></span><br><span class=\"line\">                    AVLNode minValue = getMinNode(parent.getRightNode());</span><br><span class=\"line\">                    <span class=\"comment\">//递归删除右树中的替代节点</span></span><br><span class=\"line\">                    parent.setRightNode(remove(parent.getRightNode(), minValue.getValue()));</span><br><span class=\"line\">                    <span class=\"comment\">//设置替代节点的左右节点为parent的左右节点</span></span><br><span class=\"line\">                    minValue.setLeftNode(parent.getLeftNode());</span><br><span class=\"line\">                    minValue.setRightNode(parent.getRightNode());</span><br><span class=\"line\">                    <span class=\"comment\">//重新计算替代节点的高度</span></span><br><span class=\"line\">                    minValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//返回给外部递归层级</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> minValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果左右节点中有任意一个为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parent.getLeftNode() != <span class=\"keyword\">null</span> || parent.getRightNode() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    parent = parent.getLeftNode() == <span class=\"keyword\">null</span> ? parent.getRightNode() : parent.getLeftNode();</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取值最大节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">getMaxNode</span><span class=\"params\">(AVLNode currentNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            currentNode = getMaxNode(currentNode.getRightNode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取值最小节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">getMinNode</span><span class=\"params\">(AVLNode currentNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentNode = getMinNode(currentNode.getLeftNode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">createSimpleNode</span><span class=\"params\">(Integer val)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AVLNode(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 求一个节点的高度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 节点对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回高度值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Integer <span class=\"title\">height</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//空节点高度默认是-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> avlNode == <span class=\"keyword\">null</span> ? -<span class=\"number\">1</span> : avlNode.getHeight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取左右节点中高度最大的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftNodo 左节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> rightNode 右节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 最大节点的高度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Integer <span class=\"title\">maxHeight</span><span class=\"params\">(AVLNode leftNodo, AVLNode rightNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> height(leftNodo) &gt; height(rightNode) ? height(leftNodo) : height(rightNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 左左旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">leftLeftRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//让node节点的</span></span><br><span class=\"line\">        AVLNode newAvlNode = avlNode.getLeftNode();</span><br><span class=\"line\">        avlNode.setLeftNode(newAvlNode.getRightNode());</span><br><span class=\"line\">        newAvlNode.setRightNode(avlNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newAvlNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 右右旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">rightRightRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        AVLNode newAvlNode = avlNode.getRightNode();</span><br><span class=\"line\">        avlNode.setRightNode(newAvlNode.getLeftNode());</span><br><span class=\"line\">        newAvlNode.setLeftNode(newAvlNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newAvlNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 左右旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">leftRightRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        avlNode.setLeftNode(rightRightRotate(avlNode.getLeftNode()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftLeftRotate(avlNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 右左旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">rightLeftRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        avlNode.setRightNode(leftLeftRotate(avlNode.getRightNode()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rightRightRotate(avlNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>最近看到纯洁的微笑在微信公众号分享了一篇平衡二叉树（AVL）的博客，正好之前想要学习这一块，因此就一遍学习一遍手写平衡二叉树，<br>在注释中加入自己的理解，学习过程中发现这篇博客实现的二叉树有问题，查阅相关资料，最终手写成功。编程之道：光靠脑子编程只能是别人的编程，只有自己手动实现的才叫自己的编程。</p>\n</blockquote>","more":"<hr>\n<blockquote>\n<p>以下代码纯手动实现，如有问题，及时留言。</p>\n</blockquote>\n<h4 id=\"手动实现源码\"><a href=\"#手动实现源码\" class=\"headerlink\" title=\"手动实现源码\"></a>手动实现源码</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 平衡二叉树 AVL实现</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLBalanceTree</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//根节点</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AVLNode root;</span><br><span class=\"line\">    <span class=\"comment\">//节点数</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Integer size;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLBalanceTree</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLBalanceTree</span><span class=\"params\">(AVLNode root)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 节点类</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Data</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AVLNode</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//节点值</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer value;</span><br><span class=\"line\">        <span class=\"comment\">//节点高度</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> Integer height;</span><br><span class=\"line\">        <span class=\"comment\">//左子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> AVLNode leftNode;</span><br><span class=\"line\">        <span class=\"comment\">//右子节点</span></span><br><span class=\"line\">        <span class=\"keyword\">private</span> AVLNode rightNode;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLNode</span><span class=\"params\">(Integer value)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"comment\">//新节点的高度默认是0</span></span><br><span class=\"line\">            <span class=\"keyword\">new</span> AVLNode(value,<span class=\"number\">0</span>,<span class=\"keyword\">null</span>,<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">AVLNode</span><span class=\"params\">(Integer value, Integer height, AVLNode leftNode, AVLNode rightNode)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.height = height;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.leftNode = leftNode;</span><br><span class=\"line\">            <span class=\"keyword\">this</span>.rightNode = rightNode;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入操作</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> value  插入值为Integer类型</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Integer value)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == <span class=\"keyword\">this</span>.root)&#123;</span><br><span class=\"line\">            initRoot(value);</span><br><span class=\"line\">            size++;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!constains(value))</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Exception(<span class=\"string\">\"该值已经存在\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化根节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initRoot</span><span class=\"params\">(Integer value)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.root = <span class=\"keyword\">new</span> AVLNode(value);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"root:\"</span> + <span class=\"keyword\">this</span>.root.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询是否包含该val</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> val</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> boolean值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">constains</span><span class=\"params\">(Integer val)</span></span>&#123;</span><br><span class=\"line\">        AVLNode currentNode = root;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">null</span> == currentNode)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">null</span> != currentNode)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (val &gt; currentNode.getValue())&#123;</span><br><span class=\"line\">                currentNode = currentNode.getRightNode();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &lt; currentNode.getValue())&#123;</span><br><span class=\"line\">                currentNode = currentNode.getLeftNode();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 插入操作</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">insert</span><span class=\"params\">(AVLNode parent,Integer val)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (parent == <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> createSimpleNode(val);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &lt; parent.getValue())&#123;</span><br><span class=\"line\">            parent.setLeftNode(insert(parent.getLeftNode(), val));</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//在每一个递归层级上都要进行节点的平衡判断</span></span><br><span class=\"line\">            <span class=\"comment\">// 左子节点添加节点，左子节点高度减去右子节点高度来判断是否平衡。仔细思考不可能出现负值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getLeftNode()) - height(parent.getRightNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。</span></span><br><span class=\"line\">                Integer compareVal = parent.getLeftNode().getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val &lt; compareVal)&#123; <span class=\"comment\">// val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转</span></span><br><span class=\"line\">                    leftLeftRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转</span></span><br><span class=\"line\">                    leftRightRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &gt; parent.getValue())&#123;</span><br><span class=\"line\">            parent.setRightNode(insert(parent.getRightNode(), val));</span><br><span class=\"line\">            <span class=\"comment\">// 右子节点添加节点，右子节点高度减去左子节点高度来判断是否平衡。仔细思考不可能出现负值</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getRightNode()) - height(parent.getLeftNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//使用parent的左节点与val进行比较，从而判断val被放在了parent左节点的左边还是右边，根据位置不同进行不同的旋转。</span></span><br><span class=\"line\">                Integer compareVal = parent.getRightNode().getValue();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (val &gt; compareVal)&#123;  <span class=\"comment\">// val相当于第三个节点并且比parent的左节点(第二个节点)小的话就会进行左左旋转</span></span><br><span class=\"line\">                    rightRightRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123; <span class=\"comment\">// val相当于第三个节点并且比parent左节点(第二个节点)大的话就会进行左右旋转</span></span><br><span class=\"line\">                    rightLeftRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 插入成功以后都要递归将parent的节点高度加1</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> AVLNode <span class=\"title\">remove</span><span class=\"params\">(AVLNode parent, Integer val)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (val &lt; parent.getValue())&#123;</span><br><span class=\"line\">            <span class=\"comment\">//递归左节点</span></span><br><span class=\"line\">            parent.setLeftNode(remove(parent.getLeftNode(), val));</span><br><span class=\"line\">            <span class=\"comment\">//重新计算当前节点高度</span></span><br><span class=\"line\">            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//只有左节点的高度低于右节点的高度的时候，删除左节点会导致不平衡。左节点比右节点最多高1，因此不可能出现负值。</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getRightNode()) - height(parent.getLeftNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进入到该if条件说明删除左节点后，右节点高度变高。parent节点失衡</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//获取parent的右节点</span></span><br><span class=\"line\">                AVLNode tempNode = parent.getRightNode();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height(tempNode.getLeftNode()) &gt; height(tempNode.getRightNode()))&#123;</span><br><span class=\"line\">                    rightLeftRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    rightRightRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//因为是删除左节点，调整右节点因此高度不用++</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (val &gt; parent.getValue())&#123;</span><br><span class=\"line\">            <span class=\"comment\">//遍历右子树</span></span><br><span class=\"line\">            parent.setRightNode(remove(parent.getRightNode(), val));</span><br><span class=\"line\">            <span class=\"comment\">//重新计算当前节点高度</span></span><br><span class=\"line\">            parent.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"comment\">//右节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (height(parent.getLeftNode()) - height(parent.getRightNode()) &gt; <span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">//进入到该if条件说明删除右节点后，左节点高度变高。parent节点失衡</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">//获取parent的左节点</span></span><br><span class=\"line\">                AVLNode tempNode = parent.getLeftNode();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height(tempNode.getRightNode()) &gt; height(tempNode.getLeftNode()))&#123;</span><br><span class=\"line\">                    leftRightRotate(parent);</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    leftLeftRotate(parent);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//因为是删除右节点，调整左节点因此高度不用++</span></span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//找到该节点，匹配成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//如果该节点的左右子节点都不为空</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (parent.getLeftNode() != <span class=\"keyword\">null</span> &amp;&amp; parent.getRightNode() != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                <span class=\"comment\">// 选择替代节点的条件：</span></span><br><span class=\"line\">                <span class=\"comment\">// 1.小于parent(即将被删除)节点，大于parent(即将被删除)左树节点中任意节点.</span></span><br><span class=\"line\">                <span class=\"comment\">// 2.大于parent(即将被删除)节点，小于parent(即将被删除)右树节点中任意节点。</span></span><br><span class=\"line\">                <span class=\"comment\">// 满足上述任意条件即可吗，那么就是选择删除左树和右树节点的问题了。为了平衡，左树，右树哪个高度最高就从中选择替代节点。</span></span><br><span class=\"line\">                <span class=\"comment\">// 步骤：</span></span><br><span class=\"line\">                <span class=\"comment\">//    先查找满足条件的节点赋值给替代节点保留，然后删除左树或右树中的该节点，设置替代节点的左右节点，重新计算左右节点高度，</span></span><br><span class=\"line\">                <span class=\"comment\">//    返回给外部(上一层级)递归层级，外部递归层级中会将该重新赋值为替代节点。</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (height(parent.getLeftNode()) &gt; height(parent.getRightNode()))&#123;</span><br><span class=\"line\">                    <span class=\"comment\">//要删除节点即parent，如果它的左节点的高度&gt;右节点高度，那就选出左树节点最大的节点作为parent节点的替代节点，</span></span><br><span class=\"line\">                    <span class=\"comment\">//该替代节点(maxNode)一定小于要被删除的节点(parent)。正好满足替代条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//获取替代节点并保留</span></span><br><span class=\"line\">                    AVLNode maxValue = getMaxNode(parent.getLeftNode());</span><br><span class=\"line\">                    <span class=\"comment\">//递归删除左树中的替代节点</span></span><br><span class=\"line\">                    parent.setLeftNode(remove(parent.getLeftNode(), maxValue.getValue()));</span><br><span class=\"line\">                    <span class=\"comment\">//设置替代节点的左右节点为parent的左右节点</span></span><br><span class=\"line\">                    maxValue.setLeftNode(parent.getLeftNode());</span><br><span class=\"line\">                    maxValue.setRightNode(parent.getRightNode());</span><br><span class=\"line\">                    <span class=\"comment\">//重新计算替代节点的高度</span></span><br><span class=\"line\">                    maxValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//返回给外部递归层级</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> maxValue;</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//要删除节点即parent，如果它的左节点的高度&lt;=右节点高度，那就选出右树节点最小的节点作为parent节点的替代节点，</span></span><br><span class=\"line\">                    <span class=\"comment\">//该替代节点(minNode)一定大于要被删除的节点(parent)。正好满足替代条件</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"comment\">//获取替代节点并保留</span></span><br><span class=\"line\">                    AVLNode minValue = getMinNode(parent.getRightNode());</span><br><span class=\"line\">                    <span class=\"comment\">//递归删除右树中的替代节点</span></span><br><span class=\"line\">                    parent.setRightNode(remove(parent.getRightNode(), minValue.getValue()));</span><br><span class=\"line\">                    <span class=\"comment\">//设置替代节点的左右节点为parent的左右节点</span></span><br><span class=\"line\">                    minValue.setLeftNode(parent.getLeftNode());</span><br><span class=\"line\">                    minValue.setRightNode(parent.getRightNode());</span><br><span class=\"line\">                    <span class=\"comment\">//重新计算替代节点的高度</span></span><br><span class=\"line\">                    minValue.setHeight(maxHeight(parent.getLeftNode(), parent.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">                    <span class=\"comment\">//返回给外部递归层级</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> minValue;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 如果左右节点中有任意一个为空</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (parent.getLeftNode() != <span class=\"keyword\">null</span> || parent.getRightNode() != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    parent = parent.getLeftNode() == <span class=\"keyword\">null</span> ? parent.getRightNode() : parent.getLeftNode();</span><br><span class=\"line\">                &#125;<span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    parent = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> parent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取值最大节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">getMaxNode</span><span class=\"params\">(AVLNode currentNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            currentNode = getMaxNode(currentNode.getRightNode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取值最小节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">getMinNode</span><span class=\"params\">(AVLNode currentNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (currentNode != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            currentNode = getMinNode(currentNode.getLeftNode());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> currentNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">createSimpleNode</span><span class=\"params\">(Integer val)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> AVLNode(val);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 求一个节点的高度</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 节点对象</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 返回高度值</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Integer <span class=\"title\">height</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//空节点高度默认是-1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> avlNode == <span class=\"keyword\">null</span> ? -<span class=\"number\">1</span> : avlNode.getHeight();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 获取左右节点中高度最大的值</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> leftNodo 左节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> rightNode 右节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 最大节点的高度</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Integer <span class=\"title\">maxHeight</span><span class=\"params\">(AVLNode leftNodo, AVLNode rightNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> height(leftNodo) &gt; height(rightNode) ? height(leftNodo) : height(rightNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 左左旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">leftLeftRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//让node节点的</span></span><br><span class=\"line\">        AVLNode newAvlNode = avlNode.getLeftNode();</span><br><span class=\"line\">        avlNode.setLeftNode(newAvlNode.getRightNode());</span><br><span class=\"line\">        newAvlNode.setRightNode(avlNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newAvlNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 右右旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">rightRightRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        AVLNode newAvlNode = avlNode.getRightNode();</span><br><span class=\"line\">        avlNode.setRightNode(newAvlNode.getLeftNode());</span><br><span class=\"line\">        newAvlNode.setLeftNode(newAvlNode);</span><br><span class=\"line\"></span><br><span class=\"line\">        avlNode.setHeight(maxHeight(avlNode.getLeftNode(), avlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        newAvlNode.setHeight(maxHeight(newAvlNode.getLeftNode(), newAvlNode.getRightNode()) + <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> newAvlNode;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 左右旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">leftRightRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        avlNode.setLeftNode(rightRightRotate(avlNode.getLeftNode()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> leftLeftRotate(avlNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 右左旋转</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> avlNode 旋转之前的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span> 旋转之后的父节点</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> AVLNode <span class=\"title\">rightLeftRotate</span><span class=\"params\">(AVLNode avlNode)</span></span>&#123;</span><br><span class=\"line\">        avlNode.setRightNode(leftLeftRotate(avlNode.getRightNode()));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> rightRightRotate(avlNode);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"BTrace实战","date":"2018-08-05T12:40:09.000Z","copyright":true,"_content":"\n{% cq %} \n最近了解到关于java动态追踪工具BTrace的相关内容，决定实战一下，本文是针对BTrace的简单实战，未涉及过多详细内容\n{% endcq %}\n<!-- more -->\n\n### BTrace简介\n>Btrace (Byte Trace)是sun推出的一款java 动态、安全追踪（监控）工具，可以不停机的情况下监控线上情况，并且做到最少的侵入，占用最少的系统资源。BTrace应用较为广泛的原因应该是其安全性和无侵入性，其中热交互技术，使得我们无需启动Agent的情况下动态跟踪分析，其安全性不会导致对目标Java进程的任何破坏性影响，使得BTrace成为我们线上产品问题定位的利器。无侵入性无需我们对原有代码做任何修改，降低上线风险和测试成本，并且无需重启启动目标Java进程进行Agent加载即可动态分析和跟踪目标程序，可以说BTrace可以满足大部分的应用场景。\n\n### BTrace安装\n- 首先下载[release](https://github.com/btraceio/btrace)版本\n- 配置环境变量\n {% qnimg /java-BTrace/java-BTrace01.png %}\n- 验证是否安装成功\n {% qnimg /java-BTrace/java-BTrace02.png %}\n \n### BTrace实战\n- 测试用例(间隔一秒打印当前时间戳)\n {% qnimg /java-BTrace/java-BTrace03.png %}\n- 追踪脚本\n {% qnimg /java-BTrace/java-BTrace04.png %}\n- 追踪结果\n {% qnimg /java-BTrace/java-BTrace05.png %}\n \n\n### BTrace相关API含义\n#### 追踪时机\n- Kind.ENTRY  默认拦截方式，入口拦截\n- Kind.RETURN 拦截返回值\n- Kind.THROW 发生异常时拦截\n- Kind.LINE 拦截某一行\n- Kind.Call 被调用时拦截\n \n### BTrace使用限制\n- 不能创建对象\n- 不能创建数组\n- 不能抛出和捕获异常\n- 不能调用任何对象方法和静态方法\n- 不能给目标程序中的类静态属性和对象的属性进行赋值\n- 不能有外部、内部和嵌套类\n- 不能有同步块和同步方法\n- 不能有循环(for, while, do..while)\n- 不能继承任何的类\n- 不能实现接口\n- 不能包含assert断言语句\n\n\n\n","source":"_posts/java-BTrace.md","raw":"---\ntitle: BTrace实战\ndate: 2018-08-05 20:40:09\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n\n{% cq %} \n最近了解到关于java动态追踪工具BTrace的相关内容，决定实战一下，本文是针对BTrace的简单实战，未涉及过多详细内容\n{% endcq %}\n<!-- more -->\n\n### BTrace简介\n>Btrace (Byte Trace)是sun推出的一款java 动态、安全追踪（监控）工具，可以不停机的情况下监控线上情况，并且做到最少的侵入，占用最少的系统资源。BTrace应用较为广泛的原因应该是其安全性和无侵入性，其中热交互技术，使得我们无需启动Agent的情况下动态跟踪分析，其安全性不会导致对目标Java进程的任何破坏性影响，使得BTrace成为我们线上产品问题定位的利器。无侵入性无需我们对原有代码做任何修改，降低上线风险和测试成本，并且无需重启启动目标Java进程进行Agent加载即可动态分析和跟踪目标程序，可以说BTrace可以满足大部分的应用场景。\n\n### BTrace安装\n- 首先下载[release](https://github.com/btraceio/btrace)版本\n- 配置环境变量\n {% qnimg /java-BTrace/java-BTrace01.png %}\n- 验证是否安装成功\n {% qnimg /java-BTrace/java-BTrace02.png %}\n \n### BTrace实战\n- 测试用例(间隔一秒打印当前时间戳)\n {% qnimg /java-BTrace/java-BTrace03.png %}\n- 追踪脚本\n {% qnimg /java-BTrace/java-BTrace04.png %}\n- 追踪结果\n {% qnimg /java-BTrace/java-BTrace05.png %}\n \n\n### BTrace相关API含义\n#### 追踪时机\n- Kind.ENTRY  默认拦截方式，入口拦截\n- Kind.RETURN 拦截返回值\n- Kind.THROW 发生异常时拦截\n- Kind.LINE 拦截某一行\n- Kind.Call 被调用时拦截\n \n### BTrace使用限制\n- 不能创建对象\n- 不能创建数组\n- 不能抛出和捕获异常\n- 不能调用任何对象方法和静态方法\n- 不能给目标程序中的类静态属性和对象的属性进行赋值\n- 不能有外部、内部和嵌套类\n- 不能有同步块和同步方法\n- 不能有循环(for, while, do..while)\n- 不能继承任何的类\n- 不能实现接口\n- 不能包含assert断言语句\n\n\n\n","slug":"java-BTrace","published":1,"updated":"2018-10-11T11:31:07.314Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq640005m9cgv0g9t37g","content":"<blockquote class=\"blockquote-center\"><p>最近了解到关于java动态追踪工具BTrace的相关内容，决定实战一下，本文是针对BTrace的简单实战，未涉及过多详细内容</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"BTrace简介\"><a href=\"#BTrace简介\" class=\"headerlink\" title=\"BTrace简介\"></a>BTrace简介</h3><blockquote>\n<p>Btrace (Byte Trace)是sun推出的一款java 动态、安全追踪（监控）工具，可以不停机的情况下监控线上情况，并且做到最少的侵入，占用最少的系统资源。BTrace应用较为广泛的原因应该是其安全性和无侵入性，其中热交互技术，使得我们无需启动Agent的情况下动态跟踪分析，其安全性不会导致对目标Java进程的任何破坏性影响，使得BTrace成为我们线上产品问题定位的利器。无侵入性无需我们对原有代码做任何修改，降低上线风险和测试成本，并且无需重启启动目标Java进程进行Agent加载即可动态分析和跟踪目标程序，可以说BTrace可以满足大部分的应用场景。</p>\n</blockquote>\n<h3 id=\"BTrace安装\"><a href=\"#BTrace安装\" class=\"headerlink\" title=\"BTrace安装\"></a>BTrace安装</h3><ul>\n<li>首先下载<a href=\"https://github.com/btraceio/btrace\" target=\"_blank\" rel=\"noopener\">release</a>版本</li>\n<li>配置环境变量<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace01.png\"></li>\n<li>验证是否安装成功<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace02.png\">\n</li>\n</ul>\n<h3 id=\"BTrace实战\"><a href=\"#BTrace实战\" class=\"headerlink\" title=\"BTrace实战\"></a>BTrace实战</h3><ul>\n<li>测试用例(间隔一秒打印当前时间戳)<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace03.png\"></li>\n<li>追踪脚本<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace04.png\"></li>\n<li>追踪结果<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace05.png\">\n</li>\n</ul>\n<h3 id=\"BTrace相关API含义\"><a href=\"#BTrace相关API含义\" class=\"headerlink\" title=\"BTrace相关API含义\"></a>BTrace相关API含义</h3><h4 id=\"追踪时机\"><a href=\"#追踪时机\" class=\"headerlink\" title=\"追踪时机\"></a>追踪时机</h4><ul>\n<li>Kind.ENTRY  默认拦截方式，入口拦截</li>\n<li>Kind.RETURN 拦截返回值</li>\n<li>Kind.THROW 发生异常时拦截</li>\n<li>Kind.LINE 拦截某一行</li>\n<li>Kind.Call 被调用时拦截</li>\n</ul>\n<h3 id=\"BTrace使用限制\"><a href=\"#BTrace使用限制\" class=\"headerlink\" title=\"BTrace使用限制\"></a>BTrace使用限制</h3><ul>\n<li>不能创建对象</li>\n<li>不能创建数组</li>\n<li>不能抛出和捕获异常</li>\n<li>不能调用任何对象方法和静态方法</li>\n<li>不能给目标程序中的类静态属性和对象的属性进行赋值</li>\n<li>不能有外部、内部和嵌套类</li>\n<li>不能有同步块和同步方法</li>\n<li>不能有循环(for, while, do..while)</li>\n<li>不能继承任何的类</li>\n<li>不能实现接口</li>\n<li>不能包含assert断言语句</li>\n</ul>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>最近了解到关于java动态追踪工具BTrace的相关内容，决定实战一下，本文是针对BTrace的简单实战，未涉及过多详细内容</p>\n</blockquote>","more":"<h3 id=\"BTrace简介\"><a href=\"#BTrace简介\" class=\"headerlink\" title=\"BTrace简介\"></a>BTrace简介</h3><blockquote>\n<p>Btrace (Byte Trace)是sun推出的一款java 动态、安全追踪（监控）工具，可以不停机的情况下监控线上情况，并且做到最少的侵入，占用最少的系统资源。BTrace应用较为广泛的原因应该是其安全性和无侵入性，其中热交互技术，使得我们无需启动Agent的情况下动态跟踪分析，其安全性不会导致对目标Java进程的任何破坏性影响，使得BTrace成为我们线上产品问题定位的利器。无侵入性无需我们对原有代码做任何修改，降低上线风险和测试成本，并且无需重启启动目标Java进程进行Agent加载即可动态分析和跟踪目标程序，可以说BTrace可以满足大部分的应用场景。</p>\n</blockquote>\n<h3 id=\"BTrace安装\"><a href=\"#BTrace安装\" class=\"headerlink\" title=\"BTrace安装\"></a>BTrace安装</h3><ul>\n<li>首先下载<a href=\"https://github.com/btraceio/btrace\" target=\"_blank\" rel=\"noopener\">release</a>版本</li>\n<li>配置环境变量<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace01.png\"></li>\n<li>验证是否安装成功<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace02.png\">\n</li>\n</ul>\n<h3 id=\"BTrace实战\"><a href=\"#BTrace实战\" class=\"headerlink\" title=\"BTrace实战\"></a>BTrace实战</h3><ul>\n<li>测试用例(间隔一秒打印当前时间戳)<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace03.png\"></li>\n<li>追踪脚本<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace04.png\"></li>\n<li>追踪结果<img src=\"http://qiniuyun.xanderxu.cn/static/images//java-BTrace/java-BTrace05.png\">\n</li>\n</ul>\n<h3 id=\"BTrace相关API含义\"><a href=\"#BTrace相关API含义\" class=\"headerlink\" title=\"BTrace相关API含义\"></a>BTrace相关API含义</h3><h4 id=\"追踪时机\"><a href=\"#追踪时机\" class=\"headerlink\" title=\"追踪时机\"></a>追踪时机</h4><ul>\n<li>Kind.ENTRY  默认拦截方式，入口拦截</li>\n<li>Kind.RETURN 拦截返回值</li>\n<li>Kind.THROW 发生异常时拦截</li>\n<li>Kind.LINE 拦截某一行</li>\n<li>Kind.Call 被调用时拦截</li>\n</ul>\n<h3 id=\"BTrace使用限制\"><a href=\"#BTrace使用限制\" class=\"headerlink\" title=\"BTrace使用限制\"></a>BTrace使用限制</h3><ul>\n<li>不能创建对象</li>\n<li>不能创建数组</li>\n<li>不能抛出和捕获异常</li>\n<li>不能调用任何对象方法和静态方法</li>\n<li>不能给目标程序中的类静态属性和对象的属性进行赋值</li>\n<li>不能有外部、内部和嵌套类</li>\n<li>不能有同步块和同步方法</li>\n<li>不能有循环(for, while, do..while)</li>\n<li>不能继承任何的类</li>\n<li>不能实现接口</li>\n<li>不能包含assert断言语句</li>\n</ul>"},{"title":"AQS实现之ReentrantLock的公平锁模式","date":"2018-10-15T12:40:09.000Z","copyright":true,"_content":"{% cq %} \n之前阅读javadoop的文章，根据自己的理解对ReentrantLock进行解析\n{% endcq %}\n<!-- more -->\n\n#### 流程图：\n{% qnimg /java-AQS-01/AQS_01.jpg %}\n* * *\n\n#### 代码详解\n\n##### ReentrantLock构造方法\n```java\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n- 从上面的构造函数可以看出可重入锁ReentrantLock有两种模式。\n\n##### AQS中的acquire方法\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n##### ReentrantLock公平锁模式时的内部类\n```java\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n\n    /**\n     * 尝试直接获取锁，返回值是boolean，代表是否获取到锁\n     * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取\n     */\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        // state == 0 此时此刻没有线程持有锁\n        if (c == 0) {\n            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，\n            // 看看有没有别人在队列中等了半天了\n            if (!hasQueuedPredecessors() &&\n                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，\n                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了\n                compareAndSetState(0, acquires)) {\n                \n                // 设置当前占用该锁的线程\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 会进入这个else if分支，说明是重入了，需要操作：state=state+1\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁\n        // 回到上面一个外层调用方法继续看:\n        // if (!tryAcquire(arg) \n        //        && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) \n        //     selfInterrupt();\n        // 这时!tryAcquire(arg) == true,继续执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)\n        return false;\n    }\n}\n```\n\n##### addWaiter方法\n```java\n    // 此方法的作用是把线程包装成node，同时放入队列中\n    // 参数mode此时是Node.EXCLUSIVE，代表独占模式\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后\n        Node pred = tail;\n\n        // tail!=null => 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)\n        if (pred != null) { \n            // 设置自己的前驱 为当前的队尾节点\n            node.prev = pred; \n            // 用CAS把自己设置为队尾, 如果成功后，tail == node了\n            //  下面的CAS主要是根据tailOffSet改变成员变量tail指向的堆内存地址为node的堆内存地址，\n            // 传入的pred只是用它的值做CAS参考，并不会影响pred指向的内存地址。因此打印出来的结果就是pred还是原来tail的内存地址，成员变量已经变为node的内存地址\n            if (compareAndSetTail(pred, node)) {\n                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，\n                // 上面已经有 node.prev = pred\n                // 加上下面这句，也就实现了和之前的尾节点双向连接了\n                pred.next = node;\n                // 线程入队了，可以返回了\n                return node;\n            }\n        }\n        // 仔细看看上面的代码，如果会到这里，\n        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)\n        enq(node);\n        return node;\n    }\n```\n\n##### enq方法\n```java\n    // 采用自旋的方式入队\n    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，\n    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            // 之前说过，队列为空也会进来这里\n            if (t == null) { // Must initialize\n                // 初始化head节点\n                // 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心\n                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢\n                if (compareAndSetHead(new Node()))\n                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了\n\n                    // 这个时候有了head，但是tail还是null，设置一下，\n                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了\n                    // 注意：这里只是设置了tail=head，这里可没return，没有return，没有return\n                    // 所以，设置完了以后，继续for循环，然后就到下面的else分支了\n                    tail = head;\n            } else {\n                // 下面几行，和上一个方法 addWaiter 是一样的，\n                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n\n#### acquireQueued方法\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head\n                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列\n                // 所以当前节点可以去试抢一下锁\n                // 这里我们说一下，为什么可以去试试：\n                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，\n                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程\n                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，\n                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，\n                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n\n```\n\n#### shouldParkAfterFailedAcquire方法\n```java\n    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\"\n    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true\n        // 根据Node类的定义可知只有前驱节点为-1才表示当前线程是可以挂起，然后被唤醒的。\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n\n        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：\n        // 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。\n        // 所以下面这块代码说的是将当前节点的prev指向waitStatus<=0的节点，\n        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，\n        // 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            // 仔细想想，如果进入到这个分支意味着什么\n            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3\n            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0\n            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n\n#### shouldParkAfterFailedAcquire方法\n```java\n    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)\n    // 这个方法结束根据返回值我们简单分析下：\n    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒\n    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了\n    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看\n\n    // 跳回到前面是这个方法\n    // if (shouldParkAfterFailedAcquire(p, node) &&\n    //                parkAndCheckInterrupt())\n    //                interrupted = true;\n\n    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，\n    // 那么需要执行parkAndCheckInterrupt():\n\n    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的\n    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======\n    private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n> 如果shouldParkAfterFailedAcquire(p, node)返回false的情况:\n  仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。\n  解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：是为了应对在经过这个方法后，node有可能已经是head的直接后继节点了,继续for循环，抢占锁，第二次循环没有抢到锁的的话再挂起。","source":"_posts/java-AQS-01.md","raw":"---\ntitle: AQS实现之ReentrantLock的公平锁模式\ndate: 2018-10-15 20:40:09\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n{% cq %} \n之前阅读javadoop的文章，根据自己的理解对ReentrantLock进行解析\n{% endcq %}\n<!-- more -->\n\n#### 流程图：\n{% qnimg /java-AQS-01/AQS_01.jpg %}\n* * *\n\n#### 代码详解\n\n##### ReentrantLock构造方法\n```java\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n```\n- 从上面的构造函数可以看出可重入锁ReentrantLock有两种模式。\n\n##### AQS中的acquire方法\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n```\n##### ReentrantLock公平锁模式时的内部类\n```java\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n\n    /**\n     * 尝试直接获取锁，返回值是boolean，代表是否获取到锁\n     * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取\n     */\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        // state == 0 此时此刻没有线程持有锁\n        if (c == 0) {\n            // 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，\n            // 看看有没有别人在队列中等了半天了\n            if (!hasQueuedPredecessors() &&\n                // 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，\n                // 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了\n                compareAndSetState(0, acquires)) {\n                \n                // 设置当前占用该锁的线程\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        // 会进入这个else if分支，说明是重入了，需要操作：state=state+1\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        // 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁\n        // 回到上面一个外层调用方法继续看:\n        // if (!tryAcquire(arg) \n        //        && acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) \n        //     selfInterrupt();\n        // 这时!tryAcquire(arg) == true,继续执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)\n        return false;\n    }\n}\n```\n\n##### addWaiter方法\n```java\n    // 此方法的作用是把线程包装成node，同时放入队列中\n    // 参数mode此时是Node.EXCLUSIVE，代表独占模式\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        // 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后\n        Node pred = tail;\n\n        // tail!=null => 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)\n        if (pred != null) { \n            // 设置自己的前驱 为当前的队尾节点\n            node.prev = pred; \n            // 用CAS把自己设置为队尾, 如果成功后，tail == node了\n            //  下面的CAS主要是根据tailOffSet改变成员变量tail指向的堆内存地址为node的堆内存地址，\n            // 传入的pred只是用它的值做CAS参考，并不会影响pred指向的内存地址。因此打印出来的结果就是pred还是原来tail的内存地址，成员变量已经变为node的内存地址\n            if (compareAndSetTail(pred, node)) {\n                // 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，\n                // 上面已经有 node.prev = pred\n                // 加上下面这句，也就实现了和之前的尾节点双向连接了\n                pred.next = node;\n                // 线程入队了，可以返回了\n                return node;\n            }\n        }\n        // 仔细看看上面的代码，如果会到这里，\n        // 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)\n        enq(node);\n        return node;\n    }\n```\n\n##### enq方法\n```java\n    // 采用自旋的方式入队\n    // 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，\n    // 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            // 之前说过，队列为空也会进来这里\n            if (t == null) { // Must initialize\n                // 初始化head节点\n                // 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心\n                // 还是一步CAS，你懂的，现在可能是很多线程同时进来呢\n                if (compareAndSetHead(new Node()))\n                    // 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了\n\n                    // 这个时候有了head，但是tail还是null，设置一下，\n                    // 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了\n                    // 注意：这里只是设置了tail=head，这里可没return，没有return，没有return\n                    // 所以，设置完了以后，继续for循环，然后就到下面的else分支了\n                    tail = head;\n            } else {\n                // 下面几行，和上一个方法 addWaiter 是一样的，\n                // 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排\n                node.prev = t;\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n\n#### acquireQueued方法\n```java\nfinal boolean acquireQueued(final Node node, int arg) {\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) {\n                final Node p = node.predecessor();\n                // p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head\n                // 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列\n                // 所以当前节点可以去试抢一下锁\n                // 这里我们说一下，为什么可以去试试：\n                // 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，\n                // enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程\n                // 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，\n                // tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node);\n                    p.next = null; // help GC\n                    failed = false;\n                    return interrupted;\n                }\n                // 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，\n                // 要么就是tryAcquire(arg)没有抢赢别人，继续往下看\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n\n```\n\n#### shouldParkAfterFailedAcquire方法\n```java\n    // 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\"\n    // 第一个参数是前驱节点，第二个参数才是代表当前线程的节点\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;\n        // 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true\n        // 根据Node类的定义可知只有前驱节点为-1才表示当前线程是可以挂起，然后被唤醒的。\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true;\n\n        // 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：\n        // 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。\n        // 所以下面这块代码说的是将当前节点的prev指向waitStatus<=0的节点，\n        // 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，\n        // 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev;\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            // 仔细想想，如果进入到这个分支意味着什么\n            // 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3\n            // 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0\n            // 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n\n#### shouldParkAfterFailedAcquire方法\n```java\n    // private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)\n    // 这个方法结束根据返回值我们简单分析下：\n    // 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒\n    //        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了\n    // 如果返回false, 说明当前不需要被挂起，为什么呢？往后看\n\n    // 跳回到前面是这个方法\n    // if (shouldParkAfterFailedAcquire(p, node) &&\n    //                parkAndCheckInterrupt())\n    //                interrupted = true;\n\n    // 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，\n    // 那么需要执行parkAndCheckInterrupt():\n\n    // 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的\n    // 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======\n    private final boolean parkAndCheckInterrupt() {\n        LockSupport.park(this);\n        return Thread.interrupted();\n    }\n```\n> 如果shouldParkAfterFailedAcquire(p, node)返回false的情况:\n  仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。\n  解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：是为了应对在经过这个方法后，node有可能已经是head的直接后继节点了,继续for循环，抢占锁，第二次循环没有抢到锁的的话再挂起。","slug":"java-AQS-01","published":1,"updated":"2018-11-06T06:17:07.838Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq660007m9cgikhbckhz","content":"<blockquote class=\"blockquote-center\"><p>之前阅读javadoop的文章，根据自己的理解对ReentrantLock进行解析</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"流程图：\"><a href=\"#流程图：\" class=\"headerlink\" title=\"流程图：\"></a>流程图：</h4><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-AQS-01/AQS_01.jpg\">\n<hr>\n<h4 id=\"代码详解\"><a href=\"#代码详解\" class=\"headerlink\" title=\"代码详解\"></a>代码详解</h4><h5 id=\"ReentrantLock构造方法\"><a href=\"#ReentrantLock构造方法\" class=\"headerlink\" title=\"ReentrantLock构造方法\"></a>ReentrantLock构造方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从上面的构造函数可以看出可重入锁ReentrantLock有两种模式。</li>\n</ul>\n<h5 id=\"AQS中的acquire方法\"><a href=\"#AQS中的acquire方法\" class=\"headerlink\" title=\"AQS中的acquire方法\"></a>AQS中的acquire方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"ReentrantLock公平锁模式时的内部类\"><a href=\"#ReentrantLock公平锁模式时的内部类\" class=\"headerlink\" title=\"ReentrantLock公平锁模式时的内部类\"></a>ReentrantLock公平锁模式时的内部类</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"comment\">// state == 0 此时此刻没有线程持有锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class=\"line\">            <span class=\"comment\">// 看看有没有别人在队列中等了半天了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                <span class=\"comment\">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class=\"line\">                <span class=\"comment\">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了</span></span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 设置当前占用该锁的线程</span></span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class=\"line\">        <span class=\"comment\">// 回到上面一个外层调用方法继续看:</span></span><br><span class=\"line\">        <span class=\"comment\">// if (!tryAcquire(arg) </span></span><br><span class=\"line\">        <span class=\"comment\">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class=\"line\">        <span class=\"comment\">//     selfInterrupt();</span></span><br><span class=\"line\">        <span class=\"comment\">// 这时!tryAcquire(arg) == true,继续执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"addWaiter方法\"><a href=\"#addWaiter方法\" class=\"headerlink\" title=\"addWaiter方法\"></a>addWaiter方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此方法的作用是把线程包装成node，同时放入队列中</span></span><br><span class=\"line\"><span class=\"comment\">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    <span class=\"comment\">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 设置自己的前驱 为当前的队尾节点</span></span><br><span class=\"line\">        node.prev = pred; </span><br><span class=\"line\">        <span class=\"comment\">// 用CAS把自己设置为队尾, 如果成功后，tail == node了</span></span><br><span class=\"line\">        <span class=\"comment\">//  下面的CAS主要是根据tailOffSet改变成员变量tail指向的堆内存地址为node的堆内存地址，</span></span><br><span class=\"line\">        <span class=\"comment\">// 传入的pred只是用它的值做CAS参考，并不会影响pred指向的内存地址。因此打印出来的结果就是pred还是原来tail的内存地址，成员变量已经变为node的内存地址</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class=\"line\">            <span class=\"comment\">// 上面已经有 node.prev = pred</span></span><br><span class=\"line\">            <span class=\"comment\">// 加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"comment\">// 线程入队了，可以返回了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"enq方法\"><a href=\"#enq方法\" class=\"headerlink\" title=\"enq方法\"></a>enq方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用自旋的方式入队</span></span><br><span class=\"line\"><span class=\"comment\">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span></span><br><span class=\"line\"><span class=\"comment\">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"comment\">// 之前说过，队列为空也会进来这里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"comment\">// 初始化head节点</span></span><br><span class=\"line\">            <span class=\"comment\">// 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心</span></span><br><span class=\"line\">            <span class=\"comment\">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                <span class=\"comment\">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class=\"line\">                <span class=\"comment\">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意：这里只是设置了tail=head，这里可没return，没有return，没有return</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以，设置完了以后，继续for循环，然后就到下面的else分支了</span></span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class=\"line\">            <span class=\"comment\">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"acquireQueued方法\"><a href=\"#acquireQueued方法\" class=\"headerlink\" title=\"acquireQueued方法\"></a>acquireQueued方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">                <span class=\"comment\">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以当前节点可以去试抢一下锁</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里我们说一下，为什么可以去试试：</span></span><br><span class=\"line\">                <span class=\"comment\">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class=\"line\">                <span class=\"comment\">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class=\"line\">                <span class=\"comment\">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class=\"line\">                <span class=\"comment\">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                    setHead(node);</span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class=\"line\">                <span class=\"comment\">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                    parkAndCheckInterrupt())</span><br><span class=\"line\">                    interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">                cancelAcquire(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shouldParkAfterFailedAcquire方法\"><a href=\"#shouldParkAfterFailedAcquire方法\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire方法\"></a>shouldParkAfterFailedAcquire方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\"</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据Node类的定义可知只有前驱节点为-1才表示当前线程是可以挂起，然后被唤醒的。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：</span></span><br><span class=\"line\">    <span class=\"comment\">// 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class=\"line\">    <span class=\"comment\">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class=\"line\">    <span class=\"comment\">// 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class=\"line\">        <span class=\"comment\">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class=\"line\">        <span class=\"comment\">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class=\"line\">        <span class=\"comment\">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shouldParkAfterFailedAcquire方法-1\"><a href=\"#shouldParkAfterFailedAcquire方法-1\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire方法\"></a>shouldParkAfterFailedAcquire方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法结束根据返回值我们简单分析下：</span></span><br><span class=\"line\"><span class=\"comment\">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class=\"line\"><span class=\"comment\">//        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class=\"line\"><span class=\"comment\">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳回到前面是这个方法</span></span><br><span class=\"line\"><span class=\"comment\">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class=\"line\"><span class=\"comment\">//                parkAndCheckInterrupt())</span></span><br><span class=\"line\"><span class=\"comment\">//                interrupted = true;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span></span><br><span class=\"line\"><span class=\"comment\">// 那么需要执行parkAndCheckInterrupt():</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class=\"line\"><span class=\"comment\">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果shouldParkAfterFailedAcquire(p, node)返回false的情况:<br>  仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。<br>  解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：是为了应对在经过这个方法后，node有可能已经是head的直接后继节点了,继续for循环，抢占锁，第二次循环没有抢到锁的的话再挂起。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>之前阅读javadoop的文章，根据自己的理解对ReentrantLock进行解析</p>\n</blockquote>","more":"<h4 id=\"流程图：\"><a href=\"#流程图：\" class=\"headerlink\" title=\"流程图：\"></a>流程图：</h4><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-AQS-01/AQS_01.jpg\">\n<hr>\n<h4 id=\"代码详解\"><a href=\"#代码详解\" class=\"headerlink\" title=\"代码详解\"></a>代码详解</h4><h5 id=\"ReentrantLock构造方法\"><a href=\"#ReentrantLock构造方法\" class=\"headerlink\" title=\"ReentrantLock构造方法\"></a>ReentrantLock构造方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从上面的构造函数可以看出可重入锁ReentrantLock有两种模式。</li>\n</ul>\n<h5 id=\"AQS中的acquire方法\"><a href=\"#AQS中的acquire方法\" class=\"headerlink\" title=\"AQS中的acquire方法\"></a>AQS中的acquire方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"ReentrantLock公平锁模式时的内部类\"><a href=\"#ReentrantLock公平锁模式时的内部类\" class=\"headerlink\" title=\"ReentrantLock公平锁模式时的内部类\"></a>ReentrantLock公平锁模式时的内部类</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">3000897897090466540L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span></span><br><span class=\"line\"><span class=\"comment\">     * 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"comment\">// state == 0 此时此刻没有线程持有锁</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span></span><br><span class=\"line\">            <span class=\"comment\">// 看看有没有别人在队列中等了半天了</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class=\"line\">                <span class=\"comment\">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span></span><br><span class=\"line\">                <span class=\"comment\">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了</span></span><br><span class=\"line\">                compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">// 设置当前占用该锁的线程</span></span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span></span><br><span class=\"line\">        <span class=\"comment\">// 回到上面一个外层调用方法继续看:</span></span><br><span class=\"line\">        <span class=\"comment\">// if (!tryAcquire(arg) </span></span><br><span class=\"line\">        <span class=\"comment\">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span></span><br><span class=\"line\">        <span class=\"comment\">//     selfInterrupt();</span></span><br><span class=\"line\">        <span class=\"comment\">// 这时!tryAcquire(arg) == true,继续执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"addWaiter方法\"><a href=\"#addWaiter方法\" class=\"headerlink\" title=\"addWaiter方法\"></a>addWaiter方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 此方法的作用是把线程包装成node，同时放入队列中</span></span><br><span class=\"line\"><span class=\"comment\">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addWaiter</span><span class=\"params\">(Node mode)</span> </span>&#123;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), mode);</span><br><span class=\"line\">    <span class=\"comment\">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class=\"line\">    <span class=\"comment\">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span></span><br><span class=\"line\">    Node pred = tail;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pred != <span class=\"keyword\">null</span>) &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 设置自己的前驱 为当前的队尾节点</span></span><br><span class=\"line\">        node.prev = pred; </span><br><span class=\"line\">        <span class=\"comment\">// 用CAS把自己设置为队尾, 如果成功后，tail == node了</span></span><br><span class=\"line\">        <span class=\"comment\">//  下面的CAS主要是根据tailOffSet改变成员变量tail指向的堆内存地址为node的堆内存地址，</span></span><br><span class=\"line\">        <span class=\"comment\">// 传入的pred只是用它的值做CAS参考，并不会影响pred指向的内存地址。因此打印出来的结果就是pred还是原来tail的内存地址，成员变量已经变为node的内存地址</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span></span><br><span class=\"line\">            <span class=\"comment\">// 上面已经有 node.prev = pred</span></span><br><span class=\"line\">            <span class=\"comment\">// 加上下面这句，也就实现了和之前的尾节点双向连接了</span></span><br><span class=\"line\">            pred.next = node;</span><br><span class=\"line\">            <span class=\"comment\">// 线程入队了，可以返回了</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 仔细看看上面的代码，如果会到这里，</span></span><br><span class=\"line\">    <span class=\"comment\">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span></span><br><span class=\"line\">    enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"enq方法\"><a href=\"#enq方法\" class=\"headerlink\" title=\"enq方法\"></a>enq方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 采用自旋的方式入队</span></span><br><span class=\"line\"><span class=\"comment\">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span></span><br><span class=\"line\"><span class=\"comment\">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">enq</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        Node t = tail;</span><br><span class=\"line\">        <span class=\"comment\">// 之前说过，队列为空也会进来这里</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>) &#123; <span class=\"comment\">// Must initialize</span></span><br><span class=\"line\">            <span class=\"comment\">// 初始化head节点</span></span><br><span class=\"line\">            <span class=\"comment\">// 细心的读者会知道原来head和tail初始化的时候都是null，反正我不细心</span></span><br><span class=\"line\">            <span class=\"comment\">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetHead(<span class=\"keyword\">new</span> Node()))</span><br><span class=\"line\">                <span class=\"comment\">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span></span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"comment\">// 这个时候有了head，但是tail还是null，设置一下，</span></span><br><span class=\"line\">                <span class=\"comment\">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意：这里只是设置了tail=head，这里可没return，没有return，没有return</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以，设置完了以后，继续for循环，然后就到下面的else分支了</span></span><br><span class=\"line\">                tail = head;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 下面几行，和上一个方法 addWaiter 是一样的，</span></span><br><span class=\"line\">            <span class=\"comment\">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span></span><br><span class=\"line\">            node.prev = t;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class=\"line\">                t.next = node;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> t;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"acquireQueued方法\"><a href=\"#acquireQueued方法\" class=\"headerlink\" title=\"acquireQueued方法\"></a>acquireQueued方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">acquireQueued</span><span class=\"params\">(<span class=\"keyword\">final</span> Node node, <span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> interrupted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">final</span> Node p = node.predecessor();</span><br><span class=\"line\">                <span class=\"comment\">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span></span><br><span class=\"line\">                <span class=\"comment\">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span></span><br><span class=\"line\">                <span class=\"comment\">// 所以当前节点可以去试抢一下锁</span></span><br><span class=\"line\">                <span class=\"comment\">// 这里我们说一下，为什么可以去试试：</span></span><br><span class=\"line\">                <span class=\"comment\">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span></span><br><span class=\"line\">                <span class=\"comment\">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span></span><br><span class=\"line\">                <span class=\"comment\">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span></span><br><span class=\"line\">                <span class=\"comment\">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class=\"line\">                    setHead(node);</span><br><span class=\"line\">                    p.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// help GC</span></span><br><span class=\"line\">                    failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> interrupted;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span></span><br><span class=\"line\">                <span class=\"comment\">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class=\"line\">                    parkAndCheckInterrupt())</span><br><span class=\"line\">                    interrupted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">                cancelAcquire(node);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shouldParkAfterFailedAcquire方法\"><a href=\"#shouldParkAfterFailedAcquire方法\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire方法\"></a>shouldParkAfterFailedAcquire方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：\"当前线程没有抢到锁，是否需要挂起当前线程？\"</span></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">shouldParkAfterFailedAcquire</span><span class=\"params\">(Node pred, Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = pred.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span></span><br><span class=\"line\">    <span class=\"comment\">// 根据Node类的定义可知只有前驱节点为-1才表示当前线程是可以挂起，然后被唤醒的。</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws == Node.SIGNAL)</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * This node has already set status asking a release</span></span><br><span class=\"line\"><span class=\"comment\">         * to signal it, so it can safely park.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。这里需要知道这点：</span></span><br><span class=\"line\">    <span class=\"comment\">// 进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span></span><br><span class=\"line\">    <span class=\"comment\">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span></span><br><span class=\"line\">    <span class=\"comment\">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span></span><br><span class=\"line\">    <span class=\"comment\">// 找前驱节点的前驱节点做爹，往前循环总能找到一个好爹的</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class=\"line\"><span class=\"comment\">         * indicate retry.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">            node.prev = pred = pred.prev;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">while</span> (pred.waitStatus &gt; <span class=\"number\">0</span>);</span><br><span class=\"line\">        pred.next = node;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 仔细想想，如果进入到这个分支意味着什么</span></span><br><span class=\"line\">        <span class=\"comment\">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span></span><br><span class=\"line\">        <span class=\"comment\">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span></span><br><span class=\"line\">        <span class=\"comment\">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span></span><br><span class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"shouldParkAfterFailedAcquire方法-1\"><a href=\"#shouldParkAfterFailedAcquire方法-1\" class=\"headerlink\" title=\"shouldParkAfterFailedAcquire方法\"></a>shouldParkAfterFailedAcquire方法</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法结束根据返回值我们简单分析下：</span></span><br><span class=\"line\"><span class=\"comment\">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span></span><br><span class=\"line\"><span class=\"comment\">//        我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span></span><br><span class=\"line\"><span class=\"comment\">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 跳回到前面是这个方法</span></span><br><span class=\"line\"><span class=\"comment\">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span></span><br><span class=\"line\"><span class=\"comment\">//                parkAndCheckInterrupt())</span></span><br><span class=\"line\"><span class=\"comment\">//                interrupted = true;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span></span><br><span class=\"line\"><span class=\"comment\">// 那么需要执行parkAndCheckInterrupt():</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span></span><br><span class=\"line\"><span class=\"comment\">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">parkAndCheckInterrupt</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果shouldParkAfterFailedAcquire(p, node)返回false的情况:<br>  仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。<br>  解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：是为了应对在经过这个方法后，node有可能已经是head的直接后继节点了,继续for循环，抢占锁，第二次循环没有抢到锁的的话再挂起。</p>\n</blockquote>"},{"title":"this引用溢出导致的安全问题","date":"2018-11-08T06:20:09.000Z","copyright":true,"_content":"\n{% cq %} \n最近在读并发相关的文章，了解到一个重要知识点，拿出来分享给大家\n{% endcq %}\n<!-- more -->\n\n* * *\n\n#### this引用溢出示例\nThisEscape类\n```java\npublic class ThisEscape {  \n    private String name = null;  \n  \n    public ThisEscape(EventSource source) {  \n        source.registerListener(new EventListener() {  \n  \n            public void onEvent(Event event) {  \n                doSomething(event);  \n            }  \n  \n        });\n        //可以看出在上面的registerListener方法中调用了listener.onEvent（）方法，\n        //onEvent方法里面调用了dosomething但这个时候name还没有被初始化，\n        //因此执行name.toString的时候肯定会报空指针，其实就是this引用溢出了\n        name = \"TEST\";  \n    }  \n  \n    /** \n     * \n     * @param event \n     */  \n    protected void doSomething(Event event) {  \n        System.out.println(name.toString());  \n    }  \n}  \n```\n##### EventListener接口\n```java\nimport java.awt.Event; \n\npublic interface EventListener {  \n    public void onEvent(Event event);  \n  \n} \n```\n##### EventSource接口\n```java\npublic class EventSource {  \n  \n    public void registerListener(EventListener listener) {  \n        listener.onEvent(null);  \n    }  \n  \n}  \n```\n##### main方法\n```java\npublic class Client {  \n  \n    /** \n     * \n     * @param args \n     * @throws InterruptedException \n     */  \n    public static void main(String[] args) throws InterruptedException {  \n        EventSource es = new EventSource();  \n        new ThisEscape(es);  \n    }  \n  \n}  \n```\n##### 运行结果:\n{% qnimg /java-ThisEscape/java-ThisEscape-01.png %}\n> 我们可以看出再name初始化之前，我们就使用了ThisEscape实例即this，由于new EventListener(){}是匿名内部类，在创建匿名内部类的时候其实是生成外部类class文件和内部类class文件，内部类class文件中有外部类的引用即this引用，因此还没初始化完成就调用了this引用，造成引用溢出。\n\n#### 正确的编程\n> 解决方法：在初始化完成后再使用该类实例的方法或变量。\n##### SafeListener类\n```java\npublic class SafeListener {  \n    //这里使用final来保证成员变量的值不变，保证匿名内部类和外部环境局部变量保持同步,\n    //也就是不允许对EventListener修改,保证构造过程中的安全问题。\n    private final EventListener listener;  \n    private String              name = null;  \n  \n    private SafeListener() {  \n        listener = new EventListener() {  \n  \n            public void onEvent(Event event) {  \n                doSomething();  \n            }  \n        };  \n        name = \"TEST\";  \n    }  \n  \n    public static SafeListener newInstance(EventSource eventSource) {  \n        SafeListener safeListener = new SafeListener();  \n        eventSource.registerListener(safeListener.listener);  \n        return safeListener;  \n    }  \n  \n    protected void doSomething() {  \n        System.out.println(name.toString());  \n    }  \n}  \n```\n##### client方法\n```java\npublic class Client {\n\n    public static void main(String[] args) throws InterruptedException {\n        EventSource es = new EventSource();\n//        new ThisEscape(es);\n        SafeListener.newInstance(es);\n    }\n}\n\n```\n##### 执行结果:\n{% qnimg /java-ThisEscape/java-ThisEscape-02.png %}\n\n> 这样在正式初始化完成后，再调用不会出现引用溢出的安全性问题。","source":"_posts/java-ThisEscape.md","raw":"---\ntitle: this引用溢出导致的安全问题\ndate: 2018-11-08 14:20:09\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n\n{% cq %} \n最近在读并发相关的文章，了解到一个重要知识点，拿出来分享给大家\n{% endcq %}\n<!-- more -->\n\n* * *\n\n#### this引用溢出示例\nThisEscape类\n```java\npublic class ThisEscape {  \n    private String name = null;  \n  \n    public ThisEscape(EventSource source) {  \n        source.registerListener(new EventListener() {  \n  \n            public void onEvent(Event event) {  \n                doSomething(event);  \n            }  \n  \n        });\n        //可以看出在上面的registerListener方法中调用了listener.onEvent（）方法，\n        //onEvent方法里面调用了dosomething但这个时候name还没有被初始化，\n        //因此执行name.toString的时候肯定会报空指针，其实就是this引用溢出了\n        name = \"TEST\";  \n    }  \n  \n    /** \n     * \n     * @param event \n     */  \n    protected void doSomething(Event event) {  \n        System.out.println(name.toString());  \n    }  \n}  \n```\n##### EventListener接口\n```java\nimport java.awt.Event; \n\npublic interface EventListener {  \n    public void onEvent(Event event);  \n  \n} \n```\n##### EventSource接口\n```java\npublic class EventSource {  \n  \n    public void registerListener(EventListener listener) {  \n        listener.onEvent(null);  \n    }  \n  \n}  \n```\n##### main方法\n```java\npublic class Client {  \n  \n    /** \n     * \n     * @param args \n     * @throws InterruptedException \n     */  \n    public static void main(String[] args) throws InterruptedException {  \n        EventSource es = new EventSource();  \n        new ThisEscape(es);  \n    }  \n  \n}  \n```\n##### 运行结果:\n{% qnimg /java-ThisEscape/java-ThisEscape-01.png %}\n> 我们可以看出再name初始化之前，我们就使用了ThisEscape实例即this，由于new EventListener(){}是匿名内部类，在创建匿名内部类的时候其实是生成外部类class文件和内部类class文件，内部类class文件中有外部类的引用即this引用，因此还没初始化完成就调用了this引用，造成引用溢出。\n\n#### 正确的编程\n> 解决方法：在初始化完成后再使用该类实例的方法或变量。\n##### SafeListener类\n```java\npublic class SafeListener {  \n    //这里使用final来保证成员变量的值不变，保证匿名内部类和外部环境局部变量保持同步,\n    //也就是不允许对EventListener修改,保证构造过程中的安全问题。\n    private final EventListener listener;  \n    private String              name = null;  \n  \n    private SafeListener() {  \n        listener = new EventListener() {  \n  \n            public void onEvent(Event event) {  \n                doSomething();  \n            }  \n        };  \n        name = \"TEST\";  \n    }  \n  \n    public static SafeListener newInstance(EventSource eventSource) {  \n        SafeListener safeListener = new SafeListener();  \n        eventSource.registerListener(safeListener.listener);  \n        return safeListener;  \n    }  \n  \n    protected void doSomething() {  \n        System.out.println(name.toString());  \n    }  \n}  \n```\n##### client方法\n```java\npublic class Client {\n\n    public static void main(String[] args) throws InterruptedException {\n        EventSource es = new EventSource();\n//        new ThisEscape(es);\n        SafeListener.newInstance(es);\n    }\n}\n\n```\n##### 执行结果:\n{% qnimg /java-ThisEscape/java-ThisEscape-02.png %}\n\n> 这样在正式初始化完成后，再调用不会出现引用溢出的安全性问题。","slug":"java-ThisEscape","published":1,"updated":"2018-11-08T07:45:49.430Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6a000bm9cgwr7g808t","content":"<blockquote class=\"blockquote-center\"><p>最近在读并发相关的文章，了解到一个重要知识点，拿出来分享给大家</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h4 id=\"this引用溢出示例\"><a href=\"#this引用溢出示例\" class=\"headerlink\" title=\"this引用溢出示例\"></a>this引用溢出示例</h4><p>ThisEscape类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThisEscape</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThisEscape</span><span class=\"params\">(EventSource source)</span> </span>&#123;  </span><br><span class=\"line\">        source.registerListener(<span class=\"keyword\">new</span> EventListener() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(Event event)</span> </span>&#123;  </span><br><span class=\"line\">                doSomething(event);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//可以看出在上面的registerListener方法中调用了listener.onEvent（）方法，</span></span><br><span class=\"line\">        <span class=\"comment\">//onEvent方法里面调用了dosomething但这个时候name还没有被初始化，</span></span><br><span class=\"line\">        <span class=\"comment\">//因此执行name.toString的时候肯定会报空指针，其实就是this引用溢出了</span></span><br><span class=\"line\">        name = <span class=\"string\">\"TEST\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(Event event)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(name.toString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"EventListener接口\"><a href=\"#EventListener接口\" class=\"headerlink\" title=\"EventListener接口\"></a>EventListener接口</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.awt.Event; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EventListener</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(Event event)</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"EventSource接口\"><a href=\"#EventSource接口\" class=\"headerlink\" title=\"EventSource接口\"></a>EventSource接口</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventSource</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerListener</span><span class=\"params\">(EventListener listener)</span> </span>&#123;  </span><br><span class=\"line\">        listener.onEvent(<span class=\"keyword\">null</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"main方法\"><a href=\"#main方法\" class=\"headerlink\" title=\"main方法\"></a>main方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> InterruptedException </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;  </span><br><span class=\"line\">        EventSource es = <span class=\"keyword\">new</span> EventSource();  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> ThisEscape(es);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果:\"></a>运行结果:</h5><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-ThisEscape/java-ThisEscape-01.png\">\n<blockquote>\n<p>我们可以看出再name初始化之前，我们就使用了ThisEscape实例即this，由于new EventListener(){}是匿名内部类，在创建匿名内部类的时候其实是生成外部类class文件和内部类class文件，内部类class文件中有外部类的引用即this引用，因此还没初始化完成就调用了this引用，造成引用溢出。</p>\n</blockquote>\n<h4 id=\"正确的编程\"><a href=\"#正确的编程\" class=\"headerlink\" title=\"正确的编程\"></a>正确的编程</h4><blockquote>\n<p>解决方法：在初始化完成后再使用该类实例的方法或变量。</p>\n</blockquote>\n<h5 id=\"SafeListener类\"><a href=\"#SafeListener类\" class=\"headerlink\" title=\"SafeListener类\"></a>SafeListener类</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SafeListener</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//这里使用final来保证成员变量的值不变，保证匿名内部类和外部环境局部变量保持同步,</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是不允许对EventListener修改,保证构造过程中的安全问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventListener listener;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String              name = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SafeListener</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        listener = <span class=\"keyword\">new</span> EventListener() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(Event event)</span> </span>&#123;  </span><br><span class=\"line\">                doSomething();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;  </span><br><span class=\"line\">        name = <span class=\"string\">\"TEST\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeListener <span class=\"title\">newInstance</span><span class=\"params\">(EventSource eventSource)</span> </span>&#123;  </span><br><span class=\"line\">        SafeListener safeListener = <span class=\"keyword\">new</span> SafeListener();  </span><br><span class=\"line\">        eventSource.registerListener(safeListener.listener);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> safeListener;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(name.toString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"client方法\"><a href=\"#client方法\" class=\"headerlink\" title=\"client方法\"></a>client方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventSource es = <span class=\"keyword\">new</span> EventSource();</span><br><span class=\"line\"><span class=\"comment\">//        new ThisEscape(es);</span></span><br><span class=\"line\">        SafeListener.newInstance(es);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果:\"></a>执行结果:</h5><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-ThisEscape/java-ThisEscape-02.png\">\n<blockquote>\n<p>这样在正式初始化完成后，再调用不会出现引用溢出的安全性问题。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>最近在读并发相关的文章，了解到一个重要知识点，拿出来分享给大家</p>\n</blockquote>","more":"<hr>\n<h4 id=\"this引用溢出示例\"><a href=\"#this引用溢出示例\" class=\"headerlink\" title=\"this引用溢出示例\"></a>this引用溢出示例</h4><p>ThisEscape类<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ThisEscape</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThisEscape</span><span class=\"params\">(EventSource source)</span> </span>&#123;  </span><br><span class=\"line\">        source.registerListener(<span class=\"keyword\">new</span> EventListener() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(Event event)</span> </span>&#123;  </span><br><span class=\"line\">                doSomething(event);  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"comment\">//可以看出在上面的registerListener方法中调用了listener.onEvent（）方法，</span></span><br><span class=\"line\">        <span class=\"comment\">//onEvent方法里面调用了dosomething但这个时候name还没有被初始化，</span></span><br><span class=\"line\">        <span class=\"comment\">//因此执行name.toString的时候肯定会报空指针，其实就是this引用溢出了</span></span><br><span class=\"line\">        name = <span class=\"string\">\"TEST\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> event </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(Event event)</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(name.toString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h5 id=\"EventListener接口\"><a href=\"#EventListener接口\" class=\"headerlink\" title=\"EventListener接口\"></a>EventListener接口</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.awt.Event; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">EventListener</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(Event event)</span></span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"EventSource接口\"><a href=\"#EventSource接口\" class=\"headerlink\" title=\"EventSource接口\"></a>EventSource接口</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventSource</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">registerListener</span><span class=\"params\">(EventListener listener)</span> </span>&#123;  </span><br><span class=\"line\">        listener.onEvent(<span class=\"keyword\">null</span>);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"main方法\"><a href=\"#main方法\" class=\"headerlink\" title=\"main方法\"></a>main方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"comment\">/** </span></span><br><span class=\"line\"><span class=\"comment\">     * </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> args </span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@throws</span> InterruptedException </span></span><br><span class=\"line\"><span class=\"comment\">     */</span>  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;  </span><br><span class=\"line\">        EventSource es = <span class=\"keyword\">new</span> EventSource();  </span><br><span class=\"line\">        <span class=\"keyword\">new</span> ThisEscape(es);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"运行结果\"><a href=\"#运行结果\" class=\"headerlink\" title=\"运行结果:\"></a>运行结果:</h5><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-ThisEscape/java-ThisEscape-01.png\">\n<blockquote>\n<p>我们可以看出再name初始化之前，我们就使用了ThisEscape实例即this，由于new EventListener(){}是匿名内部类，在创建匿名内部类的时候其实是生成外部类class文件和内部类class文件，内部类class文件中有外部类的引用即this引用，因此还没初始化完成就调用了this引用，造成引用溢出。</p>\n</blockquote>\n<h4 id=\"正确的编程\"><a href=\"#正确的编程\" class=\"headerlink\" title=\"正确的编程\"></a>正确的编程</h4><blockquote>\n<p>解决方法：在初始化完成后再使用该类实例的方法或变量。</p>\n</blockquote>\n<h5 id=\"SafeListener类\"><a href=\"#SafeListener类\" class=\"headerlink\" title=\"SafeListener类\"></a>SafeListener类</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SafeListener</span> </span>&#123;  </span><br><span class=\"line\">    <span class=\"comment\">//这里使用final来保证成员变量的值不变，保证匿名内部类和外部环境局部变量保持同步,</span></span><br><span class=\"line\">    <span class=\"comment\">//也就是不允许对EventListener修改,保证构造过程中的安全问题。</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> EventListener listener;  </span><br><span class=\"line\">    <span class=\"keyword\">private</span> String              name = <span class=\"keyword\">null</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">SafeListener</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        listener = <span class=\"keyword\">new</span> EventListener() &#123;  </span><br><span class=\"line\">  </span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onEvent</span><span class=\"params\">(Event event)</span> </span>&#123;  </span><br><span class=\"line\">                doSomething();  </span><br><span class=\"line\">            &#125;  </span><br><span class=\"line\">        &#125;;  </span><br><span class=\"line\">        name = <span class=\"string\">\"TEST\"</span>;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> SafeListener <span class=\"title\">newInstance</span><span class=\"params\">(EventSource eventSource)</span> </span>&#123;  </span><br><span class=\"line\">        SafeListener safeListener = <span class=\"keyword\">new</span> SafeListener();  </span><br><span class=\"line\">        eventSource.registerListener(safeListener.listener);  </span><br><span class=\"line\">        <span class=\"keyword\">return</span> safeListener;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">()</span> </span>&#123;  </span><br><span class=\"line\">        System.out.println(name.toString());  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"client方法\"><a href=\"#client方法\" class=\"headerlink\" title=\"client方法\"></a>client方法</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Client</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        EventSource es = <span class=\"keyword\">new</span> EventSource();</span><br><span class=\"line\"><span class=\"comment\">//        new ThisEscape(es);</span></span><br><span class=\"line\">        SafeListener.newInstance(es);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"执行结果\"><a href=\"#执行结果\" class=\"headerlink\" title=\"执行结果:\"></a>执行结果:</h5><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-ThisEscape/java-ThisEscape-02.png\">\n<blockquote>\n<p>这样在正式初始化完成后，再调用不会出现引用溢出的安全性问题。</p>\n</blockquote>"},{"title":"IdentityHashmap解析","date":"2018-04-30T09:10:06.000Z","copyright":true,"_content":"\n{% cq %}\n本篇文章主要浅析IdentityHashmap的使用、适用场景和内部实现原理。\n{% endcq %}\n\n<!-- more -->\n\n\n### **IdentityHashMap 继承类与实现接口**\n\n{% qnimg /java-IdentityHashmap/java-IdentityHashmap01.png %}\n### **IdentityHashMap 内部的方法**\n\n{% qnimg /java-IdentityHashmap/java-IdentityHashmap02.png %}\n\n\n### **IdentityHashMap示例**\n\n- 示例\n{% codeblock lang:java %}\n@Test\npublic void testIdentityHashMap(){\n   String xanderXu = new String(\"XanderXu\");\n   \n   Map<String, Object> identityHashMap = new IdentityHashMap<>();\n   identityHashMap.put(new String(\"XanderXu\"),\"666\");\n   identityHashMap.put(new String(\"XanderXu\"),\"777\");\n   identityHashMap.put(xanderXu, \"xiaofei\");\n   identityHashMap.put(xanderXu, \"xiaofei--2\");\n\n   System.out.println(identityHashMap);\n}\n{% endcodeblock %}\n\n- 运行结果\n{% codeblock lang:java %}\n{XanderXu=666, XanderXu=xiaofei--2, XanderXu=777}\n{% endcodeblock %}\n> 从IdentityHashMap的继承关系可以看出IdentityHashMap并非继承于HashMap,而是兄弟关系，共同继承Map，从示例中我们也可以看出IdentitHashMap与HashMap的一大不同：IdentitHashMap允许\"equals\"为true的key同时存在,但不允许\"==\"为true的key同时存在。\n\n### **IdentityHashMap 成员变量**\n{% codeblock lang:java %}\n\n/**\n * 默认容量\n */\nprivate static final int DEFAULT_CAPACITY = 32;\n\n/**\n * 最小容量\n */\nprivate static final int MINIMUM_CAPACITY = 4;\n\n/**\n * 最大容量\n */\nprivate static final int MAXIMUM_CAPACITY = 1 << 29;\n\n/**\n * 实际存放元素数组\n */\ntransient Object[] table; // non-private to simplify nested class access\n\n/**\n * 元素个数\n */\nint size;\n\n/**\n * 修改次数,以支持快速失败\n */\ntransient int modCount;\n\n/**\n * NULL对象\n */\nstatic final Object NULL_KEY = new Object();\n{% endcodeblock %}\n> 从成员变量中可以看出IdentityHashMap数据结构就是一个Object数组,默认容量为32(这里是指存放的键值对数，后面init方法会有讲解),支持迭代器的快速失败,并且对null进行包装(区别put的是null还是原本是null)。\n\n\n### **核心方法解析**\n\n- init方法\n{% codeblock lang:java %}\nprivate void init(int initCapacity) {\n    // assert (initCapacity & -initCapacity) == initCapacity; // power of 2\n    // assert initCapacity >= MINIMUM_CAPACITY;\n    // assert initCapacity <= MAXIMUM_CAPACITY;    \n    table = new Object[2 * initCapacity];\n}\n{% endcodeblock %}\n> 因为IdentityHashMap中key和value都是存放数组(table)中的,因此默认容量是32，但是占用的空间是64。所以初始化时要乘以2。\n\n\n- hash方法\n{% codeblock lang:java %}\nprivate static int hash(Object x, int length) {\n    int h = System.identityHashCode(x);\n    // Multiply by -127, and left-shift to use least bit as part of hash\n    return ((h << 1) - (h << 8)) & (length - 1);\n}\n{% endcodeblock %}\n> identityHashCode是一个Native方法,是根据对象的内存地址来计算hash值的。并且length一定是2的n次方,所以减1后和任何数相与得到的永远是偶数，所以key一定是存放在偶数位\n\n- nextKeyIndex方法\n{% codeblock lang:java %}\nprivate static int nextKeyIndex(int i, int len) {\n    return (i + 2 < len ? i + 2 : 0);\n}\n{% endcodeblock %}\n> 获取下一个key的数组下标\n\n- resize方法\n{% codeblock lang:java %}\nprivate boolean resize(int newCapacity) {\n    // assert (newCapacity & -newCapacity) == newCapacity; // power of 2\n    int newLength = newCapacity * 2;\n\n    Object[] oldTable = table;\n    int oldLength = oldTable.length;\n    if (oldLength == 2 * MAXIMUM_CAPACITY) { // can't expand any further\n        if (size == MAXIMUM_CAPACITY - 1)\n            throw new IllegalStateException(\"Capacity exhausted.\");\n        return false;\n    }\n    if (oldLength >= newLength)\n        return false;\n\n    Object[] newTable = new Object[newLength];\n\n    for (int j = 0; j < oldLength; j += 2) {\n        Object key = oldTable[j];\n        if (key != null) {\n            Object value = oldTable[j+1];\n            oldTable[j] = null;\n            oldTable[j+1] = null;\n            int i = hash(key, newLength);\n            while (newTable[i] != null)\n                i = nextKeyIndex(i, newLength);\n            newTable[i] = key;\n            newTable[i + 1] = value;\n        }\n    }\n    table = newTable;\n    return true;\n}\n{% endcodeblock %}\n> 判断容量是否超过最大值,将旧值置空，重新计算hash值，赋值到新table中\n\n\n- put方法\n{% codeblock lang:java %}\npublic V put(K key, V value) {\n    final Object k = maskNull(key);\n\n    retryAfterResize: for (;;) {\n        final Object[] tab = table;\n        final int len = tab.length;\n        int i = hash(k, len);\n\n        for (Object item; (item = tab[i]) != null;\n             i = nextKeyIndex(i, len)) {\n            if (item == k) {\n                @SuppressWarnings(\"unchecked\")\n                    V oldValue = (V) tab[i + 1];\n                tab[i + 1] = value;\n                return oldValue;\n            }\n        }\n\n        final int s = size + 1;\n        // Use optimized form of 3 * s.\n        // Next capacity is len, 2 * current capacity.\n        if (s + (s << 1) > len && resize(len))\n            continue retryAfterResize;\n\n        modCount++;\n        tab[i] = k;\n        tab[i + 1] = value;\n        size = s;\n        return null;\n    }\n}\n{% endcodeblock %}\n> 先根据hash值获取数组中的位置，然后往后判断是否存在和引用相等的key，如果存在则替换value，返回旧值。终止条件为当前key是null(注意并不是NULL_KEY)\n> 如果没有找到相等引用，那么就停止循环，循环后table[i]一定是null的(循环过程中i一直在变)，这时进行插入操作，在插入操作之前判断是否需要扩容。\n> 上面s + (s << 1) = s + (s * 2) = s(1=2) = 3s > len,也就是说当键值对的个数大于表长的三分之一的时候就会进行扩容\n\n- get方法\n{% codeblock lang:java %}\n@SuppressWarnings(\"unchecked\")\npublic V get(Object key) {\n    Object k = maskNull(key);\n    Object[] tab = table;\n    int len = tab.length;\n    int i = hash(k, len);\n    while (true) {\n        Object item = tab[i];\n        if (item == k)\n            return (V) tab[i + 1];\n        if (item == null)\n            return null;\n        i = nextKeyIndex(i, len);\n    }\n}\n{% endcodeblock %}\n> 先检查key是否是null,然后对key哈希取值确定索引，如果没有找到，就到下一个key，直到为key为null为止。\n\n\n\n- closeDeletion方法\n{% codeblock lang:java %}\nprivate void closeDeletion(int d) {\n    // Adapted from Knuth Section 6.4 Algorithm R\n    Object[] tab = table;\n    int len = tab.length;\n\n    // Look for items to swap into newly vacated slot\n    // starting at index immediately following deletion,\n    // and continuing until a null slot is seen, indicating\n    // the end of a run of possibly-colliding keys.\n    Object item;\n    for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;\n         i = nextKeyIndex(i, len) ) {\n        // The following test triggers if the item at slot i (which\n        // hashes to be at slot r) should take the spot vacated by d.\n        // If so, we swap it in, and then continue with d now at the\n        // newly vacated i.  This process will terminate when we hit\n        // the null slot at the end of this run.\n        // The test is messy because we are using a circular table.\n        int r = hash(item, len);\n        if ((i < r && (r <= d || d <= i)) || (r <= d && d <= i)) {\n            tab[d] = item;\n            tab[d + 1] = tab[i + 1];\n            tab[i] = null;\n            tab[i + 1] = null;\n            d = i;\n        }\n    }\n}   \n{% endcodeblock %}\n> 删除后,将后面的键值对向前调整,防止找不到key的情况发生。if条件判断该key是否发生hash碰撞，只要发生过碰撞,就会往前移动。\n\n\n\n- remove方法\n{% codeblock lang:java %}\npublic V remove(Object key) {\n    Object k = maskNull(key);\n    Object[] tab = table;\n    int len = tab.length;\n    int i = hash(k, len);\n\n    while (true) {\n        Object item = tab[i];\n        if (item == k) {\n            modCount++;\n            size--;\n            @SuppressWarnings(\"unchecked\")\n                V oldValue = (V) tab[i + 1];\n            tab[i + 1] = null;\n            tab[i] = null;\n            closeDeletion(i);\n            return oldValue;\n        }\n        if (item == null)\n            return null;\n        i = nextKeyIndex(i, len);\n    }\n}\n{% endcodeblock %}\n> 获取对应key然后hash取值,将对应key删除,并且通过closeDeletion方法对后面的键值对向前做调整\n\n\n\n### **总结**\n\n> 1、IdentityHashMap 是通过引用来判断键是否相等的，并且允许null值和null键、允许重复键的Map容器。 \n  2、IdentityHashMap 解决哈希冲突的方式是采用线性探测法即往后寻找为null的槽位\n  3、IdentityHashMap 默认的初始容量为 32 ，扩容每次扩为原来的两倍。\n  4、IdentityHashMap 每一次做删除操作都会调整一次map\n","source":"_posts/java-IdentityHashmap.md","raw":"---\ntitle: IdentityHashmap解析\ndate: 2018-04-30 17:10:06\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n\n{% cq %}\n本篇文章主要浅析IdentityHashmap的使用、适用场景和内部实现原理。\n{% endcq %}\n\n<!-- more -->\n\n\n### **IdentityHashMap 继承类与实现接口**\n\n{% qnimg /java-IdentityHashmap/java-IdentityHashmap01.png %}\n### **IdentityHashMap 内部的方法**\n\n{% qnimg /java-IdentityHashmap/java-IdentityHashmap02.png %}\n\n\n### **IdentityHashMap示例**\n\n- 示例\n{% codeblock lang:java %}\n@Test\npublic void testIdentityHashMap(){\n   String xanderXu = new String(\"XanderXu\");\n   \n   Map<String, Object> identityHashMap = new IdentityHashMap<>();\n   identityHashMap.put(new String(\"XanderXu\"),\"666\");\n   identityHashMap.put(new String(\"XanderXu\"),\"777\");\n   identityHashMap.put(xanderXu, \"xiaofei\");\n   identityHashMap.put(xanderXu, \"xiaofei--2\");\n\n   System.out.println(identityHashMap);\n}\n{% endcodeblock %}\n\n- 运行结果\n{% codeblock lang:java %}\n{XanderXu=666, XanderXu=xiaofei--2, XanderXu=777}\n{% endcodeblock %}\n> 从IdentityHashMap的继承关系可以看出IdentityHashMap并非继承于HashMap,而是兄弟关系，共同继承Map，从示例中我们也可以看出IdentitHashMap与HashMap的一大不同：IdentitHashMap允许\"equals\"为true的key同时存在,但不允许\"==\"为true的key同时存在。\n\n### **IdentityHashMap 成员变量**\n{% codeblock lang:java %}\n\n/**\n * 默认容量\n */\nprivate static final int DEFAULT_CAPACITY = 32;\n\n/**\n * 最小容量\n */\nprivate static final int MINIMUM_CAPACITY = 4;\n\n/**\n * 最大容量\n */\nprivate static final int MAXIMUM_CAPACITY = 1 << 29;\n\n/**\n * 实际存放元素数组\n */\ntransient Object[] table; // non-private to simplify nested class access\n\n/**\n * 元素个数\n */\nint size;\n\n/**\n * 修改次数,以支持快速失败\n */\ntransient int modCount;\n\n/**\n * NULL对象\n */\nstatic final Object NULL_KEY = new Object();\n{% endcodeblock %}\n> 从成员变量中可以看出IdentityHashMap数据结构就是一个Object数组,默认容量为32(这里是指存放的键值对数，后面init方法会有讲解),支持迭代器的快速失败,并且对null进行包装(区别put的是null还是原本是null)。\n\n\n### **核心方法解析**\n\n- init方法\n{% codeblock lang:java %}\nprivate void init(int initCapacity) {\n    // assert (initCapacity & -initCapacity) == initCapacity; // power of 2\n    // assert initCapacity >= MINIMUM_CAPACITY;\n    // assert initCapacity <= MAXIMUM_CAPACITY;    \n    table = new Object[2 * initCapacity];\n}\n{% endcodeblock %}\n> 因为IdentityHashMap中key和value都是存放数组(table)中的,因此默认容量是32，但是占用的空间是64。所以初始化时要乘以2。\n\n\n- hash方法\n{% codeblock lang:java %}\nprivate static int hash(Object x, int length) {\n    int h = System.identityHashCode(x);\n    // Multiply by -127, and left-shift to use least bit as part of hash\n    return ((h << 1) - (h << 8)) & (length - 1);\n}\n{% endcodeblock %}\n> identityHashCode是一个Native方法,是根据对象的内存地址来计算hash值的。并且length一定是2的n次方,所以减1后和任何数相与得到的永远是偶数，所以key一定是存放在偶数位\n\n- nextKeyIndex方法\n{% codeblock lang:java %}\nprivate static int nextKeyIndex(int i, int len) {\n    return (i + 2 < len ? i + 2 : 0);\n}\n{% endcodeblock %}\n> 获取下一个key的数组下标\n\n- resize方法\n{% codeblock lang:java %}\nprivate boolean resize(int newCapacity) {\n    // assert (newCapacity & -newCapacity) == newCapacity; // power of 2\n    int newLength = newCapacity * 2;\n\n    Object[] oldTable = table;\n    int oldLength = oldTable.length;\n    if (oldLength == 2 * MAXIMUM_CAPACITY) { // can't expand any further\n        if (size == MAXIMUM_CAPACITY - 1)\n            throw new IllegalStateException(\"Capacity exhausted.\");\n        return false;\n    }\n    if (oldLength >= newLength)\n        return false;\n\n    Object[] newTable = new Object[newLength];\n\n    for (int j = 0; j < oldLength; j += 2) {\n        Object key = oldTable[j];\n        if (key != null) {\n            Object value = oldTable[j+1];\n            oldTable[j] = null;\n            oldTable[j+1] = null;\n            int i = hash(key, newLength);\n            while (newTable[i] != null)\n                i = nextKeyIndex(i, newLength);\n            newTable[i] = key;\n            newTable[i + 1] = value;\n        }\n    }\n    table = newTable;\n    return true;\n}\n{% endcodeblock %}\n> 判断容量是否超过最大值,将旧值置空，重新计算hash值，赋值到新table中\n\n\n- put方法\n{% codeblock lang:java %}\npublic V put(K key, V value) {\n    final Object k = maskNull(key);\n\n    retryAfterResize: for (;;) {\n        final Object[] tab = table;\n        final int len = tab.length;\n        int i = hash(k, len);\n\n        for (Object item; (item = tab[i]) != null;\n             i = nextKeyIndex(i, len)) {\n            if (item == k) {\n                @SuppressWarnings(\"unchecked\")\n                    V oldValue = (V) tab[i + 1];\n                tab[i + 1] = value;\n                return oldValue;\n            }\n        }\n\n        final int s = size + 1;\n        // Use optimized form of 3 * s.\n        // Next capacity is len, 2 * current capacity.\n        if (s + (s << 1) > len && resize(len))\n            continue retryAfterResize;\n\n        modCount++;\n        tab[i] = k;\n        tab[i + 1] = value;\n        size = s;\n        return null;\n    }\n}\n{% endcodeblock %}\n> 先根据hash值获取数组中的位置，然后往后判断是否存在和引用相等的key，如果存在则替换value，返回旧值。终止条件为当前key是null(注意并不是NULL_KEY)\n> 如果没有找到相等引用，那么就停止循环，循环后table[i]一定是null的(循环过程中i一直在变)，这时进行插入操作，在插入操作之前判断是否需要扩容。\n> 上面s + (s << 1) = s + (s * 2) = s(1=2) = 3s > len,也就是说当键值对的个数大于表长的三分之一的时候就会进行扩容\n\n- get方法\n{% codeblock lang:java %}\n@SuppressWarnings(\"unchecked\")\npublic V get(Object key) {\n    Object k = maskNull(key);\n    Object[] tab = table;\n    int len = tab.length;\n    int i = hash(k, len);\n    while (true) {\n        Object item = tab[i];\n        if (item == k)\n            return (V) tab[i + 1];\n        if (item == null)\n            return null;\n        i = nextKeyIndex(i, len);\n    }\n}\n{% endcodeblock %}\n> 先检查key是否是null,然后对key哈希取值确定索引，如果没有找到，就到下一个key，直到为key为null为止。\n\n\n\n- closeDeletion方法\n{% codeblock lang:java %}\nprivate void closeDeletion(int d) {\n    // Adapted from Knuth Section 6.4 Algorithm R\n    Object[] tab = table;\n    int len = tab.length;\n\n    // Look for items to swap into newly vacated slot\n    // starting at index immediately following deletion,\n    // and continuing until a null slot is seen, indicating\n    // the end of a run of possibly-colliding keys.\n    Object item;\n    for (int i = nextKeyIndex(d, len); (item = tab[i]) != null;\n         i = nextKeyIndex(i, len) ) {\n        // The following test triggers if the item at slot i (which\n        // hashes to be at slot r) should take the spot vacated by d.\n        // If so, we swap it in, and then continue with d now at the\n        // newly vacated i.  This process will terminate when we hit\n        // the null slot at the end of this run.\n        // The test is messy because we are using a circular table.\n        int r = hash(item, len);\n        if ((i < r && (r <= d || d <= i)) || (r <= d && d <= i)) {\n            tab[d] = item;\n            tab[d + 1] = tab[i + 1];\n            tab[i] = null;\n            tab[i + 1] = null;\n            d = i;\n        }\n    }\n}   \n{% endcodeblock %}\n> 删除后,将后面的键值对向前调整,防止找不到key的情况发生。if条件判断该key是否发生hash碰撞，只要发生过碰撞,就会往前移动。\n\n\n\n- remove方法\n{% codeblock lang:java %}\npublic V remove(Object key) {\n    Object k = maskNull(key);\n    Object[] tab = table;\n    int len = tab.length;\n    int i = hash(k, len);\n\n    while (true) {\n        Object item = tab[i];\n        if (item == k) {\n            modCount++;\n            size--;\n            @SuppressWarnings(\"unchecked\")\n                V oldValue = (V) tab[i + 1];\n            tab[i + 1] = null;\n            tab[i] = null;\n            closeDeletion(i);\n            return oldValue;\n        }\n        if (item == null)\n            return null;\n        i = nextKeyIndex(i, len);\n    }\n}\n{% endcodeblock %}\n> 获取对应key然后hash取值,将对应key删除,并且通过closeDeletion方法对后面的键值对向前做调整\n\n\n\n### **总结**\n\n> 1、IdentityHashMap 是通过引用来判断键是否相等的，并且允许null值和null键、允许重复键的Map容器。 \n  2、IdentityHashMap 解决哈希冲突的方式是采用线性探测法即往后寻找为null的槽位\n  3、IdentityHashMap 默认的初始容量为 32 ，扩容每次扩为原来的两倍。\n  4、IdentityHashMap 每一次做删除操作都会调整一次map\n","slug":"java-IdentityHashmap","published":1,"updated":"2018-10-11T11:25:07.193Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6c000dm9cgfml9vzv9","content":"<blockquote class=\"blockquote-center\"><p>本篇文章主要浅析IdentityHashmap的使用、适用场景和内部实现原理。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"IdentityHashMap-继承类与实现接口\"><a href=\"#IdentityHashMap-继承类与实现接口\" class=\"headerlink\" title=\"IdentityHashMap 继承类与实现接口\"></a><strong>IdentityHashMap 继承类与实现接口</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-IdentityHashmap/java-IdentityHashmap01.png\">\n<h3 id=\"IdentityHashMap-内部的方法\"><a href=\"#IdentityHashMap-内部的方法\" class=\"headerlink\" title=\"IdentityHashMap 内部的方法\"></a><strong>IdentityHashMap 内部的方法</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-IdentityHashmap/java-IdentityHashmap02.png\">\n<h3 id=\"IdentityHashMap示例\"><a href=\"#IdentityHashMap示例\" class=\"headerlink\" title=\"IdentityHashMap示例\"></a><strong>IdentityHashMap示例</strong></h3><ul>\n<li><p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testIdentityHashMap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   String xanderXu = <span class=\"keyword\">new</span> String(<span class=\"string\">\"XanderXu\"</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   Map&lt;String, Object&gt; identityHashMap = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;();</span><br><span class=\"line\">   identityHashMap.put(<span class=\"keyword\">new</span> String(<span class=\"string\">\"XanderXu\"</span>),<span class=\"string\">\"666\"</span>);</span><br><span class=\"line\">   identityHashMap.put(<span class=\"keyword\">new</span> String(<span class=\"string\">\"XanderXu\"</span>),<span class=\"string\">\"777\"</span>);</span><br><span class=\"line\">   identityHashMap.put(xanderXu, <span class=\"string\">\"xiaofei\"</span>);</span><br><span class=\"line\">   identityHashMap.put(xanderXu, <span class=\"string\">\"xiaofei--2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(identityHashMap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;XanderXu=<span class=\"number\">666</span>, XanderXu=xiaofei--<span class=\"number\">2</span>, XanderXu=<span class=\"number\">777</span>&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从IdentityHashMap的继承关系可以看出IdentityHashMap并非继承于HashMap,而是兄弟关系，共同继承Map，从示例中我们也可以看出IdentitHashMap与HashMap的一大不同：IdentitHashMap允许”equals”为true的key同时存在,但不允许”==”为true的key同时存在。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"IdentityHashMap-成员变量\"><a href=\"#IdentityHashMap-成员变量\" class=\"headerlink\" title=\"IdentityHashMap 成员变量\"></a><strong>IdentityHashMap 成员变量</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">32</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MINIMUM_CAPACITY = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">29</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实际存放元素数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] table; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 元素个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改次数,以支持快速失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * NULL对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从成员变量中可以看出IdentityHashMap数据结构就是一个Object数组,默认容量为32(这里是指存放的键值对数，后面init方法会有讲解),支持迭代器的快速失败,并且对null进行包装(区别put的是null还是原本是null)。</p>\n</blockquote>\n<h3 id=\"核心方法解析\"><a href=\"#核心方法解析\" class=\"headerlink\" title=\"核心方法解析\"></a><strong>核心方法解析</strong></h3><ul>\n<li>init方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> initCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></span><br><span class=\"line\">    <span class=\"comment\">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></span><br><span class=\"line\">    <span class=\"comment\">// assert initCapacity &lt;= MAXIMUM_CAPACITY;    </span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Object[<span class=\"number\">2</span> * initCapacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为IdentityHashMap中key和value都是存放数组(table)中的,因此默认容量是32，但是占用的空间是64。所以初始化时要乘以2。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>hash方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object x, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = System.identityHashCode(x);</span><br><span class=\"line\">    <span class=\"comment\">// Multiply by -127, and left-shift to use least bit as part of hash</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((h &lt;&lt; <span class=\"number\">1</span>) - (h &lt;&lt; <span class=\"number\">8</span>)) &amp; (length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>identityHashCode是一个Native方法,是根据对象的内存地址来计算hash值的。并且length一定是2的n次方,所以减1后和任何数相与得到的永远是偶数，所以key一定是存放在偶数位</p>\n</blockquote>\n</li>\n<li><p>nextKeyIndex方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextKeyIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i + <span class=\"number\">2</span> &lt; len ? i + <span class=\"number\">2</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>获取下一个key的数组下标</p>\n</blockquote>\n</li>\n<li><p>resize方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert (newCapacity &amp; -newCapacity) == newCapacity; // power of 2</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLength = newCapacity * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] oldTable = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldLength = oldTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLength == <span class=\"number\">2</span> * MAXIMUM_CAPACITY) &#123; <span class=\"comment\">// can't expand any further</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == MAXIMUM_CAPACITY - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Capacity exhausted.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLength &gt;= newLength)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] newTable = <span class=\"keyword\">new</span> Object[newLength];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLength; j += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        Object key = oldTable[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Object value = oldTable[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">            oldTable[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            oldTable[j+<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = hash(key, newLength);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (newTable[i] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                i = nextKeyIndex(i, newLength);</span><br><span class=\"line\">            newTable[i] = key;</span><br><span class=\"line\">            newTable[i + <span class=\"number\">1</span>] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table = newTable;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>判断容量是否超过最大值,将旧值置空，重新计算hash值，赋值到新table中</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>put方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object k = maskNull(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    retryAfterResize: <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Object[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = hash(k, len);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object item; (item = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">             i = nextKeyIndex(i, len)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item == k) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                    V oldValue = (V) tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">                tab[i + <span class=\"number\">1</span>] = value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> s = size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Use optimized form of 3 * s.</span></span><br><span class=\"line\">        <span class=\"comment\">// Next capacity is len, 2 * current capacity.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s + (s &lt;&lt; <span class=\"number\">1</span>) &gt; len &amp;&amp; resize(len))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span> retryAfterResize;</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        tab[i] = k;</span><br><span class=\"line\">        tab[i + <span class=\"number\">1</span>] = value;</span><br><span class=\"line\">        size = s;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>先根据hash值获取数组中的位置，然后往后判断是否存在和引用相等的key，如果存在则替换value，返回旧值。终止条件为当前key是null(注意并不是NULL_KEY)<br>如果没有找到相等引用，那么就停止循环，循环后table[i]一定是null的(循环过程中i一直在变)，这时进行插入操作，在插入操作之前判断是否需要扩容。<br>上面s + (s &lt;&lt; 1) = s + (s * 2) = s(1=2) = 3s &gt; len,也就是说当键值对的个数大于表长的三分之一的时候就会进行扩容</p>\n</blockquote>\n</li>\n<li><p>get方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    Object[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = hash(k, len);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        Object item = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == k)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (V) tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        i = nextKeyIndex(i, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>先检查key是否是null,然后对key哈希取值确定索引，如果没有找到，就到下一个key，直到为key为null为止。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>closeDeletion方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">closeDeletion</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Adapted from Knuth Section 6.4 Algorithm R</span></span><br><span class=\"line\">    Object[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Look for items to swap into newly vacated slot</span></span><br><span class=\"line\">    <span class=\"comment\">// starting at index immediately following deletion,</span></span><br><span class=\"line\">    <span class=\"comment\">// and continuing until a null slot is seen, indicating</span></span><br><span class=\"line\">    <span class=\"comment\">// the end of a run of possibly-colliding keys.</span></span><br><span class=\"line\">    Object item;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextKeyIndex(i, len) ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The following test triggers if the item at slot i (which</span></span><br><span class=\"line\">        <span class=\"comment\">// hashes to be at slot r) should take the spot vacated by d.</span></span><br><span class=\"line\">        <span class=\"comment\">// If so, we swap it in, and then continue with d now at the</span></span><br><span class=\"line\">        <span class=\"comment\">// newly vacated i.  This process will terminate when we hit</span></span><br><span class=\"line\">        <span class=\"comment\">// the null slot at the end of this run.</span></span><br><span class=\"line\">        <span class=\"comment\">// The test is messy because we are using a circular table.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = hash(item, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class=\"line\">            tab[d] = item;</span><br><span class=\"line\">            tab[d + <span class=\"number\">1</span>] = tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i + <span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            d = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>删除后,将后面的键值对向前调整,防止找不到key的情况发生。if条件判断该key是否发生hash碰撞，只要发生过碰撞,就会往前移动。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>remove方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    Object[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = hash(k, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        Object item = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == k) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                V oldValue = (V) tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            tab[i + <span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            closeDeletion(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        i = nextKeyIndex(i, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>获取对应key然后hash取值,将对应key删除,并且通过closeDeletion方法对后面的键值对向前做调整</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><blockquote>\n<p>1、IdentityHashMap 是通过引用来判断键是否相等的，并且允许null值和null键、允许重复键的Map容器。<br>  2、IdentityHashMap 解决哈希冲突的方式是采用线性探测法即往后寻找为null的槽位<br>  3、IdentityHashMap 默认的初始容量为 32 ，扩容每次扩为原来的两倍。<br>  4、IdentityHashMap 每一次做删除操作都会调整一次map</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>本篇文章主要浅析IdentityHashmap的使用、适用场景和内部实现原理。</p>\n</blockquote>","more":"<h3 id=\"IdentityHashMap-继承类与实现接口\"><a href=\"#IdentityHashMap-继承类与实现接口\" class=\"headerlink\" title=\"IdentityHashMap 继承类与实现接口\"></a><strong>IdentityHashMap 继承类与实现接口</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-IdentityHashmap/java-IdentityHashmap01.png\">\n<h3 id=\"IdentityHashMap-内部的方法\"><a href=\"#IdentityHashMap-内部的方法\" class=\"headerlink\" title=\"IdentityHashMap 内部的方法\"></a><strong>IdentityHashMap 内部的方法</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-IdentityHashmap/java-IdentityHashmap02.png\">\n<h3 id=\"IdentityHashMap示例\"><a href=\"#IdentityHashMap示例\" class=\"headerlink\" title=\"IdentityHashMap示例\"></a><strong>IdentityHashMap示例</strong></h3><ul>\n<li><p>示例</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testIdentityHashMap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">   String xanderXu = <span class=\"keyword\">new</span> String(<span class=\"string\">\"XanderXu\"</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\">   Map&lt;String, Object&gt; identityHashMap = <span class=\"keyword\">new</span> IdentityHashMap&lt;&gt;();</span><br><span class=\"line\">   identityHashMap.put(<span class=\"keyword\">new</span> String(<span class=\"string\">\"XanderXu\"</span>),<span class=\"string\">\"666\"</span>);</span><br><span class=\"line\">   identityHashMap.put(<span class=\"keyword\">new</span> String(<span class=\"string\">\"XanderXu\"</span>),<span class=\"string\">\"777\"</span>);</span><br><span class=\"line\">   identityHashMap.put(xanderXu, <span class=\"string\">\"xiaofei\"</span>);</span><br><span class=\"line\">   identityHashMap.put(xanderXu, <span class=\"string\">\"xiaofei--2\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">   System.out.println(identityHashMap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>运行结果</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;XanderXu=<span class=\"number\">666</span>, XanderXu=xiaofei--<span class=\"number\">2</span>, XanderXu=<span class=\"number\">777</span>&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从IdentityHashMap的继承关系可以看出IdentityHashMap并非继承于HashMap,而是兄弟关系，共同继承Map，从示例中我们也可以看出IdentitHashMap与HashMap的一大不同：IdentitHashMap允许”equals”为true的key同时存在,但不允许”==”为true的key同时存在。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"IdentityHashMap-成员变量\"><a href=\"#IdentityHashMap-成员变量\" class=\"headerlink\" title=\"IdentityHashMap 成员变量\"></a><strong>IdentityHashMap 成员变量</strong></h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_CAPACITY = <span class=\"number\">32</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最小容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MINIMUM_CAPACITY = <span class=\"number\">4</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">29</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 实际存放元素数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> Object[] table; <span class=\"comment\">// non-private to simplify nested class access</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 元素个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改次数,以支持快速失败</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * NULL对象</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL_KEY = <span class=\"keyword\">new</span> Object();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>从成员变量中可以看出IdentityHashMap数据结构就是一个Object数组,默认容量为32(这里是指存放的键值对数，后面init方法会有讲解),支持迭代器的快速失败,并且对null进行包装(区别put的是null还是原本是null)。</p>\n</blockquote>\n<h3 id=\"核心方法解析\"><a href=\"#核心方法解析\" class=\"headerlink\" title=\"核心方法解析\"></a><strong>核心方法解析</strong></h3><ul>\n<li>init方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">int</span> initCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert (initCapacity &amp; -initCapacity) == initCapacity; // power of 2</span></span><br><span class=\"line\">    <span class=\"comment\">// assert initCapacity &gt;= MINIMUM_CAPACITY;</span></span><br><span class=\"line\">    <span class=\"comment\">// assert initCapacity &lt;= MAXIMUM_CAPACITY;    </span></span><br><span class=\"line\">    table = <span class=\"keyword\">new</span> Object[<span class=\"number\">2</span> * initCapacity];</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为IdentityHashMap中key和value都是存放数组(table)中的,因此默认容量是32，但是占用的空间是64。所以初始化时要乘以2。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>hash方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object x, <span class=\"keyword\">int</span> length)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = System.identityHashCode(x);</span><br><span class=\"line\">    <span class=\"comment\">// Multiply by -127, and left-shift to use least bit as part of hash</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ((h &lt;&lt; <span class=\"number\">1</span>) - (h &lt;&lt; <span class=\"number\">8</span>)) &amp; (length - <span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>identityHashCode是一个Native方法,是根据对象的内存地址来计算hash值的。并且length一定是2的n次方,所以减1后和任何数相与得到的永远是偶数，所以key一定是存放在偶数位</p>\n</blockquote>\n</li>\n<li><p>nextKeyIndex方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">nextKeyIndex</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> len)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (i + <span class=\"number\">2</span> &lt; len ? i + <span class=\"number\">2</span> : <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>获取下一个key的数组下标</p>\n</blockquote>\n</li>\n<li><p>resize方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">resize</span><span class=\"params\">(<span class=\"keyword\">int</span> newCapacity)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert (newCapacity &amp; -newCapacity) == newCapacity; // power of 2</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> newLength = newCapacity * <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] oldTable = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> oldLength = oldTable.length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLength == <span class=\"number\">2</span> * MAXIMUM_CAPACITY) &#123; <span class=\"comment\">// can't expand any further</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (size == MAXIMUM_CAPACITY - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">\"Capacity exhausted.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldLength &gt;= newLength)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Object[] newTable = <span class=\"keyword\">new</span> Object[newLength];</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; oldLength; j += <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        Object key = oldTable[j];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            Object value = oldTable[j+<span class=\"number\">1</span>];</span><br><span class=\"line\">            oldTable[j] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            oldTable[j+<span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = hash(key, newLength);</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (newTable[i] != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                i = nextKeyIndex(i, newLength);</span><br><span class=\"line\">            newTable[i] = key;</span><br><span class=\"line\">            newTable[i + <span class=\"number\">1</span>] = value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    table = newTable;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>判断容量是否超过最大值,将旧值置空，重新计算hash值，赋值到新table中</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li><p>put方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object k = maskNull(key);</span><br><span class=\"line\"></span><br><span class=\"line\">    retryAfterResize: <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Object[] tab = table;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = hash(k, len);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Object item; (item = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">             i = nextKeyIndex(i, len)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (item == k) &#123;</span><br><span class=\"line\">                <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                    V oldValue = (V) tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">                tab[i + <span class=\"number\">1</span>] = value;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> s = size + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">// Use optimized form of 3 * s.</span></span><br><span class=\"line\">        <span class=\"comment\">// Next capacity is len, 2 * current capacity.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s + (s &lt;&lt; <span class=\"number\">1</span>) &gt; len &amp;&amp; resize(len))</span><br><span class=\"line\">            <span class=\"keyword\">continue</span> retryAfterResize;</span><br><span class=\"line\"></span><br><span class=\"line\">        modCount++;</span><br><span class=\"line\">        tab[i] = k;</span><br><span class=\"line\">        tab[i + <span class=\"number\">1</span>] = value;</span><br><span class=\"line\">        size = s;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>先根据hash值获取数组中的位置，然后往后判断是否存在和引用相等的key，如果存在则替换value，返回旧值。终止条件为当前key是null(注意并不是NULL_KEY)<br>如果没有找到相等引用，那么就停止循环，循环后table[i]一定是null的(循环过程中i一直在变)，这时进行插入操作，在插入操作之前判断是否需要扩容。<br>上面s + (s &lt;&lt; 1) = s + (s * 2) = s(1=2) = 3s &gt; len,也就是说当键值对的个数大于表长的三分之一的时候就会进行扩容</p>\n</blockquote>\n</li>\n<li><p>get方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    Object[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = hash(k, len);</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        Object item = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == k)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (V) tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        i = nextKeyIndex(i, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>先检查key是否是null,然后对key哈希取值确定索引，如果没有找到，就到下一个key，直到为key为null为止。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>closeDeletion方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">closeDeletion</span><span class=\"params\">(<span class=\"keyword\">int</span> d)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// Adapted from Knuth Section 6.4 Algorithm R</span></span><br><span class=\"line\">    Object[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// Look for items to swap into newly vacated slot</span></span><br><span class=\"line\">    <span class=\"comment\">// starting at index immediately following deletion,</span></span><br><span class=\"line\">    <span class=\"comment\">// and continuing until a null slot is seen, indicating</span></span><br><span class=\"line\">    <span class=\"comment\">// the end of a run of possibly-colliding keys.</span></span><br><span class=\"line\">    Object item;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = nextKeyIndex(d, len); (item = tab[i]) != <span class=\"keyword\">null</span>;</span><br><span class=\"line\">         i = nextKeyIndex(i, len) ) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// The following test triggers if the item at slot i (which</span></span><br><span class=\"line\">        <span class=\"comment\">// hashes to be at slot r) should take the spot vacated by d.</span></span><br><span class=\"line\">        <span class=\"comment\">// If so, we swap it in, and then continue with d now at the</span></span><br><span class=\"line\">        <span class=\"comment\">// newly vacated i.  This process will terminate when we hit</span></span><br><span class=\"line\">        <span class=\"comment\">// the null slot at the end of this run.</span></span><br><span class=\"line\">        <span class=\"comment\">// The test is messy because we are using a circular table.</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> r = hash(item, len);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((i &lt; r &amp;&amp; (r &lt;= d || d &lt;= i)) || (r &lt;= d &amp;&amp; d &lt;= i)) &#123;</span><br><span class=\"line\">            tab[d] = item;</span><br><span class=\"line\">            tab[d + <span class=\"number\">1</span>] = tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i + <span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            d = i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;   </span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>删除后,将后面的键值对向前调整,防止找不到key的情况发生。if条件判断该key是否发生hash碰撞，只要发生过碰撞,就会往前移动。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>remove方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    Object[] tab = table;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> len = tab.length;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = hash(k, len);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">        Object item = tab[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == k) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">                V oldValue = (V) tab[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            tab[i + <span class=\"number\">1</span>] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            tab[i] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            closeDeletion(i);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (item == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        i = nextKeyIndex(i, len);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>获取对应key然后hash取值,将对应key删除,并且通过closeDeletion方法对后面的键值对向前做调整</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><blockquote>\n<p>1、IdentityHashMap 是通过引用来判断键是否相等的，并且允许null值和null键、允许重复键的Map容器。<br>  2、IdentityHashMap 解决哈希冲突的方式是采用线性探测法即往后寻找为null的槽位<br>  3、IdentityHashMap 默认的初始容量为 32 ，扩容每次扩为原来的两倍。<br>  4、IdentityHashMap 每一次做删除操作都会调整一次map</p>\n</blockquote>"},{"title":"AQS实现之ReentrantLock-Condition类","date":"2018-10-29T07:53:09.000Z","copyright":true,"_content":"{% cq %} \n之前阅读javadoop的文章，根据自己的理解对Condition进行解析\n{% endcq %}\n<!-- more -->\n\n* * *\n\n#### ReentrantLock之Condition 详解\n> 从字面意思可以理解为条件，在并发代码块中添加条件，条件不满足，线程将被阻塞。\n\n\n#### Condition在生产消费者模型（Doug Lea 示例）\n```java\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    // condition 依赖于 lock 来产生\n    final Condition notFull = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    // 生产\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();  // 队列已满，等待，直到 not full 才能继续生产\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 消费\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n* * *\n\n#### 核心代码分析\n\n##### await方法:\n```java\n// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()\n// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 添加到 condition 的条件队列中\n    Node node = addConditionWaiter();\n    // 释放锁，返回值是释放锁之前的 state 值\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 这里退出循环有两种情况，之后再仔细分析\n    // 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了\n    // 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // 被唤醒后，将进入阻塞队列，等待获取锁\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n> 这里需要注意的就是,fullyRelease(node)完全释放独占锁，即释放ReentrantLock的独占锁即使该锁已经重入，其中会调用AQS的通用方法release()方法\n> release方法中会调用unparkSuccessor(h)，将当前线程的下一个节点线程unpark,虽然下一个线程unpark了，但是当前线程还是会继续执行，方法返回，\n> 这时候执行到for循环，等待其他线程将当前线程从条件队列加入到阻塞队列，如果不在阻塞队列，将当前线程park起来。至此await方法结束，等待single方法的唤醒。\n> 这里有一个疑问？为什么不用park和unpark来进行线程的禁用和切换，因为park存在假唤醒，如果当前条件还不满足就被假唤醒的时候，容易产生巨大并发问题，因此通过将当前线程从条件队列添加到阻塞队列从而严格控制条件，防止假唤醒造成的并发影响。\n\n##### addConditionWaiter方法:\n```java\n// 将当前线程对应的节点入队，插入队尾\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // 如果条件队列的最后一个节点取消了，将其清除出去\n    if (t != null && t.waitStatus != Node.CONDITION) {\n        // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    // 如果队列为空\n    if (t == null)\n        firstWaiter = node;\n    else\n        t.nextWaiter = node;\n    lastWaiter = node;\n    return node;\n}\n```\n\n\n##### unlinkCancelledWaiters()方法：\n```java\n// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去\n// 纯属链表操作，很好理解，看不懂多看几遍就可以了\nprivate void unlinkCancelledWaiters() {\n    Node t = firstWaiter;\n    Node trail = null;\n    while (t != null) {\n        Node next = t.nextWaiter;\n        // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的\n        if (t.waitStatus != Node.CONDITION) {\n            t.nextWaiter = null;\n            if (trail == null)\n                firstWaiter = next;\n            else\n                trail.nextWaiter = next;\n            if (next == null)\n                lastWaiter = trail;\n        }\n        else\n            trail = t;\n        t = next;\n    }\n}\n```\n\n##### 完全释放独占锁fullyRelease：\n```java\n// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值\n// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。\n//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1\n//         相应的，如果 lock 重入了 n 次，savedState == n\n// 如果这个方法失败，会将节点设置为\"取消\"状态，并抛出异常 IllegalMonitorStateException\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        // 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n```\n\n##### isOnSyncQueue:\n```java\n// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION\n// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，\n// 这个方法就是判断 node 是否已经移动到阻塞队列了\nfinal boolean isOnSyncQueue(Node node) {\n    // 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到\n    // 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中\n    // 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    // 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了\n    if (node.next != null) \n        return true;\n\n    // 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列\n\n    // 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。\n    // 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，\n    // 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。\n\n    // 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的\n    return findNodeFromTail(node);\n}\n\n// 从同步队列的队尾往前遍历，如果找到，返回 true\nprivate boolean findNodeFromTail(Node node) {\n    Node t = tail;\n    for (;;) {\n        if (t == node)\n            return true;\n        if (t == null)\n            return false;\n        t = t.prev;\n    }\n}\n```\n\n##### signal唤醒：\n```java\n// 唤醒等待了最久的线程\n// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列\npublic final void signal() {\n    // 调用 signal 方法的线程必须持有当前的独占锁\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n\n// 从条件队列队头往后遍历，找出第一个需要转移的 node\n// 因为前面我们说过，有些线程会取消排队，但是还在队列中\nprivate void doSignal(Node first) {\n    do {\n          // 将 firstWaiter 指向 first 节点后面的第一个\n        // 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n      // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推\n}\n\n// 将节点从条件队列转移到阻塞队列\n// true 代表成功转移\n// false 代表在 signal 之前，节点已经取消了\nfinal boolean transferForSignal(Node node) {\n\n    // CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，\n    // 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点\n    // 否则，将 waitStatus 置为 0\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    // enq(node): 自旋进入阻塞队列的队尾\n    // 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    // ws > 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释\n    // 如果 ws <= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节\n        LockSupport.unpark(node.thread);\n    return true;\n}\n```\n> 正常情况下，ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 这句中，ws <= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。\n\n假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。\n\n##### checkInterruptWhileWaiting检查中断状态\n> 先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0\n- REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态\n- THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常\n- 0 ：说明在 await 期间，没有发生中断\n> 有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：\n- 常规路径。signal -> 转移节点到阻塞队列 -> 获取了锁（unpark）\n- 线程中断。在 park 的时候，另外一个线程对这个线程进行了中断\n- signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了\n- 假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题\n> 线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。\n```java\n// 1. 如果在 signal 之前已经中断，返回 THROW_IE\n// 2. 如果是 signal 之后中断，返回 REINTERRUPT\n// 3. 没有发生中断，返回 0\nprivate int checkInterruptWhileWaiting(Node node) {\n    return Thread.interrupted() ?\n        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :\n        0;\n}\n```\n> Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 重新中断（REINTERRUPT） 的使用。\n\n看看怎么判断是 signal 之前还是之后发生的中断：\n```java\n// 只有线程处于中断状态，才会调用此方法\n// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列\n// 返回 true：如果此线程在 signal 之前被取消，\nfinal boolean transferAfterCancelledWait(Node node) {\n    // 用 CAS 将节点状态设置为 0 \n    // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0\n    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\n        // 将节点放入阻塞队列\n        // 这里我们看到，即使中断了，依然会转移到阻塞队列\n        enq(node);\n        return true;\n    }\n\n    // 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0\n    // signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成\n    // 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断\n    while (!isOnSyncQueue(node))\n        Thread.yield();\n    return false;\n}\n```\n> 这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。\n\n#### 重新获取独占锁\nwhile循环出来以后执行下面代码\n```java\nif (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n    interruptMode = REINTERRUPT;\n```\n> 由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。\n> 这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。\n> 注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。\n\n继续往下：\n```java\nif (node.nextWaiter != null) // clean up if cancelled\n    unlinkCancelledWaiters();\n```\n> node.nextWaiter != null 满足条件。前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。\n> 可是，在判断发生中断的情况下，是 signal 之前还是之后发生的？ 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。\n> 之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了\n\n继续处理中断状态:\n```java\nif (interruptMode != 0)\n    reportInterruptAfterWait(interruptMode);\n```\nreportInterruptAfterWait:\n```java\nprivate void reportInterruptAfterWait(int interruptMode)\n    throws InterruptedException {\n    if (interruptMode == THROW_IE)\n        throw new InterruptedException();\n    else if (interruptMode == REINTERRUPT)\n        selfInterrupt();\n}\n```\n> 到这里，我们可以说下这个interruptMode的作用\n- 0：什么都不做。\n- THROW_IE：await 方法抛出 InterruptedException 异常\n- REINTERRUPT：重新中断当前线程\n> 这个方法是满足不同情况下，可以对中断作出不同处理，THROW_IE 肯定是在进入single将waitstatus设置为0之后放入阻塞队列之前发生的中断，因为不是并发代码块发生的中断，所以不必重新设置中断状态\n> REINTERRUPT是在single之前发生的中断即并发代码块发生的中断，checkInterruptWhileWaiting(Node node)方法的时候会调用Thread.interrupted()重新清空中断状态。因此这种情况下需要重新设置线程的中断状态\n","source":"_posts/java-AQS-02.md","raw":"---\ntitle: AQS实现之ReentrantLock-Condition类\ndate: 2018-10-29 15:53:09\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n{% cq %} \n之前阅读javadoop的文章，根据自己的理解对Condition进行解析\n{% endcq %}\n<!-- more -->\n\n* * *\n\n#### ReentrantLock之Condition 详解\n> 从字面意思可以理解为条件，在并发代码块中添加条件，条件不满足，线程将被阻塞。\n\n\n#### Condition在生产消费者模型（Doug Lea 示例）\n```java\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    // condition 依赖于 lock 来产生\n    final Condition notFull = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    // 生产\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();  // 队列已满，等待，直到 not full 才能继续生产\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal(); // 生产成功，队列已经 not empty 了，发个通知出去\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    // 消费\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await(); // 队列为空，等待，直到队列 not empty，才能继续消费\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal(); // 被我消费掉一个，队列 not full 了，发个通知出去\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n```\n\n* * *\n\n#### 核心代码分析\n\n##### await方法:\n```java\n// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()\n// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 添加到 condition 的条件队列中\n    Node node = addConditionWaiter();\n    // 释放锁，返回值是释放锁之前的 state 值\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    // 这里退出循环有两种情况，之后再仔细分析\n    // 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了\n    // 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // 被唤醒后，将进入阻塞队列，等待获取锁\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n```\n> 这里需要注意的就是,fullyRelease(node)完全释放独占锁，即释放ReentrantLock的独占锁即使该锁已经重入，其中会调用AQS的通用方法release()方法\n> release方法中会调用unparkSuccessor(h)，将当前线程的下一个节点线程unpark,虽然下一个线程unpark了，但是当前线程还是会继续执行，方法返回，\n> 这时候执行到for循环，等待其他线程将当前线程从条件队列加入到阻塞队列，如果不在阻塞队列，将当前线程park起来。至此await方法结束，等待single方法的唤醒。\n> 这里有一个疑问？为什么不用park和unpark来进行线程的禁用和切换，因为park存在假唤醒，如果当前条件还不满足就被假唤醒的时候，容易产生巨大并发问题，因此通过将当前线程从条件队列添加到阻塞队列从而严格控制条件，防止假唤醒造成的并发影响。\n\n##### addConditionWaiter方法:\n```java\n// 将当前线程对应的节点入队，插入队尾\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // 如果条件队列的最后一个节点取消了，将其清除出去\n    if (t != null && t.waitStatus != Node.CONDITION) {\n        // 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    // 如果队列为空\n    if (t == null)\n        firstWaiter = node;\n    else\n        t.nextWaiter = node;\n    lastWaiter = node;\n    return node;\n}\n```\n\n\n##### unlinkCancelledWaiters()方法：\n```java\n// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去\n// 纯属链表操作，很好理解，看不懂多看几遍就可以了\nprivate void unlinkCancelledWaiters() {\n    Node t = firstWaiter;\n    Node trail = null;\n    while (t != null) {\n        Node next = t.nextWaiter;\n        // 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的\n        if (t.waitStatus != Node.CONDITION) {\n            t.nextWaiter = null;\n            if (trail == null)\n                firstWaiter = next;\n            else\n                trail.nextWaiter = next;\n            if (next == null)\n                lastWaiter = trail;\n        }\n        else\n            trail = t;\n        t = next;\n    }\n}\n```\n\n##### 完全释放独占锁fullyRelease：\n```java\n// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值\n// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。\n//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1\n//         相应的，如果 lock 重入了 n 次，savedState == n\n// 如果这个方法失败，会将节点设置为\"取消\"状态，并抛出异常 IllegalMonitorStateException\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        // 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0\n        if (release(savedState)) {\n            failed = false;\n            return savedState;\n        } else {\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n```\n\n##### isOnSyncQueue:\n```java\n// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION\n// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，\n// 这个方法就是判断 node 是否已经移动到阻塞队列了\nfinal boolean isOnSyncQueue(Node node) {\n    // 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到\n    // 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中\n    // 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列\n    if (node.waitStatus == Node.CONDITION || node.prev == null)\n        return false;\n    // 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了\n    if (node.next != null) \n        return true;\n\n    // 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列\n\n    // 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。\n    // 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，\n    // 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。\n\n    // 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的\n    return findNodeFromTail(node);\n}\n\n// 从同步队列的队尾往前遍历，如果找到，返回 true\nprivate boolean findNodeFromTail(Node node) {\n    Node t = tail;\n    for (;;) {\n        if (t == node)\n            return true;\n        if (t == null)\n            return false;\n        t = t.prev;\n    }\n}\n```\n\n##### signal唤醒：\n```java\n// 唤醒等待了最久的线程\n// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列\npublic final void signal() {\n    // 调用 signal 方法的线程必须持有当前的独占锁\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    Node first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n\n// 从条件队列队头往后遍历，找出第一个需要转移的 node\n// 因为前面我们说过，有些线程会取消排队，但是还在队列中\nprivate void doSignal(Node first) {\n    do {\n          // 将 firstWaiter 指向 first 节点后面的第一个\n        // 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n        // 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉\n        first.nextWaiter = null;\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n      // 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推\n}\n\n// 将节点从条件队列转移到阻塞队列\n// true 代表成功转移\n// false 代表在 signal 之前，节点已经取消了\nfinal boolean transferForSignal(Node node) {\n\n    // CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，\n    // 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点\n    // 否则，将 waitStatus 置为 0\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    // enq(node): 自旋进入阻塞队列的队尾\n    // 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    // ws > 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释\n    // 如果 ws <= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        // 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节\n        LockSupport.unpark(node.thread);\n    return true;\n}\n```\n> 正常情况下，ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 这句中，ws <= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。\n\n假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。\n\n##### checkInterruptWhileWaiting检查中断状态\n> 先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0\n- REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态\n- THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常\n- 0 ：说明在 await 期间，没有发生中断\n> 有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：\n- 常规路径。signal -> 转移节点到阻塞队列 -> 获取了锁（unpark）\n- 线程中断。在 park 的时候，另外一个线程对这个线程进行了中断\n- signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了\n- 假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题\n> 线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。\n```java\n// 1. 如果在 signal 之前已经中断，返回 THROW_IE\n// 2. 如果是 signal 之后中断，返回 REINTERRUPT\n// 3. 没有发生中断，返回 0\nprivate int checkInterruptWhileWaiting(Node node) {\n    return Thread.interrupted() ?\n        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :\n        0;\n}\n```\n> Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 重新中断（REINTERRUPT） 的使用。\n\n看看怎么判断是 signal 之前还是之后发生的中断：\n```java\n// 只有线程处于中断状态，才会调用此方法\n// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列\n// 返回 true：如果此线程在 signal 之前被取消，\nfinal boolean transferAfterCancelledWait(Node node) {\n    // 用 CAS 将节点状态设置为 0 \n    // 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0\n    if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\n        // 将节点放入阻塞队列\n        // 这里我们看到，即使中断了，依然会转移到阻塞队列\n        enq(node);\n        return true;\n    }\n\n    // 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0\n    // signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成\n    // 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断\n    while (!isOnSyncQueue(node))\n        Thread.yield();\n    return false;\n}\n```\n> 这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。\n\n#### 重新获取独占锁\nwhile循环出来以后执行下面代码\n```java\nif (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n    interruptMode = REINTERRUPT;\n```\n> 由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。\n> 这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。\n> 注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。\n\n继续往下：\n```java\nif (node.nextWaiter != null) // clean up if cancelled\n    unlinkCancelledWaiters();\n```\n> node.nextWaiter != null 满足条件。前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。\n> 可是，在判断发生中断的情况下，是 signal 之前还是之后发生的？ 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。\n> 之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了\n\n继续处理中断状态:\n```java\nif (interruptMode != 0)\n    reportInterruptAfterWait(interruptMode);\n```\nreportInterruptAfterWait:\n```java\nprivate void reportInterruptAfterWait(int interruptMode)\n    throws InterruptedException {\n    if (interruptMode == THROW_IE)\n        throw new InterruptedException();\n    else if (interruptMode == REINTERRUPT)\n        selfInterrupt();\n}\n```\n> 到这里，我们可以说下这个interruptMode的作用\n- 0：什么都不做。\n- THROW_IE：await 方法抛出 InterruptedException 异常\n- REINTERRUPT：重新中断当前线程\n> 这个方法是满足不同情况下，可以对中断作出不同处理，THROW_IE 肯定是在进入single将waitstatus设置为0之后放入阻塞队列之前发生的中断，因为不是并发代码块发生的中断，所以不必重新设置中断状态\n> REINTERRUPT是在single之前发生的中断即并发代码块发生的中断，checkInterruptWhileWaiting(Node node)方法的时候会调用Thread.interrupted()重新清空中断状态。因此这种情况下需要重新设置线程的中断状态\n","slug":"java-AQS-02","published":1,"updated":"2018-10-29T07:53:56.909Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6d000em9cg63zpfq9k","content":"<blockquote class=\"blockquote-center\"><p>之前阅读javadoop的文章，根据自己的理解对Condition进行解析</p>\n</blockquote>\n<a id=\"more\"></a>\n<hr>\n<h4 id=\"ReentrantLock之Condition-详解\"><a href=\"#ReentrantLock之Condition-详解\" class=\"headerlink\" title=\"ReentrantLock之Condition 详解\"></a>ReentrantLock之Condition 详解</h4><blockquote>\n<p>从字面意思可以理解为条件，在并发代码块中添加条件，条件不满足，线程将被阻塞。</p>\n</blockquote>\n<h4 id=\"Condition在生产消费者模型（Doug-Lea-示例）\"><a href=\"#Condition在生产消费者模型（Doug-Lea-示例）\" class=\"headerlink\" title=\"Condition在生产消费者模型（Doug Lea 示例）\"></a>Condition在生产消费者模型（Doug Lea 示例）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">// condition 依赖于 lock 来产生</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notFull = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notEmpty = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">new</span> Object[<span class=\"number\">100</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> putptr, takeptr, count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生产</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object x)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">                notFull.await();  <span class=\"comment\">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class=\"line\">            items[putptr] = x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++putptr == items.length) putptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            notEmpty.signal(); <span class=\"comment\">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消费</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">                notEmpty.await(); <span class=\"comment\">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class=\"line\">            Object x = items[takeptr];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++takeptr == items.length) takeptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            --count;</span><br><span class=\"line\">            notFull.signal(); <span class=\"comment\">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"核心代码分析\"><a href=\"#核心代码分析\" class=\"headerlink\" title=\"核心代码分析\"></a>核心代码分析</h4><h5 id=\"await方法\"><a href=\"#await方法\" class=\"headerlink\" title=\"await方法:\"></a>await方法:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// 添加到 condition 的条件队列中</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"comment\">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意的就是,fullyRelease(node)完全释放独占锁，即释放ReentrantLock的独占锁即使该锁已经重入，其中会调用AQS的通用方法release()方法<br>release方法中会调用unparkSuccessor(h)，将当前线程的下一个节点线程unpark,虽然下一个线程unpark了，但是当前线程还是会继续执行，方法返回，<br>这时候执行到for循环，等待其他线程将当前线程从条件队列加入到阻塞队列，如果不在阻塞队列，将当前线程park起来。至此await方法结束，等待single方法的唤醒。<br>这里有一个疑问？为什么不用park和unpark来进行线程的禁用和切换，因为park存在假唤醒，如果当前条件还不满足就被假唤醒的时候，容易产生巨大并发问题，因此通过将当前线程从条件队列添加到阻塞队列从而严格控制条件，防止假唤醒造成的并发影响。</p>\n</blockquote>\n<h5 id=\"addConditionWaiter方法\"><a href=\"#addConditionWaiter方法\" class=\"headerlink\" title=\"addConditionWaiter方法:\"></a>addConditionWaiter方法:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addConditionWaiter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = lastWaiter;</span><br><span class=\"line\">    <span class=\"comment\">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">        t = lastWaiter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class=\"line\">    <span class=\"comment\">// 如果队列为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        firstWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        t.nextWaiter = node;</span><br><span class=\"line\">    lastWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"unlinkCancelledWaiters-方法：\"><a href=\"#unlinkCancelledWaiters-方法：\" class=\"headerlink\" title=\"unlinkCancelledWaiters()方法：\"></a>unlinkCancelledWaiters()方法：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class=\"line\"><span class=\"comment\">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unlinkCancelledWaiters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = firstWaiter;</span><br><span class=\"line\">    Node trail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node next = t.nextWaiter;</span><br><span class=\"line\">        <span class=\"comment\">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">            t.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (trail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                firstWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                trail.nextWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                lastWaiter = trail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            trail = t;</span><br><span class=\"line\">        t = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"完全释放独占锁fullyRelease：\"><a href=\"#完全释放独占锁fullyRelease：\" class=\"headerlink\" title=\"完全释放独占锁fullyRelease：\"></a>完全释放独占锁fullyRelease：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class=\"line\"><span class=\"comment\">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class=\"line\"><span class=\"comment\">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class=\"line\"><span class=\"comment\">//         相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class=\"line\"><span class=\"comment\">// 如果这个方法失败，会将节点设置为\"取消\"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">fullyRelease</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> savedState = getState();</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (release(savedState)) &#123;</span><br><span class=\"line\">            failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> savedState;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"isOnSyncQueue\"><a href=\"#isOnSyncQueue\" class=\"headerlink\" title=\"isOnSyncQueue:\"></a>isOnSyncQueue:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class=\"line\"><span class=\"comment\">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOnSyncQueue</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.next != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> findNodeFromTail(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从同步队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findNodeFromTail</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        t = t.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"signal唤醒：\"><a href=\"#signal唤醒：\" class=\"headerlink\" title=\"signal唤醒：\"></a>signal唤醒：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 唤醒等待了最久的线程</span></span><br><span class=\"line\"><span class=\"comment\">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class=\"line\"><span class=\"comment\">// 因为前面我们说过，有些线程会取消排队，但是还在队列中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignal</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将 firstWaiter 指向 first 节点后面的第一个</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (firstWaiter = first.nextWaiter) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lastWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">             (first = firstWaiter) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将节点从条件队列转移到阻塞队列</span></span><br><span class=\"line\"><span class=\"comment\">// true 代表成功转移</span></span><br><span class=\"line\"><span class=\"comment\">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferForSignal</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class=\"line\">    <span class=\"comment\">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则，将 waitStatus 置为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class=\"line\">    Node p = enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = p.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        <span class=\"comment\">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class=\"line\">        LockSupport.unpark(node.thread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正常情况下，ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 这句中，ws &lt;= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p>\n</blockquote>\n<p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>\n<h5 id=\"checkInterruptWhileWaiting检查中断状态\"><a href=\"#checkInterruptWhileWaiting检查中断状态\" class=\"headerlink\" title=\"checkInterruptWhileWaiting检查中断状态\"></a>checkInterruptWhileWaiting检查中断状态</h5><blockquote>\n<p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>\n<ul>\n<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li>\n<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>\n<li>0 ：说明在 await 期间，没有发生中断<br>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</li>\n<li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li>\n<li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li>\n<li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>\n<li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题<br>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 没有发生中断，返回 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">checkInterruptWhileWaiting</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted() ?</span><br><span class=\"line\">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class=\"line\">        <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 重新中断（REINTERRUPT） 的使用。</p>\n</blockquote>\n<p>看看怎么判断是 signal 之前还是之后发生的中断：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class=\"line\"><span class=\"comment\">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class=\"line\"><span class=\"comment\">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferAfterCancelledWait</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用 CAS 将节点状态设置为 0 </span></span><br><span class=\"line\">    <span class=\"comment\">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将节点放入阻塞队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class=\"line\">        enq(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class=\"line\">    <span class=\"comment\">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class=\"line\">    <span class=\"comment\">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node))</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p>\n</blockquote>\n<h4 id=\"重新获取独占锁\"><a href=\"#重新获取独占锁\" class=\"headerlink\" title=\"重新获取独占锁\"></a>重新获取独占锁</h4><p>while循环出来以后执行下面代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。<br>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。<br>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p>\n</blockquote>\n<p>继续往下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">    unlinkCancelledWaiters();</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>node.nextWaiter != null 满足条件。前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。<br>可是，在判断发生中断的情况下，是 signal 之前还是之后发生的？ 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。<br>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了</p>\n</blockquote>\n<p>继续处理中断状态:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure></p>\n<p>reportInterruptAfterWait:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportInterruptAfterWait</span><span class=\"params\">(<span class=\"keyword\">int</span> interruptMode)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode == THROW_IE)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (interruptMode == REINTERRUPT)</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>到这里，我们可以说下这个interruptMode的作用</p>\n<ul>\n<li>0：什么都不做。</li>\n<li>THROW_IE：await 方法抛出 InterruptedException 异常</li>\n<li>REINTERRUPT：重新中断当前线程<br>这个方法是满足不同情况下，可以对中断作出不同处理，THROW_IE 肯定是在进入single将waitstatus设置为0之后放入阻塞队列之前发生的中断，因为不是并发代码块发生的中断，所以不必重新设置中断状态<br>REINTERRUPT是在single之前发生的中断即并发代码块发生的中断，checkInterruptWhileWaiting(Node node)方法的时候会调用Thread.interrupted()重新清空中断状态。因此这种情况下需要重新设置线程的中断状态</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>之前阅读javadoop的文章，根据自己的理解对Condition进行解析</p>\n</blockquote>","more":"<hr>\n<h4 id=\"ReentrantLock之Condition-详解\"><a href=\"#ReentrantLock之Condition-详解\" class=\"headerlink\" title=\"ReentrantLock之Condition 详解\"></a>ReentrantLock之Condition 详解</h4><blockquote>\n<p>从字面意思可以理解为条件，在并发代码块中添加条件，条件不满足，线程将被阻塞。</p>\n</blockquote>\n<h4 id=\"Condition在生产消费者模型（Doug-Lea-示例）\"><a href=\"#Condition在生产消费者模型（Doug-Lea-示例）\" class=\"headerlink\" title=\"Condition在生产消费者模型（Doug Lea 示例）\"></a>Condition在生产消费者模型（Doug Lea 示例）</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Condition;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.Lock;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BoundedBuffer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Lock lock = <span class=\"keyword\">new</span> ReentrantLock();</span><br><span class=\"line\">    <span class=\"comment\">// condition 依赖于 lock 来产生</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notFull = lock.newCondition();</span><br><span class=\"line\">    <span class=\"keyword\">final</span> Condition notEmpty = lock.newCondition();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Object[] items = <span class=\"keyword\">new</span> Object[<span class=\"number\">100</span>];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> putptr, takeptr, count;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 生产</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(Object x)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == items.length)</span><br><span class=\"line\">                notFull.await();  <span class=\"comment\">// 队列已满，等待，直到 not full 才能继续生产</span></span><br><span class=\"line\">            items[putptr] = x;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++putptr == items.length) putptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            ++count;</span><br><span class=\"line\">            notEmpty.signal(); <span class=\"comment\">// 生产成功，队列已经 not empty 了，发个通知出去</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 消费</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">        lock.lock();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (count == <span class=\"number\">0</span>)</span><br><span class=\"line\">                notEmpty.await(); <span class=\"comment\">// 队列为空，等待，直到队列 not empty，才能继续消费</span></span><br><span class=\"line\">            Object x = items[takeptr];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (++takeptr == items.length) takeptr = <span class=\"number\">0</span>;</span><br><span class=\"line\">            --count;</span><br><span class=\"line\">            notFull.signal(); <span class=\"comment\">// 被我消费掉一个，队列 not full 了，发个通知出去</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">            lock.unlock();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<hr>\n<h4 id=\"核心代码分析\"><a href=\"#核心代码分析\" class=\"headerlink\" title=\"核心代码分析\"></a>核心代码分析</h4><h5 id=\"await方法\"><a href=\"#await方法\" class=\"headerlink\" title=\"await方法:\"></a>await方法:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先，这个方法是可被中断的，不可被中断的是另一个方法 awaitUninterruptibly()</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法会阻塞，直到调用 signal 方法（指 signal() 和 signalAll()，下同），或被中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"comment\">// 添加到 condition 的条件队列中</span></span><br><span class=\"line\">    Node node = addConditionWaiter();</span><br><span class=\"line\">    <span class=\"comment\">// 释放锁，返回值是释放锁之前的 state 值</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> savedState = fullyRelease(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> interruptMode = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 这里退出循环有两种情况，之后再仔细分析</span></span><br><span class=\"line\">    <span class=\"comment\">// 1. isOnSyncQueue(node) 返回 true，即当前 node 已经转移到阻塞队列了</span></span><br><span class=\"line\">    <span class=\"comment\">// 2. checkInterruptWhileWaiting(node) != 0 会到 break，然后退出循环，代表的是线程中断</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class=\"line\">        LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 被唤醒后，将进入阻塞队列，等待获取锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">        interruptMode = REINTERRUPT;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">        reportInterruptAfterWait(interruptMode);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这里需要注意的就是,fullyRelease(node)完全释放独占锁，即释放ReentrantLock的独占锁即使该锁已经重入，其中会调用AQS的通用方法release()方法<br>release方法中会调用unparkSuccessor(h)，将当前线程的下一个节点线程unpark,虽然下一个线程unpark了，但是当前线程还是会继续执行，方法返回，<br>这时候执行到for循环，等待其他线程将当前线程从条件队列加入到阻塞队列，如果不在阻塞队列，将当前线程park起来。至此await方法结束，等待single方法的唤醒。<br>这里有一个疑问？为什么不用park和unpark来进行线程的禁用和切换，因为park存在假唤醒，如果当前条件还不满足就被假唤醒的时候，容易产生巨大并发问题，因此通过将当前线程从条件队列添加到阻塞队列从而严格控制条件，防止假唤醒造成的并发影响。</p>\n</blockquote>\n<h5 id=\"addConditionWaiter方法\"><a href=\"#addConditionWaiter方法\" class=\"headerlink\" title=\"addConditionWaiter方法:\"></a>addConditionWaiter方法:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 将当前线程对应的节点入队，插入队尾</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Node <span class=\"title\">addConditionWaiter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = lastWaiter;</span><br><span class=\"line\">    <span class=\"comment\">// 如果条件队列的最后一个节点取消了，将其清除出去</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 这个方法会遍历整个条件队列，然后会将已取消的所有节点清除出队列</span></span><br><span class=\"line\">        unlinkCancelledWaiters();</span><br><span class=\"line\">        t = lastWaiter;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Node node = <span class=\"keyword\">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class=\"line\">    <span class=\"comment\">// 如果队列为空</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        firstWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        t.nextWaiter = node;</span><br><span class=\"line\">    lastWaiter = node;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"unlinkCancelledWaiters-方法：\"><a href=\"#unlinkCancelledWaiters-方法：\" class=\"headerlink\" title=\"unlinkCancelledWaiters()方法：\"></a>unlinkCancelledWaiters()方法：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 等待队列是一个单向链表，遍历链表将已经取消等待的节点清除出去</span></span><br><span class=\"line\"><span class=\"comment\">// 纯属链表操作，很好理解，看不懂多看几遍就可以了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">unlinkCancelledWaiters</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Node t = firstWaiter;</span><br><span class=\"line\">    Node trail = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Node next = t.nextWaiter;</span><br><span class=\"line\">        <span class=\"comment\">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class=\"line\">            t.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (trail == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                firstWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                trail.nextWaiter = next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                lastWaiter = trail;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            trail = t;</span><br><span class=\"line\">        t = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"完全释放独占锁fullyRelease：\"><a href=\"#完全释放独占锁fullyRelease：\" class=\"headerlink\" title=\"完全释放独占锁fullyRelease：\"></a>完全释放独占锁fullyRelease：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 首先，我们要先观察到返回值 savedState 代表 release 之前的 state 值</span></span><br><span class=\"line\"><span class=\"comment\">// 对于最简单的操作：先 lock.lock()，然后 condition1.await()。</span></span><br><span class=\"line\"><span class=\"comment\">//         那么 state 经过这个方法由 1 变为 0，锁释放，此方法返回 1</span></span><br><span class=\"line\"><span class=\"comment\">//         相应的，如果 lock 重入了 n 次，savedState == n</span></span><br><span class=\"line\"><span class=\"comment\">// 如果这个方法失败，会将节点设置为\"取消\"状态，并抛出异常 IllegalMonitorStateException</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">fullyRelease</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> failed = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> savedState = getState();</span><br><span class=\"line\">        <span class=\"comment\">// 这里使用了当前的 state 作为 release 的参数，也就是完全释放掉锁，将 state 置为 0</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (release(savedState)) &#123;</span><br><span class=\"line\">            failed = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> savedState;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (failed)</span><br><span class=\"line\">            node.waitStatus = Node.CANCELLED;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"isOnSyncQueue\"><a href=\"#isOnSyncQueue\" class=\"headerlink\" title=\"isOnSyncQueue:\"></a>isOnSyncQueue:</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在节点入条件队列的时候，初始化时设置了 waitStatus = Node.CONDITION</span></span><br><span class=\"line\"><span class=\"comment\">// 前面我提到，signal 的时候需要将节点从条件队列移到阻塞队列，</span></span><br><span class=\"line\"><span class=\"comment\">// 这个方法就是判断 node 是否已经移动到阻塞队列了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isOnSyncQueue</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 移动过去的时候，node 的 waitStatus 会置为 0，这个之后在说 signal 方法的时候会说到</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 waitStatus 还是 Node.CONDITION，也就是 -2，那肯定就是还在条件队列中</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 node 的前驱 prev 指向还是 null，说明肯定没有在 阻塞队列</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// 如果 node 已经有后继节点 next 的时候，那肯定是在阻塞队列了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (node.next != <span class=\"keyword\">null</span>) </span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 这个方法从阻塞队列的队尾开始从后往前遍历找，如果找到相等的，说明在阻塞队列，否则就是不在阻塞队列</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 可以通过判断 node.prev() != null 来推断出 node 在阻塞队列吗？答案是：不能。</span></span><br><span class=\"line\">    <span class=\"comment\">// 这个可以看上篇 AQS 的入队方法，首先设置的是 node.prev 指向 tail，</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后是 CAS 操作将自己设置为新的 tail，可是这次的 CAS 是可能失败的。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 调用这个方法的时候，往往我们需要的就在队尾的部分，所以一般都不需要完全遍历整个队列的</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> findNodeFromTail(node);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从同步队列的队尾往前遍历，如果找到，返回 true</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">findNodeFromTail</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    Node t = tail;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == node)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        t = t.prev;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"signal唤醒：\"><a href=\"#signal唤醒：\" class=\"headerlink\" title=\"signal唤醒：\"></a>signal唤醒：</h5><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 唤醒等待了最久的线程</span></span><br><span class=\"line\"><span class=\"comment\">// 其实就是，将这个线程对应的 node 从条件队列转移到阻塞队列</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 调用 signal 方法的线程必须持有当前的独占锁</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isHeldExclusively())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">    Node first = firstWaiter;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (first != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        doSignal(first);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 从条件队列队头往后遍历，找出第一个需要转移的 node</span></span><br><span class=\"line\"><span class=\"comment\">// 因为前面我们说过，有些线程会取消排队，但是还在队列中</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">doSignal</span><span class=\"params\">(Node first)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">          <span class=\"comment\">// 将 firstWaiter 指向 first 节点后面的第一个</span></span><br><span class=\"line\">        <span class=\"comment\">// 如果将队头移除后，后面没有节点在等待了，那么需要将 lastWaiter 置为 null</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( (firstWaiter = first.nextWaiter) == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            lastWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// 因为 first 马上要被移到阻塞队列了，和条件队列的链接关系在这里断掉</span></span><br><span class=\"line\">        first.nextWaiter = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class=\"line\">             (first = firstWaiter) != <span class=\"keyword\">null</span>);</span><br><span class=\"line\">      <span class=\"comment\">// 这里 while 循环，如果 first 转移不成功，那么选择 first 后面的第一个节点进行转移，依此类推</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将节点从条件队列转移到阻塞队列</span></span><br><span class=\"line\"><span class=\"comment\">// true 代表成功转移</span></span><br><span class=\"line\"><span class=\"comment\">// false 代表在 signal 之前，节点已经取消了</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferForSignal</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// CAS 如果失败，说明此 node 的 waitStatus 已不是 Node.CONDITION，说明节点已经取消，</span></span><br><span class=\"line\">    <span class=\"comment\">// 既然已经取消，也就不需要转移了，方法返回，转移后面一个节点</span></span><br><span class=\"line\">    <span class=\"comment\">// 否则，将 waitStatus 置为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// enq(node): 自旋进入阻塞队列的队尾</span></span><br><span class=\"line\">    <span class=\"comment\">// 注意，这里的返回值 p 是 node 在阻塞队列的前驱节点</span></span><br><span class=\"line\">    Node p = enq(node);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ws = p.waitStatus;</span><br><span class=\"line\">    <span class=\"comment\">// ws &gt; 0 说明 node 在阻塞队列中的前驱节点取消了等待锁，直接唤醒 node 对应的线程。唤醒之后会怎么样，后面再解释</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果 ws &lt;= 0, 那么 compareAndSetWaitStatus 将会被调用，上篇介绍的时候说过，节点入队后，需要把前驱节点的状态设为 Node.SIGNAL(-1)</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ws &gt; <span class=\"number\">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class=\"line\">        <span class=\"comment\">// 如果前驱节点取消或者 CAS 失败，会进到这里唤醒线程，之后的操作看下一节</span></span><br><span class=\"line\">        LockSupport.unpark(node.thread);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正常情况下，ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL) 这句中，ws &lt;= 0，而且 compareAndSetWaitStatus(p, ws, Node.SIGNAL) 会返回 true，所以一般也不会进去 if 语句块中唤醒 node 对应的线程。然后这个方法返回 true，也就意味着 signal 方法结束了，节点进入了阻塞队列。</p>\n</blockquote>\n<p>假设发生了阻塞队列中的前驱节点取消等待，或者 CAS 失败，只要唤醒线程，让其进到下一步即可。</p>\n<h5 id=\"checkInterruptWhileWaiting检查中断状态\"><a href=\"#checkInterruptWhileWaiting检查中断状态\" class=\"headerlink\" title=\"checkInterruptWhileWaiting检查中断状态\"></a>checkInterruptWhileWaiting检查中断状态</h5><blockquote>\n<p>先解释下 interruptMode。interruptMode 可以取值为 REINTERRUPT（1），THROW_IE（-1），0</p>\n<ul>\n<li>REINTERRUPT： 代表 await 返回的时候，需要重新设置中断状态</li>\n<li>THROW_IE： 代表 await 返回的时候，需要抛出 InterruptedException 异常</li>\n<li>0 ：说明在 await 期间，没有发生中断<br>有以下三种情况会让 LockSupport.park(this); 这句返回继续往下执行：</li>\n<li>常规路径。signal -&gt; 转移节点到阻塞队列 -&gt; 获取了锁（unpark）</li>\n<li>线程中断。在 park 的时候，另外一个线程对这个线程进行了中断</li>\n<li>signal 的时候我们说过，转移以后的前驱节点取消了，或者对前驱节点的CAS操作失败了</li>\n<li>假唤醒。这个也是存在的，和 Object.wait() 类似，都有这个问题<br>线程唤醒后第一步是调用 checkInterruptWhileWaiting(node) 这个方法，此方法用于判断是否在线程挂起期间发生了中断，如果发生了中断，是 signal 调用之前中断的，还是 signal 之后发生的中断。<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 如果在 signal 之前已经中断，返回 THROW_IE</span></span><br><span class=\"line\"><span class=\"comment\">// 2. 如果是 signal 之后中断，返回 REINTERRUPT</span></span><br><span class=\"line\"><span class=\"comment\">// 3. 没有发生中断，返回 0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">checkInterruptWhileWaiting</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> Thread.interrupted() ?</span><br><span class=\"line\">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class=\"line\">        <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>Thread.interrupted()：如果当前线程已经处于中断状态，那么该方法返回 true，同时将中断状态重置为 false，所以，才有后续的 重新中断（REINTERRUPT） 的使用。</p>\n</blockquote>\n<p>看看怎么判断是 signal 之前还是之后发生的中断：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 只有线程处于中断状态，才会调用此方法</span></span><br><span class=\"line\"><span class=\"comment\">// 如果需要的话，将这个已经取消等待的节点转移到阻塞队列</span></span><br><span class=\"line\"><span class=\"comment\">// 返回 true：如果此线程在 signal 之前被取消，</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">transferAfterCancelledWait</span><span class=\"params\">(Node node)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用 CAS 将节点状态设置为 0 </span></span><br><span class=\"line\">    <span class=\"comment\">// 如果这步 CAS 成功，说明是 signal 方法之前发生的中断，因为如果 signal 先发生的话，signal 中会将 waitStatus 设置为 0</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class=\"number\">0</span>)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 将节点放入阻塞队列</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里我们看到，即使中断了，依然会转移到阻塞队列</span></span><br><span class=\"line\">        enq(node);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 到这里是因为 CAS 失败，肯定是因为 signal 方法已经将 waitStatus 设置为了 0</span></span><br><span class=\"line\">    <span class=\"comment\">// signal 方法会将节点转移到阻塞队列，但是可能还没完成，这边自旋等待其完成</span></span><br><span class=\"line\">    <span class=\"comment\">// 当然，这种事情还是比较少的吧：signal 调用之后，没完成转移之前，发生了中断</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (!isOnSyncQueue(node))</span><br><span class=\"line\">        Thread.yield();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>这里再说一遍，即使发生了中断，节点依然会转移到阻塞队列。</p>\n</blockquote>\n<h4 id=\"重新获取独占锁\"><a href=\"#重新获取独占锁\" class=\"headerlink\" title=\"重新获取独占锁\"></a>重新获取独占锁</h4><p>while循环出来以后执行下面代码<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class=\"line\">    interruptMode = REINTERRUPT;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>由于 while 出来后，我们确定节点已经进入了阻塞队列，准备获取锁。<br>这里的 acquireQueued(node, savedState) 的第一个参数 node 之前已经经过 enq(node) 进入了队列，参数 savedState 是之前释放锁前的 state，这个方法返回的时候，代表当前线程获取了锁，而且 state == savedState了。<br>注意，前面我们说过，不管有没有发生中断，都会进入到阻塞队列，而 acquireQueued(node, savedState) 的返回值就是代表线程是否被中断。如果返回 true，说明被中断了，而且 interruptMode != THROW_IE，说明在 signal 之前就发生中断了，这里将 interruptMode 设置为 REINTERRUPT，用于待会重新中断。</p>\n</blockquote>\n<p>继续往下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (node.nextWaiter != <span class=\"keyword\">null</span>) <span class=\"comment\">// clean up if cancelled</span></span><br><span class=\"line\">    unlinkCancelledWaiters();</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>node.nextWaiter != null 满足条件。前面也说了 signal 的时候会将节点转移到阻塞队列，有一步是 node.nextWaiter = null，将断开节点和条件队列的联系。<br>可是，在判断发生中断的情况下，是 signal 之前还是之后发生的？ 这部分的时候，我也介绍了，如果 signal 之前就中断了，也需要将节点进行转移到阻塞队列，这部分转移的时候，是没有设置 node.nextWaiter = null 的。<br>之前我们说过，如果有节点取消，也会调用 unlinkCancelledWaiters 这个方法，就是这里了</p>\n</blockquote>\n<p>继续处理中断状态:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (interruptMode != <span class=\"number\">0</span>)</span><br><span class=\"line\">    reportInterruptAfterWait(interruptMode);</span><br></pre></td></tr></table></figure></p>\n<p>reportInterruptAfterWait:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">reportInterruptAfterWait</span><span class=\"params\">(<span class=\"keyword\">int</span> interruptMode)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (interruptMode == THROW_IE)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (interruptMode == REINTERRUPT)</span><br><span class=\"line\">        selfInterrupt();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>到这里，我们可以说下这个interruptMode的作用</p>\n<ul>\n<li>0：什么都不做。</li>\n<li>THROW_IE：await 方法抛出 InterruptedException 异常</li>\n<li>REINTERRUPT：重新中断当前线程<br>这个方法是满足不同情况下，可以对中断作出不同处理，THROW_IE 肯定是在进入single将waitstatus设置为0之后放入阻塞队列之前发生的中断，因为不是并发代码块发生的中断，所以不必重新设置中断状态<br>REINTERRUPT是在single之前发生的中断即并发代码块发生的中断，checkInterruptWhileWaiting(Node node)方法的时候会调用Thread.interrupted()重新清空中断状态。因此这种情况下需要重新设置线程的中断状态</li>\n</ul>\n</blockquote>"},{"title":"EnumMap浅析","date":"2018-04-19T06:40:09.000Z","copyright":true,"_content":"\n{% cq %} \n前段时间学习spring、tomcat的源码非常吃力，发现很多东西都是因为自己的Java基础不够牢固,\n因此搭建了此博客开始重点关注java基础的相关知识。这篇文章主要分析自己很少使用的EnumMap。\n{% endcq %}\n\n<!-- more -->\n\n### EnumMap的继承类与实现接口\n{% qnimg /java-EnumMap/java-EnumMap01.png %}\n\n\n### EnumMap内部的方法\n{% qnimg /java-EnumMap/java-EnumMap02.png %}\n\n\n### 类定义\n{% codeblock lang:java %}\npublic class EnumMap<K extends Enum<K>, V> extends AbstractMap<K, V> implements java.io.Serializable, Cloneable{\n    private final Class<K> keyType;\n    private transient K[] keyUniverse;\n    private transient Object[] vals;\n    private transient int size = 0;\n}\n{% endcodeblock %}\n\n以上成员变量含义:keyType表示类型信息，keyUniverse表示键，是所有可能的枚举值，vals表示键对应的值，size表示键值对个数。\n\n\n\n### 构造方法\n\n\n{% codeblock lang:java %}\n/**\n * 通过枚举的Class类型构造\n */\npublic EnumMap(Class<K> keyType) {\n    this.keyType = keyType;\n    keyUniverse = getKeyUniverse(keyType);\n    vals = new Object[keyUniverse.length];\n}\n\n/**\n * 通过EnumMap构造\n */\npublic EnumMap(EnumMap<K, ? extends V> m) {\n     keyType = m.keyType;\n     keyUniverse = m.keyUniverse;\n     vals = m.vals.clone();\n     size = m.size;\n}\n\n/**\n * 通过Map构造,必须保证key的类型是枚举类型\n */\npublic EnumMap(Map<K, ? extends V> m) {\n    if (m instanceof EnumMap) {\n        EnumMap<K, ? extends V> em = (EnumMap<K, ? extends V>) m;\n        keyType = em.keyType;\n        keyUniverse = em.keyUniverse;\n        vals = em.vals.clone();\n        size = em.size;\n    } else {\n        if (m.isEmpty())\n            throw new IllegalArgumentException(\"Specified map is empty\");\n        keyType = m.keySet().iterator().next().getDeclaringClass();\n        keyUniverse = getKeyUniverse(keyType);\n        vals = new Object[keyUniverse.length];\n        putAll(m);\n    }\n}\n{% endcodeblock %}\n\n\n### put方法解析\n{% codeblock lang:java %}\npublic V put(K key, V value) {\n    typeCheck(key);\n    int index = key.ordinal();\n    Object oldValue = vals[index];\n    vals[index] = maskNull(value);\n    if (oldValue == null)\n        size++;\n    return unmaskNull(oldValue);\n}\n\nprivate void typeCheck(K key) {\n    Class keyClass = key.getClass();\n    if (keyClass != keyType && keyClass.getSuperclass() != keyType)\n        throw new ClassCastException(keyClass + \" != \" + keyType);\n}\n\n\nprivate Object maskNull(Object value) {\n    return (value == null ? NULL : value);\n}\n\nprivate V unmaskNull(Object value) {\n    return (V) (value == NULL ? null : value);\n}\n\nprivate static final Object NULL = new Object() {\n    public int hashCode() {\n        return 0;\n    }\n    public String toString() {\n        return \"java.util.EnumMap.NULL\";\n    }\n};\n\n{% endcodeblock %}\n\n\n- typeCheck方法校验传入key的类型是否与EnumMap初始化时定义的枚举类型对应(包含子类)\n- EnumMap允许value为null，为了区别null值与没有值，EnumMap将null值包装成了一个特殊的NULL对象，\n  有两个辅助方法用于null的打包和解包，打包方法为maskNull，解包方法为unmaskNull。\n- ordinal()方法是获取key在枚举类中的顺序(索引),将该索引作为往vals数组存放value的索引\n- 当put相同的key不同value的时候.会重新将旧value覆盖，然后将value值置空。\n\n\n\n### get方法解析\n{% codeblock lang:java %}\npublic V get(Object key) {\n    return (isValidKey(key) ?\n            unmaskNull(vals[((Enum)key).ordinal()]) : null);\n}\n\nprivate boolean isValidKey(Object key) {\n    if (key == null)\n        return false;\n    // Cheaper than instanceof Enum followed by getDeclaringClass\n    Class keyClass = key.getClass();\n    return keyClass == keyType || keyClass.getSuperclass() == keyType;\n}\n\n{% endcodeblock %}\n\n\n- 从上面代码可以看出，key通过数组下标映射数据，因此get数据的时候速度效率非常高。\n\n### remove方法解析\n\n{% codeblock lang:java %}\npublic V remove(Object key) {\n    if (!isValidKey(key))\n        return null;\n    int index = ((Enum<?>)key).ordinal();\n    Object oldValue = vals[index];\n    vals[index] = null;\n    if (oldValue != null)\n        size--;\n    return unmaskNull(oldValue);\n}\n{% endcodeblock %}\n\n- 从上面代码可以看出,删除元素之前先对key进行验证，如果key不是map初始化时指定的枚举类型，那么将会返回null。\n- 当验证完key之后，再用该key在枚举类中的顺序号作为寻找value的下标，通过该下标将val数组中的值置空。如果value不为null的话，map的size就减1。\n- 最终将卸载NULL对象，返回删除的value。在remove操作中是不会删除key数组(keyUniverse[])中的任何元素。keyUniverse[]在类构造阶段已经初始化完毕，一直伴随着map的整个生命周期，直到该EnumMap被卸载。\n- 这里有一个问题需要注意，从代码中我们没有看到任何关于线程安全的代码，因此就会产生ABA的问题。当多线程环境下，很有可能发生当我们删除一个key的value时，value置空了，但是size--没有执行，这时候又有一个线程对相同的key进行put操作,我们获取的size大小就有可能不变,也有可能变大。产生脏读的情况。\n\n\n\n### 使用方法\n\n{% codeblock lang:java %}\nimport java.util.EnumMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        EnumMap<ResultEnum, String> map = new EnumMap<ResultEnum, String>(ResultEnum.class);\n        map.put(ResultEnum.SUCCESS,\"1\");\n        map.put(ResultEnum.SUCCESS,\"2\");\n        map.put(ResultEnum.FAIL,\"3\");\n        map.put(ResultEnum.DEALING,\"4\");\n        map.put(ResultEnum.UNKNOWN,\"5\");\n        System.out.println(map);\n    }\n}\n{% endcodeblock %}\n\n输出结果:\n{% codeblock lang:java %}\n{SUCCESS=2, FAIL=3, DEALING=4, UNKNOWN=5}\n{% endcodeblock %}\n\n\n###  使用场景\n状态机：根据老大的提示，周六在公司回顾EnumMap的时候，发现确实可以使用EmumMap作为状态机。状态机实现见:EnumMap状态机实现。\n\n分类场景：对于自己而言，更多的是数据分类场景，同一类的数据对应到同一个枚举，即枚举对应Map的形式。\n\n由于EnumMap并非线程安全，因此并不适合并发修改的场景。当然，也可以自定义将EnumMap封装成适用并发的Map类，这些都是后话了。\n  \n### 总结\n\n> 以上就是EnumMap的基本实现原理，内部有两个数组，长度相同，一个表示所有可能的键，一个表示对应的值，值为null表示没有该键值对，键都有一个对应的索引，根据索引可直接访问和操作其键和值，效率很高。\n  EnumMap的缺点就是并非是线程安全的，可以用工具类包装成现成安全的:Map<EnumKey, V> m = Collections.synchronizedMap(new EnumMap<EnumKey, V>();\n\n","source":"_posts/java-EnumMap.md","raw":"---\ntitle: EnumMap浅析\ndate: 2018-04-19 14:40:09\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n\n{% cq %} \n前段时间学习spring、tomcat的源码非常吃力，发现很多东西都是因为自己的Java基础不够牢固,\n因此搭建了此博客开始重点关注java基础的相关知识。这篇文章主要分析自己很少使用的EnumMap。\n{% endcq %}\n\n<!-- more -->\n\n### EnumMap的继承类与实现接口\n{% qnimg /java-EnumMap/java-EnumMap01.png %}\n\n\n### EnumMap内部的方法\n{% qnimg /java-EnumMap/java-EnumMap02.png %}\n\n\n### 类定义\n{% codeblock lang:java %}\npublic class EnumMap<K extends Enum<K>, V> extends AbstractMap<K, V> implements java.io.Serializable, Cloneable{\n    private final Class<K> keyType;\n    private transient K[] keyUniverse;\n    private transient Object[] vals;\n    private transient int size = 0;\n}\n{% endcodeblock %}\n\n以上成员变量含义:keyType表示类型信息，keyUniverse表示键，是所有可能的枚举值，vals表示键对应的值，size表示键值对个数。\n\n\n\n### 构造方法\n\n\n{% codeblock lang:java %}\n/**\n * 通过枚举的Class类型构造\n */\npublic EnumMap(Class<K> keyType) {\n    this.keyType = keyType;\n    keyUniverse = getKeyUniverse(keyType);\n    vals = new Object[keyUniverse.length];\n}\n\n/**\n * 通过EnumMap构造\n */\npublic EnumMap(EnumMap<K, ? extends V> m) {\n     keyType = m.keyType;\n     keyUniverse = m.keyUniverse;\n     vals = m.vals.clone();\n     size = m.size;\n}\n\n/**\n * 通过Map构造,必须保证key的类型是枚举类型\n */\npublic EnumMap(Map<K, ? extends V> m) {\n    if (m instanceof EnumMap) {\n        EnumMap<K, ? extends V> em = (EnumMap<K, ? extends V>) m;\n        keyType = em.keyType;\n        keyUniverse = em.keyUniverse;\n        vals = em.vals.clone();\n        size = em.size;\n    } else {\n        if (m.isEmpty())\n            throw new IllegalArgumentException(\"Specified map is empty\");\n        keyType = m.keySet().iterator().next().getDeclaringClass();\n        keyUniverse = getKeyUniverse(keyType);\n        vals = new Object[keyUniverse.length];\n        putAll(m);\n    }\n}\n{% endcodeblock %}\n\n\n### put方法解析\n{% codeblock lang:java %}\npublic V put(K key, V value) {\n    typeCheck(key);\n    int index = key.ordinal();\n    Object oldValue = vals[index];\n    vals[index] = maskNull(value);\n    if (oldValue == null)\n        size++;\n    return unmaskNull(oldValue);\n}\n\nprivate void typeCheck(K key) {\n    Class keyClass = key.getClass();\n    if (keyClass != keyType && keyClass.getSuperclass() != keyType)\n        throw new ClassCastException(keyClass + \" != \" + keyType);\n}\n\n\nprivate Object maskNull(Object value) {\n    return (value == null ? NULL : value);\n}\n\nprivate V unmaskNull(Object value) {\n    return (V) (value == NULL ? null : value);\n}\n\nprivate static final Object NULL = new Object() {\n    public int hashCode() {\n        return 0;\n    }\n    public String toString() {\n        return \"java.util.EnumMap.NULL\";\n    }\n};\n\n{% endcodeblock %}\n\n\n- typeCheck方法校验传入key的类型是否与EnumMap初始化时定义的枚举类型对应(包含子类)\n- EnumMap允许value为null，为了区别null值与没有值，EnumMap将null值包装成了一个特殊的NULL对象，\n  有两个辅助方法用于null的打包和解包，打包方法为maskNull，解包方法为unmaskNull。\n- ordinal()方法是获取key在枚举类中的顺序(索引),将该索引作为往vals数组存放value的索引\n- 当put相同的key不同value的时候.会重新将旧value覆盖，然后将value值置空。\n\n\n\n### get方法解析\n{% codeblock lang:java %}\npublic V get(Object key) {\n    return (isValidKey(key) ?\n            unmaskNull(vals[((Enum)key).ordinal()]) : null);\n}\n\nprivate boolean isValidKey(Object key) {\n    if (key == null)\n        return false;\n    // Cheaper than instanceof Enum followed by getDeclaringClass\n    Class keyClass = key.getClass();\n    return keyClass == keyType || keyClass.getSuperclass() == keyType;\n}\n\n{% endcodeblock %}\n\n\n- 从上面代码可以看出，key通过数组下标映射数据，因此get数据的时候速度效率非常高。\n\n### remove方法解析\n\n{% codeblock lang:java %}\npublic V remove(Object key) {\n    if (!isValidKey(key))\n        return null;\n    int index = ((Enum<?>)key).ordinal();\n    Object oldValue = vals[index];\n    vals[index] = null;\n    if (oldValue != null)\n        size--;\n    return unmaskNull(oldValue);\n}\n{% endcodeblock %}\n\n- 从上面代码可以看出,删除元素之前先对key进行验证，如果key不是map初始化时指定的枚举类型，那么将会返回null。\n- 当验证完key之后，再用该key在枚举类中的顺序号作为寻找value的下标，通过该下标将val数组中的值置空。如果value不为null的话，map的size就减1。\n- 最终将卸载NULL对象，返回删除的value。在remove操作中是不会删除key数组(keyUniverse[])中的任何元素。keyUniverse[]在类构造阶段已经初始化完毕，一直伴随着map的整个生命周期，直到该EnumMap被卸载。\n- 这里有一个问题需要注意，从代码中我们没有看到任何关于线程安全的代码，因此就会产生ABA的问题。当多线程环境下，很有可能发生当我们删除一个key的value时，value置空了，但是size--没有执行，这时候又有一个线程对相同的key进行put操作,我们获取的size大小就有可能不变,也有可能变大。产生脏读的情况。\n\n\n\n### 使用方法\n\n{% codeblock lang:java %}\nimport java.util.EnumMap;\n\npublic class Main {\n    public static void main(String[] args) {\n        EnumMap<ResultEnum, String> map = new EnumMap<ResultEnum, String>(ResultEnum.class);\n        map.put(ResultEnum.SUCCESS,\"1\");\n        map.put(ResultEnum.SUCCESS,\"2\");\n        map.put(ResultEnum.FAIL,\"3\");\n        map.put(ResultEnum.DEALING,\"4\");\n        map.put(ResultEnum.UNKNOWN,\"5\");\n        System.out.println(map);\n    }\n}\n{% endcodeblock %}\n\n输出结果:\n{% codeblock lang:java %}\n{SUCCESS=2, FAIL=3, DEALING=4, UNKNOWN=5}\n{% endcodeblock %}\n\n\n###  使用场景\n状态机：根据老大的提示，周六在公司回顾EnumMap的时候，发现确实可以使用EmumMap作为状态机。状态机实现见:EnumMap状态机实现。\n\n分类场景：对于自己而言，更多的是数据分类场景，同一类的数据对应到同一个枚举，即枚举对应Map的形式。\n\n由于EnumMap并非线程安全，因此并不适合并发修改的场景。当然，也可以自定义将EnumMap封装成适用并发的Map类，这些都是后话了。\n  \n### 总结\n\n> 以上就是EnumMap的基本实现原理，内部有两个数组，长度相同，一个表示所有可能的键，一个表示对应的值，值为null表示没有该键值对，键都有一个对应的索引，根据索引可直接访问和操作其键和值，效率很高。\n  EnumMap的缺点就是并非是线程安全的，可以用工具类包装成现成安全的:Map<EnumKey, V> m = Collections.synchronizedMap(new EnumMap<EnumKey, V>();\n\n","slug":"java-EnumMap","published":1,"updated":"2018-10-11T11:23:53.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6h000im9cg1ma43fkw","content":"<blockquote class=\"blockquote-center\"><p>前段时间学习spring、tomcat的源码非常吃力，发现很多东西都是因为自己的Java基础不够牢固,<br>因此搭建了此博客开始重点关注java基础的相关知识。这篇文章主要分析自己很少使用的EnumMap。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"EnumMap的继承类与实现接口\"><a href=\"#EnumMap的继承类与实现接口\" class=\"headerlink\" title=\"EnumMap的继承类与实现接口\"></a>EnumMap的继承类与实现接口</h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-EnumMap/java-EnumMap01.png\">\n<h3 id=\"EnumMap内部的方法\"><a href=\"#EnumMap内部的方法\" class=\"headerlink\" title=\"EnumMap内部的方法\"></a>EnumMap内部的方法</h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-EnumMap/java-EnumMap02.png\">\n<h3 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnumMap</span>&lt;<span class=\"title\">K</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enum</span>&lt;<span class=\"title\">K</span>&gt;, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;K&gt; keyType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> K[] keyUniverse;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] vals;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上成员变量含义:keyType表示类型信息，keyUniverse表示键，是所有可能的枚举值，vals表示键对应的值，size表示键值对个数。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过枚举的Class类型构造</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EnumMap</span><span class=\"params\">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keyType = keyType;</span><br><span class=\"line\">    keyUniverse = getKeyUniverse(keyType);</span><br><span class=\"line\">    vals = <span class=\"keyword\">new</span> Object[keyUniverse.length];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过EnumMap构造</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EnumMap</span><span class=\"params\">(EnumMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">     keyType = m.keyType;</span><br><span class=\"line\">     keyUniverse = m.keyUniverse;</span><br><span class=\"line\">     vals = m.vals.clone();</span><br><span class=\"line\">     size = m.size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过Map构造,必须保证key的类型是枚举类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EnumMap</span><span class=\"params\">(Map&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m <span class=\"keyword\">instanceof</span> EnumMap) &#123;</span><br><span class=\"line\">        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span><br><span class=\"line\">        keyType = em.keyType;</span><br><span class=\"line\">        keyUniverse = em.keyUniverse;</span><br><span class=\"line\">        vals = em.vals.clone();</span><br><span class=\"line\">        size = em.size;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.isEmpty())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Specified map is empty\"</span>);</span><br><span class=\"line\">        keyType = m.keySet().iterator().next().getDeclaringClass();</span><br><span class=\"line\">        keyUniverse = getKeyUniverse(keyType);</span><br><span class=\"line\">        vals = <span class=\"keyword\">new</span> Object[keyUniverse.length];</span><br><span class=\"line\">        putAll(m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put方法解析\"><a href=\"#put方法解析\" class=\"headerlink\" title=\"put方法解析\"></a>put方法解析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    typeCheck(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = key.ordinal();</span><br><span class=\"line\">    Object oldValue = vals[index];</span><br><span class=\"line\">    vals[index] = maskNull(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unmaskNull(oldValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">typeCheck</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">    Class keyClass = key.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(keyClass + <span class=\"string\">\" != \"</span> + keyType);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">maskNull</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (value == <span class=\"keyword\">null</span> ? NULL : value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">unmaskNull</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (V) (value == NULL ? <span class=\"keyword\">null</span> : value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL = <span class=\"keyword\">new</span> Object() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"java.util.EnumMap.NULL\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>typeCheck方法校验传入key的类型是否与EnumMap初始化时定义的枚举类型对应(包含子类)</li>\n<li>EnumMap允许value为null，为了区别null值与没有值，EnumMap将null值包装成了一个特殊的NULL对象，<br>有两个辅助方法用于null的打包和解包，打包方法为maskNull，解包方法为unmaskNull。</li>\n<li>ordinal()方法是获取key在枚举类中的顺序(索引),将该索引作为往vals数组存放value的索引</li>\n<li>当put相同的key不同value的时候.会重新将旧value覆盖，然后将value值置空。</li>\n</ul>\n<h3 id=\"get方法解析\"><a href=\"#get方法解析\" class=\"headerlink\" title=\"get方法解析\"></a>get方法解析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (isValidKey(key) ?</span><br><span class=\"line\">            unmaskNull(vals[((Enum)key).ordinal()]) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Cheaper than instanceof Enum followed by getDeclaringClass</span></span><br><span class=\"line\">    Class keyClass = key.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>从上面代码可以看出，key通过数组下标映射数据，因此get数据的时候速度效率非常高。</li>\n</ul>\n<h3 id=\"remove方法解析\"><a href=\"#remove方法解析\" class=\"headerlink\" title=\"remove方法解析\"></a>remove方法解析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidKey(key))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class=\"line\">    Object oldValue = vals[index];</span><br><span class=\"line\">    vals[index] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldValue != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unmaskNull(oldValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从上面代码可以看出,删除元素之前先对key进行验证，如果key不是map初始化时指定的枚举类型，那么将会返回null。</li>\n<li>当验证完key之后，再用该key在枚举类中的顺序号作为寻找value的下标，通过该下标将val数组中的值置空。如果value不为null的话，map的size就减1。</li>\n<li>最终将卸载NULL对象，返回删除的value。在remove操作中是不会删除key数组(keyUniverse[])中的任何元素。keyUniverse[]在类构造阶段已经初始化完毕，一直伴随着map的整个生命周期，直到该EnumMap被卸载。</li>\n<li>这里有一个问题需要注意，从代码中我们没有看到任何关于线程安全的代码，因此就会产生ABA的问题。当多线程环境下，很有可能发生当我们删除一个key的value时，value置空了，但是size–没有执行，这时候又有一个线程对相同的key进行put操作,我们获取的size大小就有可能不变,也有可能变大。产生脏读的情况。</li>\n</ul>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.EnumMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        EnumMap&lt;ResultEnum, String&gt; map = <span class=\"keyword\">new</span> EnumMap&lt;ResultEnum, String&gt;(ResultEnum.class);</span><br><span class=\"line\">        map.put(ResultEnum.SUCCESS,<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.SUCCESS,<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.FAIL,<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.DEALING,<span class=\"string\">\"4\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.UNKNOWN,<span class=\"string\">\"5\"</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;SUCCESS=<span class=\"number\">2</span>, FAIL=<span class=\"number\">3</span>, DEALING=<span class=\"number\">4</span>, UNKNOWN=<span class=\"number\">5</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>状态机：根据老大的提示，周六在公司回顾EnumMap的时候，发现确实可以使用EmumMap作为状态机。状态机实现见:EnumMap状态机实现。</p>\n<p>分类场景：对于自己而言，更多的是数据分类场景，同一类的数据对应到同一个枚举，即枚举对应Map的形式。</p>\n<p>由于EnumMap并非线程安全，因此并不适合并发修改的场景。当然，也可以自定义将EnumMap封装成适用并发的Map类，这些都是后话了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>以上就是EnumMap的基本实现原理，内部有两个数组，长度相同，一个表示所有可能的键，一个表示对应的值，值为null表示没有该键值对，键都有一个对应的索引，根据索引可直接访问和操作其键和值，效率很高。<br>  EnumMap的缺点就是并非是线程安全的，可以用工具类包装成现成安全的:Map&lt;EnumKey, V&gt; m = Collections.synchronizedMap(new EnumMap&lt;EnumKey, V&gt;();</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>前段时间学习spring、tomcat的源码非常吃力，发现很多东西都是因为自己的Java基础不够牢固,<br>因此搭建了此博客开始重点关注java基础的相关知识。这篇文章主要分析自己很少使用的EnumMap。</p>\n</blockquote>","more":"<h3 id=\"EnumMap的继承类与实现接口\"><a href=\"#EnumMap的继承类与实现接口\" class=\"headerlink\" title=\"EnumMap的继承类与实现接口\"></a>EnumMap的继承类与实现接口</h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-EnumMap/java-EnumMap01.png\">\n<h3 id=\"EnumMap内部的方法\"><a href=\"#EnumMap内部的方法\" class=\"headerlink\" title=\"EnumMap内部的方法\"></a>EnumMap内部的方法</h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-EnumMap/java-EnumMap02.png\">\n<h3 id=\"类定义\"><a href=\"#类定义\" class=\"headerlink\" title=\"类定义\"></a>类定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EnumMap</span>&lt;<span class=\"title\">K</span> <span class=\"keyword\">extends</span> <span class=\"title\">Enum</span>&lt;<span class=\"title\">K</span>&gt;, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">AbstractMap</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span>, <span class=\"title\">Cloneable</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Class&lt;K&gt; keyType;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> K[] keyUniverse;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> Object[] vals;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">transient</span> <span class=\"keyword\">int</span> size = <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上成员变量含义:keyType表示类型信息，keyUniverse表示键，是所有可能的枚举值，vals表示键对应的值，size表示键值对个数。</p>\n<h3 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过枚举的Class类型构造</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EnumMap</span><span class=\"params\">(Class&lt;K&gt; keyType)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keyType = keyType;</span><br><span class=\"line\">    keyUniverse = getKeyUniverse(keyType);</span><br><span class=\"line\">    vals = <span class=\"keyword\">new</span> Object[keyUniverse.length];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过EnumMap构造</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EnumMap</span><span class=\"params\">(EnumMap&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">     keyType = m.keyType;</span><br><span class=\"line\">     keyUniverse = m.keyUniverse;</span><br><span class=\"line\">     vals = m.vals.clone();</span><br><span class=\"line\">     size = m.size;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 通过Map构造,必须保证key的类型是枚举类型</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">EnumMap</span><span class=\"params\">(Map&lt;K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (m <span class=\"keyword\">instanceof</span> EnumMap) &#123;</span><br><span class=\"line\">        EnumMap&lt;K, ? extends V&gt; em = (EnumMap&lt;K, ? extends V&gt;) m;</span><br><span class=\"line\">        keyType = em.keyType;</span><br><span class=\"line\">        keyUniverse = em.keyUniverse;</span><br><span class=\"line\">        vals = em.vals.clone();</span><br><span class=\"line\">        size = em.size;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (m.isEmpty())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Specified map is empty\"</span>);</span><br><span class=\"line\">        keyType = m.keySet().iterator().next().getDeclaringClass();</span><br><span class=\"line\">        keyUniverse = getKeyUniverse(keyType);</span><br><span class=\"line\">        vals = <span class=\"keyword\">new</span> Object[keyUniverse.length];</span><br><span class=\"line\">        putAll(m);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"put方法解析\"><a href=\"#put方法解析\" class=\"headerlink\" title=\"put方法解析\"></a>put方法解析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    typeCheck(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = key.ordinal();</span><br><span class=\"line\">    Object oldValue = vals[index];</span><br><span class=\"line\">    vals[index] = maskNull(value);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldValue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        size++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unmaskNull(oldValue);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">typeCheck</span><span class=\"params\">(K key)</span> </span>&#123;</span><br><span class=\"line\">    Class keyClass = key.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (keyClass != keyType &amp;&amp; keyClass.getSuperclass() != keyType)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ClassCastException(keyClass + <span class=\"string\">\" != \"</span> + keyType);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Object <span class=\"title\">maskNull</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (value == <span class=\"keyword\">null</span> ? NULL : value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">unmaskNull</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (V) (value == NULL ? <span class=\"keyword\">null</span> : value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Object NULL = <span class=\"keyword\">new</span> Object() &#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"java.util.EnumMap.NULL\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>typeCheck方法校验传入key的类型是否与EnumMap初始化时定义的枚举类型对应(包含子类)</li>\n<li>EnumMap允许value为null，为了区别null值与没有值，EnumMap将null值包装成了一个特殊的NULL对象，<br>有两个辅助方法用于null的打包和解包，打包方法为maskNull，解包方法为unmaskNull。</li>\n<li>ordinal()方法是获取key在枚举类中的顺序(索引),将该索引作为往vals数组存放value的索引</li>\n<li>当put相同的key不同value的时候.会重新将旧value覆盖，然后将value值置空。</li>\n</ul>\n<h3 id=\"get方法解析\"><a href=\"#get方法解析\" class=\"headerlink\" title=\"get方法解析\"></a>get方法解析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (isValidKey(key) ?</span><br><span class=\"line\">            unmaskNull(vals[((Enum)key).ordinal()]) : <span class=\"keyword\">null</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isValidKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Cheaper than instanceof Enum followed by getDeclaringClass</span></span><br><span class=\"line\">    Class keyClass = key.getClass();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> keyClass == keyType || keyClass.getSuperclass() == keyType;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<ul>\n<li>从上面代码可以看出，key通过数组下标映射数据，因此get数据的时候速度效率非常高。</li>\n</ul>\n<h3 id=\"remove方法解析\"><a href=\"#remove方法解析\" class=\"headerlink\" title=\"remove方法解析\"></a>remove方法解析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!isValidKey(key))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = ((Enum&lt;?&gt;)key).ordinal();</span><br><span class=\"line\">    Object oldValue = vals[index];</span><br><span class=\"line\">    vals[index] = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (oldValue != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> unmaskNull(oldValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>从上面代码可以看出,删除元素之前先对key进行验证，如果key不是map初始化时指定的枚举类型，那么将会返回null。</li>\n<li>当验证完key之后，再用该key在枚举类中的顺序号作为寻找value的下标，通过该下标将val数组中的值置空。如果value不为null的话，map的size就减1。</li>\n<li>最终将卸载NULL对象，返回删除的value。在remove操作中是不会删除key数组(keyUniverse[])中的任何元素。keyUniverse[]在类构造阶段已经初始化完毕，一直伴随着map的整个生命周期，直到该EnumMap被卸载。</li>\n<li>这里有一个问题需要注意，从代码中我们没有看到任何关于线程安全的代码，因此就会产生ABA的问题。当多线程环境下，很有可能发生当我们删除一个key的value时，value置空了，但是size–没有执行，这时候又有一个线程对相同的key进行put操作,我们获取的size大小就有可能不变,也有可能变大。产生脏读的情况。</li>\n</ul>\n<h3 id=\"使用方法\"><a href=\"#使用方法\" class=\"headerlink\" title=\"使用方法\"></a>使用方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.EnumMap;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Main</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        EnumMap&lt;ResultEnum, String&gt; map = <span class=\"keyword\">new</span> EnumMap&lt;ResultEnum, String&gt;(ResultEnum.class);</span><br><span class=\"line\">        map.put(ResultEnum.SUCCESS,<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.SUCCESS,<span class=\"string\">\"2\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.FAIL,<span class=\"string\">\"3\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.DEALING,<span class=\"string\">\"4\"</span>);</span><br><span class=\"line\">        map.put(ResultEnum.UNKNOWN,<span class=\"string\">\"5\"</span>);</span><br><span class=\"line\">        System.out.println(map);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;SUCCESS=<span class=\"number\">2</span>, FAIL=<span class=\"number\">3</span>, DEALING=<span class=\"number\">4</span>, UNKNOWN=<span class=\"number\">5</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h3><p>状态机：根据老大的提示，周六在公司回顾EnumMap的时候，发现确实可以使用EmumMap作为状态机。状态机实现见:EnumMap状态机实现。</p>\n<p>分类场景：对于自己而言，更多的是数据分类场景，同一类的数据对应到同一个枚举，即枚举对应Map的形式。</p>\n<p>由于EnumMap并非线程安全，因此并不适合并发修改的场景。当然，也可以自定义将EnumMap封装成适用并发的Map类，这些都是后话了。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>以上就是EnumMap的基本实现原理，内部有两个数组，长度相同，一个表示所有可能的键，一个表示对应的值，值为null表示没有该键值对，键都有一个对应的索引，根据索引可直接访问和操作其键和值，效率很高。<br>  EnumMap的缺点就是并非是线程安全的，可以用工具类包装成现成安全的:Map&lt;EnumKey, V&gt; m = Collections.synchronizedMap(new EnumMap&lt;EnumKey, V&gt;();</p>\n</blockquote>"},{"title":"WeakHashMap解析","date":"2018-05-05T09:34:06.000Z","copyright":true,"_content":"\n{% cq %}\n本篇文章主要浅析WeakHashMap的使用、适用场景和内部实现原理。\n{% endcq %}\n\n<!-- more -->\n\n\n### **IdentityHashMap 继承类与实现接口**\n{% qnimg /java-WeakHashMap/map01.png %}\n### **IdentityHashMap 内部的方法**\n{% qnimg /java-WeakHashMap/map02.png %}\n\n\n### 成员变量\n{% codeblock lang:java %}\n/**\n * 默认初始容量\n */\nprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n\n/**\n * 最大容量\n */\nprivate static final int MAXIMUM_CAPACITY = 1 << 30;\n\n\n/**\n *  如果构造方法中没有指定默认加载因子 0.75\n */\nprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\n/**\n * 元素Entry数组\n */\nEntry<K,V>[] table;\n\n\n/**\n * 元素个数\n */\nprivate int size;\n\n\n/**\n * 要调整大小的下一个值(容量*负载系数)。\n */\nprivate int threshold;\n\n\n/**\n * 哈希表的装载因子\n */\nprivate final float loadFactor;\n\n\n/**\n * 引用队列,用于存储已经被GC的元素引用\n */\nprivate final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n\n\n/**\n * 修改计数\n */\nint modCount;\n\n{% endcodeblock %}\n\n### **核心方法解析**\n\n- 构造方法\n{% codeblock lang:java %}\npublic WeakHashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Initial Capacity: \"+\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load factor: \"+\n                                           loadFactor);\n    int capacity = 1;\n    while (capacity < initialCapacity)\n        capacity <<= 1;\n    table = newTable(capacity);\n    this.loadFactor = loadFactor;\n    threshold = (int)(capacity * loadFactor);\n}\n{% endcodeblock %}\n>判断是否指定容量大小是否是在正常范围,然后计算容量大小并初始化数组,并给threshold赋值(计算触发下一次扩容时的容量大小)\n\n- put方法\n{% codeblock lang:java %}\npublic V put(K key, V value) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n\n    for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    Entry<K,V> e = tab[i];\n    tab[i] = new Entry<>(k, value, queue, h, e);\n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}\n{% endcodeblock %}\n>计算hash值,根据hash值计算数组的索引值,遍历Entry链表，查看是否有相等的key存在，相等替换对应值。如果key不相等，添加键值对。如果超过扩容边界值，那么将重新扩容。\n\n\n- get方法\n{% codeblock lang:java %}\npublic V get(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int index = indexFor(h, tab.length);\n    Entry<K,V> e = tab[index];\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}\n{% endcodeblock %}\n>原理和put方法类似,根据key的hash值计算数组索引，遍历链表,找到相等key获取value并返回\n\n\n- remove方法\n{% codeblock lang:java %}\npublic V remove(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    Entry<K,V> prev = tab[i];\n    Entry<K,V> e = prev;\n\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return null;\n}\n{% endcodeblock %}\n> 根据key的hash值计算索引值,然后遍历单向链表判断相等的key,如果key相等将前一个键值对直接指向下一个键值对，这样就过掉了当前的键值对。上面prev==e 是为了判断当key和链表中的第一个Entry就相等的话，直接将tab[i]赋值成下一个元素\n\n\n- Entry实现\n{% codeblock lang:java %}\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {\n    V value;\n    final int hash;\n    Entry<K,V> next;\n\n    /**\n     * Creates new entry.\n     */\n    Entry(Object key, V value,\n          ReferenceQueue<Object> queue,\n          int hash, Entry<K,V> next) {\n        super(key, queue);\n        this.value = value;\n        this.hash  = hash;\n        this.next  = next;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public K getKey() {\n        return (K) WeakHashMap.unmaskNull(get());\n    }\n\n    public V getValue() {\n        return value;\n    }\n\n    public V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        K k1 = getKey();\n        Object k2 = e.getKey();\n        if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n            V v1 = getValue();\n            Object v2 = e.getValue();\n            if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                return true;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        K k = getKey();\n        V v = getValue();\n        return Objects.hashCode(k) ^ Objects.hashCode(v);\n    }\n\n    public String toString() {\n        return getKey() + \"=\" + getValue();\n    }\n}\n{% endcodeblock %}\n> 因为WeakHashMap中的Entry都是弱引用,所以一旦weakhashmap外的强引用断掉，那么这个对象就会被回收，weakhashMap指向该对象的引用也会失效。\n\n\n### **总结**\n> WeakHashMap和hashMap相似,内部都是维护了hash表和链表。不同的是WeakHashMap链表中的Entry继承了弱引用，当外部强引用失效后，weakHashMap对应的键值对也会失效。\n> 因此WeakHashMap适合存储元素经常发生变化的数据,可以防止发生强引用导致的内存泄漏。\n\n\n### **注意**\n> 常量数据存储在WeakHashMap中，无论其外部key的引用是否为null,都不会在weakhashMap中被清除，只有手动remove才会被清除,例如下面的示例\n\n{% codeblock lang:java %}\n@Test\npublic void testWeakHashMap(){\n\nWeakHashMap weakHashMap = new WeakHashMap();\nString a1 = \"a1\";\nString a2 = \"a2\";\nString a3 = new String(\"a3\");\nweakHashMap.put(a1 ,\"a1\");\nweakHashMap.put(a2, \"a2\");\nweakHashMap.put(a3, \"a3\");\nSystem.out.println(weakHashMap);\n\na3 = null;\nSystem.gc();\nSystem.out.println(weakHashMap);\n}\n{% endcodeblock %}\n> String a1 = \"a1\" 是存储在常量池中的 即使a1=null, weakHashMap中的a1键值对还是会存在，因为a1引用的指向的内存区域数据还是存在，通俗讲就是a1指向的是常量池，GC不会回收常量池中的内容。所以weakHashMap不会影响指向常量数据的引用。","source":"_posts/java-WeakHashMap.md","raw":"---\ntitle: WeakHashMap解析\ndate: 2018-05-05 17:34:06\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n\n{% cq %}\n本篇文章主要浅析WeakHashMap的使用、适用场景和内部实现原理。\n{% endcq %}\n\n<!-- more -->\n\n\n### **IdentityHashMap 继承类与实现接口**\n{% qnimg /java-WeakHashMap/map01.png %}\n### **IdentityHashMap 内部的方法**\n{% qnimg /java-WeakHashMap/map02.png %}\n\n\n### 成员变量\n{% codeblock lang:java %}\n/**\n * 默认初始容量\n */\nprivate static final int DEFAULT_INITIAL_CAPACITY = 16;\n\n\n/**\n * 最大容量\n */\nprivate static final int MAXIMUM_CAPACITY = 1 << 30;\n\n\n/**\n *  如果构造方法中没有指定默认加载因子 0.75\n */\nprivate static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n\n/**\n * 元素Entry数组\n */\nEntry<K,V>[] table;\n\n\n/**\n * 元素个数\n */\nprivate int size;\n\n\n/**\n * 要调整大小的下一个值(容量*负载系数)。\n */\nprivate int threshold;\n\n\n/**\n * 哈希表的装载因子\n */\nprivate final float loadFactor;\n\n\n/**\n * 引用队列,用于存储已经被GC的元素引用\n */\nprivate final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n\n\n/**\n * 修改计数\n */\nint modCount;\n\n{% endcodeblock %}\n\n### **核心方法解析**\n\n- 构造方法\n{% codeblock lang:java %}\npublic WeakHashMap(int initialCapacity, float loadFactor) {\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException(\"Illegal Initial Capacity: \"+\n                                           initialCapacity);\n    if (initialCapacity > MAXIMUM_CAPACITY)\n        initialCapacity = MAXIMUM_CAPACITY;\n\n    if (loadFactor <= 0 || Float.isNaN(loadFactor))\n        throw new IllegalArgumentException(\"Illegal Load factor: \"+\n                                           loadFactor);\n    int capacity = 1;\n    while (capacity < initialCapacity)\n        capacity <<= 1;\n    table = newTable(capacity);\n    this.loadFactor = loadFactor;\n    threshold = (int)(capacity * loadFactor);\n}\n{% endcodeblock %}\n>判断是否指定容量大小是否是在正常范围,然后计算容量大小并初始化数组,并给threshold赋值(计算触发下一次扩容时的容量大小)\n\n- put方法\n{% codeblock lang:java %}\npublic V put(K key, V value) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n\n    for (Entry<K,V> e = tab[i]; e != null; e = e.next) {\n        if (h == e.hash && eq(k, e.get())) {\n            V oldValue = e.value;\n            if (value != oldValue)\n                e.value = value;\n            return oldValue;\n        }\n    }\n\n    modCount++;\n    Entry<K,V> e = tab[i];\n    tab[i] = new Entry<>(k, value, queue, h, e);\n    if (++size >= threshold)\n        resize(tab.length * 2);\n    return null;\n}\n{% endcodeblock %}\n>计算hash值,根据hash值计算数组的索引值,遍历Entry链表，查看是否有相等的key存在，相等替换对应值。如果key不相等，添加键值对。如果超过扩容边界值，那么将重新扩容。\n\n\n- get方法\n{% codeblock lang:java %}\npublic V get(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int index = indexFor(h, tab.length);\n    Entry<K,V> e = tab[index];\n    while (e != null) {\n        if (e.hash == h && eq(k, e.get()))\n            return e.value;\n        e = e.next;\n    }\n    return null;\n}\n{% endcodeblock %}\n>原理和put方法类似,根据key的hash值计算数组索引，遍历链表,找到相等key获取value并返回\n\n\n- remove方法\n{% codeblock lang:java %}\npublic V remove(Object key) {\n    Object k = maskNull(key);\n    int h = hash(k);\n    Entry<K,V>[] tab = getTable();\n    int i = indexFor(h, tab.length);\n    Entry<K,V> prev = tab[i];\n    Entry<K,V> e = prev;\n\n    while (e != null) {\n        Entry<K,V> next = e.next;\n        if (h == e.hash && eq(k, e.get())) {\n            modCount++;\n            size--;\n            if (prev == e)\n                tab[i] = next;\n            else\n                prev.next = next;\n            return e.value;\n        }\n        prev = e;\n        e = next;\n    }\n\n    return null;\n}\n{% endcodeblock %}\n> 根据key的hash值计算索引值,然后遍历单向链表判断相等的key,如果key相等将前一个键值对直接指向下一个键值对，这样就过掉了当前的键值对。上面prev==e 是为了判断当key和链表中的第一个Entry就相等的话，直接将tab[i]赋值成下一个元素\n\n\n- Entry实现\n{% codeblock lang:java %}\nprivate static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {\n    V value;\n    final int hash;\n    Entry<K,V> next;\n\n    /**\n     * Creates new entry.\n     */\n    Entry(Object key, V value,\n          ReferenceQueue<Object> queue,\n          int hash, Entry<K,V> next) {\n        super(key, queue);\n        this.value = value;\n        this.hash  = hash;\n        this.next  = next;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public K getKey() {\n        return (K) WeakHashMap.unmaskNull(get());\n    }\n\n    public V getValue() {\n        return value;\n    }\n\n    public V setValue(V newValue) {\n        V oldValue = value;\n        value = newValue;\n        return oldValue;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        K k1 = getKey();\n        Object k2 = e.getKey();\n        if (k1 == k2 || (k1 != null && k1.equals(k2))) {\n            V v1 = getValue();\n            Object v2 = e.getValue();\n            if (v1 == v2 || (v1 != null && v1.equals(v2)))\n                return true;\n        }\n        return false;\n    }\n\n    public int hashCode() {\n        K k = getKey();\n        V v = getValue();\n        return Objects.hashCode(k) ^ Objects.hashCode(v);\n    }\n\n    public String toString() {\n        return getKey() + \"=\" + getValue();\n    }\n}\n{% endcodeblock %}\n> 因为WeakHashMap中的Entry都是弱引用,所以一旦weakhashmap外的强引用断掉，那么这个对象就会被回收，weakhashMap指向该对象的引用也会失效。\n\n\n### **总结**\n> WeakHashMap和hashMap相似,内部都是维护了hash表和链表。不同的是WeakHashMap链表中的Entry继承了弱引用，当外部强引用失效后，weakHashMap对应的键值对也会失效。\n> 因此WeakHashMap适合存储元素经常发生变化的数据,可以防止发生强引用导致的内存泄漏。\n\n\n### **注意**\n> 常量数据存储在WeakHashMap中，无论其外部key的引用是否为null,都不会在weakhashMap中被清除，只有手动remove才会被清除,例如下面的示例\n\n{% codeblock lang:java %}\n@Test\npublic void testWeakHashMap(){\n\nWeakHashMap weakHashMap = new WeakHashMap();\nString a1 = \"a1\";\nString a2 = \"a2\";\nString a3 = new String(\"a3\");\nweakHashMap.put(a1 ,\"a1\");\nweakHashMap.put(a2, \"a2\");\nweakHashMap.put(a3, \"a3\");\nSystem.out.println(weakHashMap);\n\na3 = null;\nSystem.gc();\nSystem.out.println(weakHashMap);\n}\n{% endcodeblock %}\n> String a1 = \"a1\" 是存储在常量池中的 即使a1=null, weakHashMap中的a1键值对还是会存在，因为a1引用的指向的内存区域数据还是存在，通俗讲就是a1指向的是常量池，GC不会回收常量池中的内容。所以weakHashMap不会影响指向常量数据的引用。","slug":"java-WeakHashMap","published":1,"updated":"2018-10-11T11:25:07.196Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6j000km9cg5dx8xiww","content":"<blockquote class=\"blockquote-center\"><p>本篇文章主要浅析WeakHashMap的使用、适用场景和内部实现原理。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"IdentityHashMap-继承类与实现接口\"><a href=\"#IdentityHashMap-继承类与实现接口\" class=\"headerlink\" title=\"IdentityHashMap 继承类与实现接口\"></a><strong>IdentityHashMap 继承类与实现接口</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-WeakHashMap/map01.png\">\n<h3 id=\"IdentityHashMap-内部的方法\"><a href=\"#IdentityHashMap-内部的方法\" class=\"headerlink\" title=\"IdentityHashMap 内部的方法\"></a><strong>IdentityHashMap 内部的方法</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-WeakHashMap/map02.png\">\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认初始容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果构造方法中没有指定默认加载因子 0.75</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 元素Entry数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Entry&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 元素个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要调整大小的下一个值(容量*负载系数)。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 哈希表的装载因子</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 引用队列,用于存储已经被GC的元素引用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改计数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"核心方法解析\"><a href=\"#核心方法解析\" class=\"headerlink\" title=\"核心方法解析\"></a><strong>核心方法解析</strong></h3><ul>\n<li><p>构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Initial Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load factor: \"</span>+</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (capacity &lt; initialCapacity)</span><br><span class=\"line\">        capacity &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    table = newTable(capacity);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)(capacity * loadFactor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>判断是否指定容量大小是否是在正常范围,然后计算容量大小并初始化数组,并给threshold赋值(计算触发下一次扩容时的容量大小)</p>\n</blockquote>\n</li>\n<li><p>put方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != oldValue)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt;= threshold)</span><br><span class=\"line\">        resize(tab.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>计算hash值,根据hash值计算数组的索引值,遍历Entry链表，查看是否有相等的key存在，相等替换对应值。如果key不相等，添加键值对。如果超过扩容边界值，那么将重新扩容。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>get方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        e = e.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原理和put方法类似,根据key的hash值计算数组索引，遍历链表,找到相等key获取value并返回</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>remove方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                tab[i] = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e;</span><br><span class=\"line\">        e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>根据key的hash值计算索引值,然后遍历单向链表判断相等的key,如果key相等将前一个键值对直接指向下一个键值对，这样就过掉了当前的键值对。上面prev==e 是为了判断当key和链表中的第一个Entry就相等的话，直接将tab[i]赋值成下一个元素</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>Entry实现<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">Object</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">    Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates new entry.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Entry(Object key, V value,</span><br><span class=\"line\">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class=\"line\">          <span class=\"keyword\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key, queue);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash  = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next  = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (K) WeakHashMap.unmaskNull(get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">        K k1 = getKey();</span><br><span class=\"line\">        Object k2 = e.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k1 == k2 || (k1 != <span class=\"keyword\">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class=\"line\">            V v1 = getValue();</span><br><span class=\"line\">            Object v2 = e.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v1 == v2 || (v1 != <span class=\"keyword\">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        K k = getKey();</span><br><span class=\"line\">        V v = getValue();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey() + <span class=\"string\">\"=\"</span> + getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为WeakHashMap中的Entry都是弱引用,所以一旦weakhashmap外的强引用断掉，那么这个对象就会被回收，weakhashMap指向该对象的引用也会失效。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><blockquote>\n<p>WeakHashMap和hashMap相似,内部都是维护了hash表和链表。不同的是WeakHashMap链表中的Entry继承了弱引用，当外部强引用失效后，weakHashMap对应的键值对也会失效。<br>因此WeakHashMap适合存储元素经常发生变化的数据,可以防止发生强引用导致的内存泄漏。</p>\n</blockquote>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a><strong>注意</strong></h3><blockquote>\n<p>常量数据存储在WeakHashMap中，无论其外部key的引用是否为null,都不会在weakhashMap中被清除，只有手动remove才会被清除,例如下面的示例</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testWeakHashMap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">WeakHashMap weakHashMap = <span class=\"keyword\">new</span> WeakHashMap();</span><br><span class=\"line\">String a1 = <span class=\"string\">\"a1\"</span>;</span><br><span class=\"line\">String a2 = <span class=\"string\">\"a2\"</span>;</span><br><span class=\"line\">String a3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"a3\"</span>);</span><br><span class=\"line\">weakHashMap.put(a1 ,<span class=\"string\">\"a1\"</span>);</span><br><span class=\"line\">weakHashMap.put(a2, <span class=\"string\">\"a2\"</span>);</span><br><span class=\"line\">weakHashMap.put(a3, <span class=\"string\">\"a3\"</span>);</span><br><span class=\"line\">System.out.println(weakHashMap);</span><br><span class=\"line\"></span><br><span class=\"line\">a3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(weakHashMap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>String a1 = “a1” 是存储在常量池中的 即使a1=null, weakHashMap中的a1键值对还是会存在，因为a1引用的指向的内存区域数据还是存在，通俗讲就是a1指向的是常量池，GC不会回收常量池中的内容。所以weakHashMap不会影响指向常量数据的引用。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>本篇文章主要浅析WeakHashMap的使用、适用场景和内部实现原理。</p>\n</blockquote>","more":"<h3 id=\"IdentityHashMap-继承类与实现接口\"><a href=\"#IdentityHashMap-继承类与实现接口\" class=\"headerlink\" title=\"IdentityHashMap 继承类与实现接口\"></a><strong>IdentityHashMap 继承类与实现接口</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-WeakHashMap/map01.png\">\n<h3 id=\"IdentityHashMap-内部的方法\"><a href=\"#IdentityHashMap-内部的方法\" class=\"headerlink\" title=\"IdentityHashMap 内部的方法\"></a><strong>IdentityHashMap 内部的方法</strong></h3><img src=\"http://qiniuyun.xanderxu.cn/static/images//java-WeakHashMap/map02.png\">\n<h3 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 默认初始容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> DEFAULT_INITIAL_CAPACITY = <span class=\"number\">16</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 最大容量</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> MAXIMUM_CAPACITY = <span class=\"number\">1</span> &lt;&lt; <span class=\"number\">30</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  如果构造方法中没有指定默认加载因子 0.75</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> DEFAULT_LOAD_FACTOR = <span class=\"number\">0.75f</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 元素Entry数组</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\">Entry&lt;K,V&gt;[] table;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 元素个数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> size;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 要调整大小的下一个值(容量*负载系数)。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> threshold;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 哈希表的装载因子</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"keyword\">float</span> loadFactor;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 引用队列,用于存储已经被GC的元素引用</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ReferenceQueue&lt;Object&gt; queue = <span class=\"keyword\">new</span> ReferenceQueue&lt;&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 修改计数</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> modCount;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"核心方法解析\"><a href=\"#核心方法解析\" class=\"headerlink\" title=\"核心方法解析\"></a><strong>核心方法解析</strong></h3><ul>\n<li><p>构造方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">WeakHashMap</span><span class=\"params\">(<span class=\"keyword\">int</span> initialCapacity, <span class=\"keyword\">float</span> loadFactor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Initial Capacity: \"</span>+</span><br><span class=\"line\">                                           initialCapacity);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class=\"line\">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (loadFactor &lt;= <span class=\"number\">0</span> || Float.isNaN(loadFactor))</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Illegal Load factor: \"</span>+</span><br><span class=\"line\">                                           loadFactor);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> capacity = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (capacity &lt; initialCapacity)</span><br><span class=\"line\">        capacity &lt;&lt;= <span class=\"number\">1</span>;</span><br><span class=\"line\">    table = newTable(capacity);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.loadFactor = loadFactor;</span><br><span class=\"line\">    threshold = (<span class=\"keyword\">int</span>)(capacity * loadFactor);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>判断是否指定容量大小是否是在正常范围,然后计算容量大小并初始化数组,并给threshold赋值(计算触发下一次扩容时的容量大小)</p>\n</blockquote>\n</li>\n<li><p>put方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Entry&lt;K,V&gt; e = tab[i]; e != <span class=\"keyword\">null</span>; e = e.next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            V oldValue = e.value;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value != oldValue)</span><br><span class=\"line\">                e.value = value;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    modCount++;</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[i];</span><br><span class=\"line\">    tab[i] = <span class=\"keyword\">new</span> Entry&lt;&gt;(k, value, queue, h, e);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (++size &gt;= threshold)</span><br><span class=\"line\">        resize(tab.length * <span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>计算hash值,根据hash值计算数组的索引值,遍历Entry链表，查看是否有相等的key存在，相等替换对应值。如果key不相等，添加键值对。如果超过扩容边界值，那么将重新扩容。</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>get方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = tab[index];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e.hash == h &amp;&amp; eq(k, e.get()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        e = e.next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原理和put方法类似,根据key的hash值计算数组索引，遍历链表,找到相等key获取value并返回</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>remove方法<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Object k = maskNull(key);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h = hash(k);</span><br><span class=\"line\">    Entry&lt;K,V&gt;[] tab = getTable();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i = indexFor(h, tab.length);</span><br><span class=\"line\">    Entry&lt;K,V&gt; prev = tab[i];</span><br><span class=\"line\">    Entry&lt;K,V&gt; e = prev;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (e != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        Entry&lt;K,V&gt; next = e.next;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h == e.hash &amp;&amp; eq(k, e.get())) &#123;</span><br><span class=\"line\">            modCount++;</span><br><span class=\"line\">            size--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (prev == e)</span><br><span class=\"line\">                tab[i] = next;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">                prev.next = next;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.value;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        prev = e;</span><br><span class=\"line\">        e = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>根据key的hash值计算索引值,然后遍历单向链表判断相等的key,如果key相等将前一个键值对直接指向下一个键值对，这样就过掉了当前的键值对。上面prev==e 是为了判断当key和链表中的第一个Entry就相等的话，直接将tab[i]赋值成下一个元素</p>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>Entry实现<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">WeakReference</span>&lt;<span class=\"title\">Object</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Map</span>.<span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    V value;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> hash;</span><br><span class=\"line\">    Entry&lt;K,V&gt; next;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Creates new entry.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    Entry(Object key, V value,</span><br><span class=\"line\">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class=\"line\">          <span class=\"keyword\">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(key, queue);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.hash  = hash;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.next  = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (K) WeakHashMap.unmaskNull(get());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V newValue)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = value;</span><br><span class=\"line\">        value = newValue;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">        K k1 = getKey();</span><br><span class=\"line\">        Object k2 = e.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (k1 == k2 || (k1 != <span class=\"keyword\">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class=\"line\">            V v1 = getValue();</span><br><span class=\"line\">            Object v2 = e.getValue();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (v1 == v2 || (v1 != <span class=\"keyword\">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        K k = getKey();</span><br><span class=\"line\">        V v = getValue();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Objects.hashCode(k) ^ Objects.hashCode(v);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getKey() + <span class=\"string\">\"=\"</span> + getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为WeakHashMap中的Entry都是弱引用,所以一旦weakhashmap外的强引用断掉，那么这个对象就会被回收，weakhashMap指向该对象的引用也会失效。</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a><strong>总结</strong></h3><blockquote>\n<p>WeakHashMap和hashMap相似,内部都是维护了hash表和链表。不同的是WeakHashMap链表中的Entry继承了弱引用，当外部强引用失效后，weakHashMap对应的键值对也会失效。<br>因此WeakHashMap适合存储元素经常发生变化的数据,可以防止发生强引用导致的内存泄漏。</p>\n</blockquote>\n<h3 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a><strong>注意</strong></h3><blockquote>\n<p>常量数据存储在WeakHashMap中，无论其外部key的引用是否为null,都不会在weakhashMap中被清除，只有手动remove才会被清除,例如下面的示例</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testWeakHashMap</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">WeakHashMap weakHashMap = <span class=\"keyword\">new</span> WeakHashMap();</span><br><span class=\"line\">String a1 = <span class=\"string\">\"a1\"</span>;</span><br><span class=\"line\">String a2 = <span class=\"string\">\"a2\"</span>;</span><br><span class=\"line\">String a3 = <span class=\"keyword\">new</span> String(<span class=\"string\">\"a3\"</span>);</span><br><span class=\"line\">weakHashMap.put(a1 ,<span class=\"string\">\"a1\"</span>);</span><br><span class=\"line\">weakHashMap.put(a2, <span class=\"string\">\"a2\"</span>);</span><br><span class=\"line\">weakHashMap.put(a3, <span class=\"string\">\"a3\"</span>);</span><br><span class=\"line\">System.out.println(weakHashMap);</span><br><span class=\"line\"></span><br><span class=\"line\">a3 = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">System.gc();</span><br><span class=\"line\">System.out.println(weakHashMap);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>String a1 = “a1” 是存储在常量池中的 即使a1=null, weakHashMap中的a1键值对还是会存在，因为a1引用的指向的内存区域数据还是存在，通俗讲就是a1指向的是常量池，GC不会回收常量池中的内容。所以weakHashMap不会影响指向常量数据的引用。</p>\n</blockquote>"},{"title":"ThreadLocalExecutor解析","copyright":true,"date":"2018-08-12T12:33:00.000Z","_content":"\n{% cq %}\n通过学习Btrace想要追踪线程池状态，公司常用ThreadPoolExecutor线程池，由于对其内部原理与实现细节不够了解，因此本文对线程池进行简要分析\n{% endcq %}\n<!-- more -->\n\n### 构造函数\n{% codeblock lang:java %}\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n{% endcodeblock %}\n- corePoolSize 核心线程数\n- maximumPoolSize 最大线程数\n- keepAliveTime 线程空闲时间\n- TimeUnit 时间单位\n- BlockingQueue<Runnable> 等待队列类型\n- ThreadFactory 线程工厂\n- RejectedExecutionHandler 拒绝策略\n\n### 状态定义\n{% codeblock lang:java %}\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n{% endcodeblock %}\n> ThreadPoolExecutor是将Int的高3位用来标志当前线程池的状态，低29位标志当前线程池的线程数。由此我们可以得知最大线程数是2^29-1。\n- RUNNING -1左移29位即11111....111111 << (29) 最终高3位是111\n- SHUTDOWN 0左移29位00000.....000000 <<  (29) 最终高3位是000\n- STOP 1左移29位000000.....00001 << (29) 最终高3位是001\n- TIDYING 2左移29位000000...00002 << (29) 最终高3位是002\n- TERMINATED 3左移29位000000...003 << (29) 最终高3位是003\n- runStateOf 获取当前线程池的状态\n- workerCountOf 获取当前线程池线程数目\n- ctlOf 根据线程数和线程池状态计算代表当前线程状态的int值\n\n### 线程池执行流程\n- 1.调用ThreadPoolExecutor的execute方法提交线程，如果线程池内的线程小于核心线程数，那么就创建新线程执行任务\n- 2.如果线程池内的线程数大于或等于核心线程数，那么就会将该线程加入任务队列，如果不能加入任务队列，那么如果当前线程池内的线程数小于最大线程数，那么创建新线程执行任务。\n- 3.如果当前线程池内的线程数超出maximumPoolSize，那么将执行拒绝策略(RejectedExecutionHandler)\n\n### execute方法\n{% codeblock lang:java %}\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    /*\n     * 三个步骤:\n     *\n     * 1.如果运行的线程少于corepoolol大小，请尝试以给定的任务作为第一个任务启动一个新线程。\n     * 对addWorker的调用原子性地检查运行状态和workerCount，从而通过返回false防止假警报，假警报会在不应该的情况下添加线程。\n     *\n     * 2.如果一个任务可以成功排队，那么我们仍然需要再次检查是否应该添加一个线程(因为自上次检查以来已有线程死亡)，\n     * 或者在进入该方法后池关闭。因此，我们重新检查状态，如果有必要，如果停止则回滚排队，如果没有，则启动一个新线程。\n     *\n     * 3.如果不能对任务进行排队，则尝试添加一个新任务线程。如果它失败了，我们知道我们已经关闭或饱和了所以拒绝这个任务。\n     */\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    else if (!addWorker(command, false))\n        reject(command);\n}\n{% endcodeblock %}\n> 对上面内容做详细分析(重要):\n> 1.首先判断当前线程池的状态以及当前线程的数目，判断当前线程的数目是否小于核心线程池的限制，如果小于，就新建线程添加任务\n> 2.如果超过核心线程池限制，那么判断线程池状态是否是Running，并且将任务添加到任务队列，等待线程处理，如果这时候线程数为0，那么就新建空线程，执行队列中的任务\n> 3.如果往任务队列中没有添加成功，那么就说明当前线程超出最大线程数限制，执行拒绝策略。\n\n### addWorker方法\n{% codeblock lang:java %}\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n{% endcodeblock %}\n\n- 1.首先对线程池，任务队列进行前期检查\n- 2.对当前线程池中线程数的校验\n- 3.新建Worker，Worker类集成AbstractQueuedSynchronizer并且实现Runnable接口，说明Worker可以执行任务并且支持AQS(独占锁)\n- 4.添加任务的时候使用可重入锁锁住当前操作，防止并发产生一些脏读问题，导致线程池内的参数不准确，进而导致线程执行任务失败。\n- 5.添加任务成功后,就执行该线程，内部最终调用Runnable的run方法\n- 6.通过返回boolean类型数据，告诉调用者添加任务是否成功。\n\n\n### Shutdown方法\n{% codeblock lang:java %}\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        advanceRunState(SHUTDOWN);\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n{% endcodeblock %}\n\n- 1.判断是否拥有操作这些线程的权限\n- 2.设置线程池的状态为SHUTDOWN\n- 3.中断所有空闲线程(即没有执行任务的线程)\n- 4.onShutdown() 该类中并实现该方法\n- 5.尝试转换为最终状态TERMINATED\n\n### 总结\n> 本文只是简要分析了ThreadPoolExecutor的大体流程，以及具体的一些细节，由于其核心方法addWorker还有疑问，因此只是对其简要分析，后期会更新本文追加其详细内容。","source":"_posts/java-ThreadLocalExecutor.md","raw":"title: ThreadLocalExecutor解析\ncopyright: true\ntags:\n  - java\ncategories:\n  - java\ndate: 2018-08-12 20:33:00\n---\n\n{% cq %}\n通过学习Btrace想要追踪线程池状态，公司常用ThreadPoolExecutor线程池，由于对其内部原理与实现细节不够了解，因此本文对线程池进行简要分析\n{% endcq %}\n<!-- more -->\n\n### 构造函数\n{% codeblock lang:java %}\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n    if (corePoolSize < 0 ||\n        maximumPoolSize <= 0 ||\n        maximumPoolSize < corePoolSize ||\n        keepAliveTime < 0)\n        throw new IllegalArgumentException();\n    if (workQueue == null || threadFactory == null || handler == null)\n        throw new NullPointerException();\n    this.acc = System.getSecurityManager() == null ?\n            null :\n            AccessController.getContext();\n    this.corePoolSize = corePoolSize;\n    this.maximumPoolSize = maximumPoolSize;\n    this.workQueue = workQueue;\n    this.keepAliveTime = unit.toNanos(keepAliveTime);\n    this.threadFactory = threadFactory;\n    this.handler = handler;\n}\n{% endcodeblock %}\n- corePoolSize 核心线程数\n- maximumPoolSize 最大线程数\n- keepAliveTime 线程空闲时间\n- TimeUnit 时间单位\n- BlockingQueue<Runnable> 等待队列类型\n- ThreadFactory 线程工厂\n- RejectedExecutionHandler 拒绝策略\n\n### 状态定义\n{% codeblock lang:java %}\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n// Packing and unpacking ctl\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n{% endcodeblock %}\n> ThreadPoolExecutor是将Int的高3位用来标志当前线程池的状态，低29位标志当前线程池的线程数。由此我们可以得知最大线程数是2^29-1。\n- RUNNING -1左移29位即11111....111111 << (29) 最终高3位是111\n- SHUTDOWN 0左移29位00000.....000000 <<  (29) 最终高3位是000\n- STOP 1左移29位000000.....00001 << (29) 最终高3位是001\n- TIDYING 2左移29位000000...00002 << (29) 最终高3位是002\n- TERMINATED 3左移29位000000...003 << (29) 最终高3位是003\n- runStateOf 获取当前线程池的状态\n- workerCountOf 获取当前线程池线程数目\n- ctlOf 根据线程数和线程池状态计算代表当前线程状态的int值\n\n### 线程池执行流程\n- 1.调用ThreadPoolExecutor的execute方法提交线程，如果线程池内的线程小于核心线程数，那么就创建新线程执行任务\n- 2.如果线程池内的线程数大于或等于核心线程数，那么就会将该线程加入任务队列，如果不能加入任务队列，那么如果当前线程池内的线程数小于最大线程数，那么创建新线程执行任务。\n- 3.如果当前线程池内的线程数超出maximumPoolSize，那么将执行拒绝策略(RejectedExecutionHandler)\n\n### execute方法\n{% codeblock lang:java %}\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    /*\n     * 三个步骤:\n     *\n     * 1.如果运行的线程少于corepoolol大小，请尝试以给定的任务作为第一个任务启动一个新线程。\n     * 对addWorker的调用原子性地检查运行状态和workerCount，从而通过返回false防止假警报，假警报会在不应该的情况下添加线程。\n     *\n     * 2.如果一个任务可以成功排队，那么我们仍然需要再次检查是否应该添加一个线程(因为自上次检查以来已有线程死亡)，\n     * 或者在进入该方法后池关闭。因此，我们重新检查状态，如果有必要，如果停止则回滚排队，如果没有，则启动一个新线程。\n     *\n     * 3.如果不能对任务进行排队，则尝试添加一个新任务线程。如果它失败了，我们知道我们已经关闭或饱和了所以拒绝这个任务。\n     */\n    int c = ctl.get();\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    else if (!addWorker(command, false))\n        reject(command);\n}\n{% endcodeblock %}\n> 对上面内容做详细分析(重要):\n> 1.首先判断当前线程池的状态以及当前线程的数目，判断当前线程的数目是否小于核心线程池的限制，如果小于，就新建线程添加任务\n> 2.如果超过核心线程池限制，那么判断线程池状态是否是Running，并且将任务添加到任务队列，等待线程处理，如果这时候线程数为0，那么就新建空线程，执行队列中的任务\n> 3.如果往任务队列中没有添加成功，那么就说明当前线程超出最大线程数限制，执行拒绝策略。\n\n### addWorker方法\n{% codeblock lang:java %}\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n{% endcodeblock %}\n\n- 1.首先对线程池，任务队列进行前期检查\n- 2.对当前线程池中线程数的校验\n- 3.新建Worker，Worker类集成AbstractQueuedSynchronizer并且实现Runnable接口，说明Worker可以执行任务并且支持AQS(独占锁)\n- 4.添加任务的时候使用可重入锁锁住当前操作，防止并发产生一些脏读问题，导致线程池内的参数不准确，进而导致线程执行任务失败。\n- 5.添加任务成功后,就执行该线程，内部最终调用Runnable的run方法\n- 6.通过返回boolean类型数据，告诉调用者添加任务是否成功。\n\n\n### Shutdown方法\n{% codeblock lang:java %}\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        advanceRunState(SHUTDOWN);\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n{% endcodeblock %}\n\n- 1.判断是否拥有操作这些线程的权限\n- 2.设置线程池的状态为SHUTDOWN\n- 3.中断所有空闲线程(即没有执行任务的线程)\n- 4.onShutdown() 该类中并实现该方法\n- 5.尝试转换为最终状态TERMINATED\n\n### 总结\n> 本文只是简要分析了ThreadPoolExecutor的大体流程，以及具体的一些细节，由于其核心方法addWorker还有疑问，因此只是对其简要分析，后期会更新本文追加其详细内容。","slug":"java-ThreadLocalExecutor","published":1,"updated":"2018-10-11T10:51:22.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6l000pm9cgje7h1gox","content":"<blockquote class=\"blockquote-center\"><p>通过学习Btrace想要追踪线程池状态，公司常用ThreadPoolExecutor线程池，由于对其内部原理与实现细节不够了解，因此本文对线程池进行简要分析</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> :</span><br><span class=\"line\">            AccessController.getContext();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>corePoolSize 核心线程数</li>\n<li>maximumPoolSize 最大线程数</li>\n<li>keepAliveTime 线程空闲时间</li>\n<li>TimeUnit 时间单位</li>\n<li>BlockingQueue<runnable> 等待队列类型</runnable></li>\n<li>ThreadFactory 线程工厂</li>\n<li>RejectedExecutionHandler 拒绝策略</li>\n</ul>\n<h3 id=\"状态定义\"><a href=\"#状态定义\" class=\"headerlink\" title=\"状态定义\"></a>状态定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Packing and unpacking ctl</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ThreadPoolExecutor是将Int的高3位用来标志当前线程池的状态，低29位标志当前线程池的线程数。由此我们可以得知最大线程数是2^29-1。</p>\n<ul>\n<li>RUNNING -1左移29位即11111….111111 &lt;&lt; (29) 最终高3位是111</li>\n<li>SHUTDOWN 0左移29位00000…..000000 &lt;&lt;  (29) 最终高3位是000</li>\n<li>STOP 1左移29位000000…..00001 &lt;&lt; (29) 最终高3位是001</li>\n<li>TIDYING 2左移29位000000…00002 &lt;&lt; (29) 最终高3位是002</li>\n<li>TERMINATED 3左移29位000000…003 &lt;&lt; (29) 最终高3位是003</li>\n<li>runStateOf 获取当前线程池的状态</li>\n<li>workerCountOf 获取当前线程池线程数目</li>\n<li>ctlOf 根据线程数和线程池状态计算代表当前线程状态的int值</li>\n</ul>\n</blockquote>\n<h3 id=\"线程池执行流程\"><a href=\"#线程池执行流程\" class=\"headerlink\" title=\"线程池执行流程\"></a>线程池执行流程</h3><ul>\n<li>1.调用ThreadPoolExecutor的execute方法提交线程，如果线程池内的线程小于核心线程数，那么就创建新线程执行任务</li>\n<li>2.如果线程池内的线程数大于或等于核心线程数，那么就会将该线程加入任务队列，如果不能加入任务队列，那么如果当前线程池内的线程数小于最大线程数，那么创建新线程执行任务。</li>\n<li>3.如果当前线程池内的线程数超出maximumPoolSize，那么将执行拒绝策略(RejectedExecutionHandler)</li>\n</ul>\n<h3 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 三个步骤:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.如果运行的线程少于corepoolol大小，请尝试以给定的任务作为第一个任务启动一个新线程。</span></span><br><span class=\"line\"><span class=\"comment\">     * 对addWorker的调用原子性地检查运行状态和workerCount，从而通过返回false防止假警报，假警报会在不应该的情况下添加线程。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.如果一个任务可以成功排队，那么我们仍然需要再次检查是否应该添加一个线程(因为自上次检查以来已有线程死亡)，</span></span><br><span class=\"line\"><span class=\"comment\">     * 或者在进入该方法后池关闭。因此，我们重新检查状态，如果有必要，如果停止则回滚排队，如果没有，则启动一个新线程。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.如果不能对任务进行排队，则尝试添加一个新任务线程。如果它失败了，我们知道我们已经关闭或饱和了所以拒绝这个任务。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对上面内容做详细分析(重要):<br>1.首先判断当前线程池的状态以及当前线程的数目，判断当前线程的数目是否小于核心线程池的限制，如果小于，就新建线程添加任务<br>2.如果超过核心线程池限制，那么判断线程池状态是否是Running，并且将任务添加到任务队列，等待线程处理，如果这时候线程数为0，那么就新建空线程，执行队列中的任务<br>3.如果往任务队列中没有添加成功，那么就说明当前线程超出最大线程数限制，执行拒绝策略。</p>\n</blockquote>\n<h3 id=\"addWorker方法\"><a href=\"#addWorker方法\" class=\"headerlink\" title=\"addWorker方法\"></a>addWorker方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Recheck while holding lock.</span></span><br><span class=\"line\">                <span class=\"comment\">// Back out on ThreadFactory failure or if</span></span><br><span class=\"line\">                <span class=\"comment\">// shut down before lock acquired.</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.首先对线程池，任务队列进行前期检查</li>\n<li>2.对当前线程池中线程数的校验</li>\n<li>3.新建Worker，Worker类集成AbstractQueuedSynchronizer并且实现Runnable接口，说明Worker可以执行任务并且支持AQS(独占锁)</li>\n<li>4.添加任务的时候使用可重入锁锁住当前操作，防止并发产生一些脏读问题，导致线程池内的参数不准确，进而导致线程执行任务失败。</li>\n<li>5.添加任务成功后,就执行该线程，内部最终调用Runnable的run方法</li>\n<li>6.通过返回boolean类型数据，告诉调用者添加任务是否成功。</li>\n</ul>\n<h3 id=\"Shutdown方法\"><a href=\"#Shutdown方法\" class=\"headerlink\" title=\"Shutdown方法\"></a>Shutdown方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        advanceRunState(SHUTDOWN);</span><br><span class=\"line\">        interruptIdleWorkers();</span><br><span class=\"line\">        onShutdown(); <span class=\"comment\">// hook for ScheduledThreadPoolExecutor</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.判断是否拥有操作这些线程的权限</li>\n<li>2.设置线程池的状态为SHUTDOWN</li>\n<li>3.中断所有空闲线程(即没有执行任务的线程)</li>\n<li>4.onShutdown() 该类中并实现该方法</li>\n<li>5.尝试转换为最终状态TERMINATED</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>本文只是简要分析了ThreadPoolExecutor的大体流程，以及具体的一些细节，由于其核心方法addWorker还有疑问，因此只是对其简要分析，后期会更新本文追加其详细内容。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>通过学习Btrace想要追踪线程池状态，公司常用ThreadPoolExecutor线程池，由于对其内部原理与实现细节不够了解，因此本文对线程池进行简要分析</p>\n</blockquote>","more":"<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (corePoolSize &lt; <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt;= <span class=\"number\">0</span> ||</span><br><span class=\"line\">        maximumPoolSize &lt; corePoolSize ||</span><br><span class=\"line\">        keepAliveTime &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workQueue == <span class=\"keyword\">null</span> || threadFactory == <span class=\"keyword\">null</span> || handler == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.acc = System.getSecurityManager() == <span class=\"keyword\">null</span> ?</span><br><span class=\"line\">            <span class=\"keyword\">null</span> :</span><br><span class=\"line\">            AccessController.getContext();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.corePoolSize = corePoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.workQueue = workQueue;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.threadFactory = threadFactory;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.handler = handler;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>corePoolSize 核心线程数</li>\n<li>maximumPoolSize 最大线程数</li>\n<li>keepAliveTime 线程空闲时间</li>\n<li>TimeUnit 时间单位</li>\n<li>BlockingQueue<runnable> 等待队列类型</runnable></li>\n<li>ThreadFactory 线程工厂</li>\n<li>RejectedExecutionHandler 拒绝策略</li>\n</ul>\n<h3 id=\"状态定义\"><a href=\"#状态定义\" class=\"headerlink\" title=\"状态定义\"></a>状态定义</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Packing and unpacking ctl</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>ThreadPoolExecutor是将Int的高3位用来标志当前线程池的状态，低29位标志当前线程池的线程数。由此我们可以得知最大线程数是2^29-1。</p>\n<ul>\n<li>RUNNING -1左移29位即11111….111111 &lt;&lt; (29) 最终高3位是111</li>\n<li>SHUTDOWN 0左移29位00000…..000000 &lt;&lt;  (29) 最终高3位是000</li>\n<li>STOP 1左移29位000000…..00001 &lt;&lt; (29) 最终高3位是001</li>\n<li>TIDYING 2左移29位000000…00002 &lt;&lt; (29) 最终高3位是002</li>\n<li>TERMINATED 3左移29位000000…003 &lt;&lt; (29) 最终高3位是003</li>\n<li>runStateOf 获取当前线程池的状态</li>\n<li>workerCountOf 获取当前线程池线程数目</li>\n<li>ctlOf 根据线程数和线程池状态计算代表当前线程状态的int值</li>\n</ul>\n</blockquote>\n<h3 id=\"线程池执行流程\"><a href=\"#线程池执行流程\" class=\"headerlink\" title=\"线程池执行流程\"></a>线程池执行流程</h3><ul>\n<li>1.调用ThreadPoolExecutor的execute方法提交线程，如果线程池内的线程小于核心线程数，那么就创建新线程执行任务</li>\n<li>2.如果线程池内的线程数大于或等于核心线程数，那么就会将该线程加入任务队列，如果不能加入任务队列，那么如果当前线程池内的线程数小于最大线程数，那么创建新线程执行任务。</li>\n<li>3.如果当前线程池内的线程数超出maximumPoolSize，那么将执行拒绝策略(RejectedExecutionHandler)</li>\n</ul>\n<h3 id=\"execute方法\"><a href=\"#execute方法\" class=\"headerlink\" title=\"execute方法\"></a>execute方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 三个步骤:</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 1.如果运行的线程少于corepoolol大小，请尝试以给定的任务作为第一个任务启动一个新线程。</span></span><br><span class=\"line\"><span class=\"comment\">     * 对addWorker的调用原子性地检查运行状态和workerCount，从而通过返回false防止假警报，假警报会在不应该的情况下添加线程。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 2.如果一个任务可以成功排队，那么我们仍然需要再次检查是否应该添加一个线程(因为自上次检查以来已有线程死亡)，</span></span><br><span class=\"line\"><span class=\"comment\">     * 或者在进入该方法后池关闭。因此，我们重新检查状态，如果有必要，如果停止则回滚排队，如果没有，则启动一个新线程。</span></span><br><span class=\"line\"><span class=\"comment\">     *</span></span><br><span class=\"line\"><span class=\"comment\">     * 3.如果不能对任务进行排队，则尝试添加一个新任务线程。如果它失败了，我们知道我们已经关闭或饱和了所以拒绝这个任务。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对上面内容做详细分析(重要):<br>1.首先判断当前线程池的状态以及当前线程的数目，判断当前线程的数目是否小于核心线程池的限制，如果小于，就新建线程添加任务<br>2.如果超过核心线程池限制，那么判断线程池状态是否是Running，并且将任务添加到任务队列，等待线程处理，如果这时候线程数为0，那么就新建空线程，执行队列中的任务<br>3.如果往任务队列中没有添加成功，那么就说明当前线程超出最大线程数限制，执行拒绝策略。</p>\n</blockquote>\n<h3 id=\"addWorker方法\"><a href=\"#addWorker方法\" class=\"headerlink\" title=\"addWorker方法\"></a>addWorker方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Recheck while holding lock.</span></span><br><span class=\"line\">                <span class=\"comment\">// Back out on ThreadFactory failure or if</span></span><br><span class=\"line\">                <span class=\"comment\">// shut down before lock acquired.</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.首先对线程池，任务队列进行前期检查</li>\n<li>2.对当前线程池中线程数的校验</li>\n<li>3.新建Worker，Worker类集成AbstractQueuedSynchronizer并且实现Runnable接口，说明Worker可以执行任务并且支持AQS(独占锁)</li>\n<li>4.添加任务的时候使用可重入锁锁住当前操作，防止并发产生一些脏读问题，导致线程池内的参数不准确，进而导致线程执行任务失败。</li>\n<li>5.添加任务成功后,就执行该线程，内部最终调用Runnable的run方法</li>\n<li>6.通过返回boolean类型数据，告诉调用者添加任务是否成功。</li>\n</ul>\n<h3 id=\"Shutdown方法\"><a href=\"#Shutdown方法\" class=\"headerlink\" title=\"Shutdown方法\"></a>Shutdown方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        advanceRunState(SHUTDOWN);</span><br><span class=\"line\">        interruptIdleWorkers();</span><br><span class=\"line\">        onShutdown(); <span class=\"comment\">// hook for ScheduledThreadPoolExecutor</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>1.判断是否拥有操作这些线程的权限</li>\n<li>2.设置线程池的状态为SHUTDOWN</li>\n<li>3.中断所有空闲线程(即没有执行任务的线程)</li>\n<li>4.onShutdown() 该类中并实现该方法</li>\n<li>5.尝试转换为最终状态TERMINATED</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>本文只是简要分析了ThreadPoolExecutor的大体流程，以及具体的一些细节，由于其核心方法addWorker还有疑问，因此只是对其简要分析，后期会更新本文追加其详细内容。</p>\n</blockquote>"},{"title":"简单状态机实现,通过EnumMap收集所有转换状态。","date":"2018-04-22T15:49:25.000Z","copyright":true,"_content":"{% cq %}\n根据公司老大提示，查阅资料发现状态机其实是一种设计模式，能够很大程度上减少我们if else的条件判断，尤其是在做状态转换的时候，本篇文章通过EnumMap做一个状态机的简单实现。\n{% endcq %}\n\n<!-- more -->\n\n> 根据公司项目(P2P网关)中的状态，简单实现一个状态机\n\n### 状态定义枚举类\n{% codeblock lang:java %}\n/**\n * 状态定义\n */\npublic enum StatusDefine {\n    SUCCESS,\n    FAILED,\n    DEALING,\n    UNKNOW;\n}\n{% endcodeblock %}\n\n### 具体操作接口\n{% codeblock lang:java %}\n/**\n * 具体操作接口\n */\npublic interface Action {\n    /**\n     * 转换状态方法\n     */\n    public void convertStatus();\n}\n{% endcodeblock %}\n\n### 状态转换枚举类\n{% codeblock lang:java %}\n\npublic enum StatusConvert{\n\n\n    /** 失败转换成成功 */\n    FAIL_TO_SUCCESS(StatusDefine.FAILED,StatusDefine.SUCCESS){\n        @Override\n        public void todoConvertStatus() {\n            doSomething(new Action() {\n                @Override\n                public void convertStatus() {\n                    System.out.println(\"失败->成功\");\n                }\n            });\n        }\n    },\n    DEALING_TO_SUCCESS(StatusDefine.DEALING,StatusDefine.SUCCESS){\n        @Override\n        public void todoConvertStatus() {\n            doSomething(new Action() {\n                @Override\n                public void convertStatus() {\n                    System.out.println(\"处理中->成功\");\n                }\n            });\n        }\n    },\n    UNKNOWN_TO_SUCCESS(StatusDefine.UNKNOW,StatusDefine.SUCCESS){\n        @Override\n        public void todoConvertStatus() {\n            doSomething(new Action() {\n                @Override\n                public void convertStatus() {\n                    System.out.println(\"未知->成功\");\n                }\n            });\n        }\n    };\n\n    /**\n     * 状态转换集合\n     */\n    public static final EnumMap<StatusDefine, EnumMap<StatusDefine, StatusConvert>> ALL_STATUS = new EnumMap<StatusDefine, EnumMap<StatusDefine, StatusConvert>>(StatusDefine.class);\n\n\n    /**\n     * 当前状态\n     */\n    private StatusDefine start;\n    /**\n     * 目标状态\n     */\n    private StatusDefine target;\n\n    /**\n     * 初始化ALL_STATUS\n     */\n    static {\n        for (StatusDefine statusDefine : StatusDefine.values()){\n            ALL_STATUS.put(statusDefine,new EnumMap<StatusDefine, StatusConvert>(StatusDefine.class));\n        }\n\n        for (StatusConvert statusConvert : StatusConvert.values()) {\n            ALL_STATUS.get(statusConvert.start).put(statusConvert.target, statusConvert);\n        }\n\n    }\n\n    StatusConvert(StatusDefine start, StatusDefine target) {\n        this.start = start;\n        this.target = target;\n    }\n\n    /**\n     * 状态转换抽象方法\n     */\n    abstract void todoConvertStatus();\n\n    /**\n     * 模板方法\n     * @param action\n     */\n    protected void doSomething(Action action){\n        System.out.println(\"转换状态之前的操作\");\n        action.convertStatus();\n        System.out.println(\"转换状态之后的操作\");\n    }\n\n}\n{% endcodeblock %}\n\n### 测试方法\n{% codeblock lang:java %}\npublic static void main(String[] args) {\n    StatusConvert.ALL_STATUS.get(StatusDefine.FAILED).get(StatusDefine.SUCCESS).todoConvertStatus()\n    System.out.println(\"***************\");\n    StatusConvert.DEALING_TO_SUCCESS.todoConvertStatus();\n}\n{% endcodeblock %}\n\n> 可以将上面的调用封装成一个静态的执行方法，在此由于方便理解，就不做封装了。\n\n### 测试结果\n{% codeblock lang:java %}\n转换状态之前的操作\n失败->成功\n转换状态之后的操作\n***************\n转换状态之前的操作\n处理中->成功\n转换状态之后的操作\n{% endcodeblock %}\n\n### 总结\n\n> 以上实现方式能够将所有的状态定义清晰的展现出来，并且所有的状态转换操作都是以StatusDefine(状态定义类)为基础，通过模版方法对状态转换之前和之后的公共代码抽出来，以便我们只关注状态转换的实现。\n\n\n### 提示\n> 以上是博主第一次实现状态机，如有瑕疵还需大家指正。\n\n\n\n\n\n\n","source":"_posts/java-stateMachine.md","raw":"---\ntitle: 简单状态机实现,通过EnumMap收集所有转换状态。\ndate: 2018-04-22 23:49:25\ncopyright: true\ntags:\n - java\ncategories:\n - java\n---\n{% cq %}\n根据公司老大提示，查阅资料发现状态机其实是一种设计模式，能够很大程度上减少我们if else的条件判断，尤其是在做状态转换的时候，本篇文章通过EnumMap做一个状态机的简单实现。\n{% endcq %}\n\n<!-- more -->\n\n> 根据公司项目(P2P网关)中的状态，简单实现一个状态机\n\n### 状态定义枚举类\n{% codeblock lang:java %}\n/**\n * 状态定义\n */\npublic enum StatusDefine {\n    SUCCESS,\n    FAILED,\n    DEALING,\n    UNKNOW;\n}\n{% endcodeblock %}\n\n### 具体操作接口\n{% codeblock lang:java %}\n/**\n * 具体操作接口\n */\npublic interface Action {\n    /**\n     * 转换状态方法\n     */\n    public void convertStatus();\n}\n{% endcodeblock %}\n\n### 状态转换枚举类\n{% codeblock lang:java %}\n\npublic enum StatusConvert{\n\n\n    /** 失败转换成成功 */\n    FAIL_TO_SUCCESS(StatusDefine.FAILED,StatusDefine.SUCCESS){\n        @Override\n        public void todoConvertStatus() {\n            doSomething(new Action() {\n                @Override\n                public void convertStatus() {\n                    System.out.println(\"失败->成功\");\n                }\n            });\n        }\n    },\n    DEALING_TO_SUCCESS(StatusDefine.DEALING,StatusDefine.SUCCESS){\n        @Override\n        public void todoConvertStatus() {\n            doSomething(new Action() {\n                @Override\n                public void convertStatus() {\n                    System.out.println(\"处理中->成功\");\n                }\n            });\n        }\n    },\n    UNKNOWN_TO_SUCCESS(StatusDefine.UNKNOW,StatusDefine.SUCCESS){\n        @Override\n        public void todoConvertStatus() {\n            doSomething(new Action() {\n                @Override\n                public void convertStatus() {\n                    System.out.println(\"未知->成功\");\n                }\n            });\n        }\n    };\n\n    /**\n     * 状态转换集合\n     */\n    public static final EnumMap<StatusDefine, EnumMap<StatusDefine, StatusConvert>> ALL_STATUS = new EnumMap<StatusDefine, EnumMap<StatusDefine, StatusConvert>>(StatusDefine.class);\n\n\n    /**\n     * 当前状态\n     */\n    private StatusDefine start;\n    /**\n     * 目标状态\n     */\n    private StatusDefine target;\n\n    /**\n     * 初始化ALL_STATUS\n     */\n    static {\n        for (StatusDefine statusDefine : StatusDefine.values()){\n            ALL_STATUS.put(statusDefine,new EnumMap<StatusDefine, StatusConvert>(StatusDefine.class));\n        }\n\n        for (StatusConvert statusConvert : StatusConvert.values()) {\n            ALL_STATUS.get(statusConvert.start).put(statusConvert.target, statusConvert);\n        }\n\n    }\n\n    StatusConvert(StatusDefine start, StatusDefine target) {\n        this.start = start;\n        this.target = target;\n    }\n\n    /**\n     * 状态转换抽象方法\n     */\n    abstract void todoConvertStatus();\n\n    /**\n     * 模板方法\n     * @param action\n     */\n    protected void doSomething(Action action){\n        System.out.println(\"转换状态之前的操作\");\n        action.convertStatus();\n        System.out.println(\"转换状态之后的操作\");\n    }\n\n}\n{% endcodeblock %}\n\n### 测试方法\n{% codeblock lang:java %}\npublic static void main(String[] args) {\n    StatusConvert.ALL_STATUS.get(StatusDefine.FAILED).get(StatusDefine.SUCCESS).todoConvertStatus()\n    System.out.println(\"***************\");\n    StatusConvert.DEALING_TO_SUCCESS.todoConvertStatus();\n}\n{% endcodeblock %}\n\n> 可以将上面的调用封装成一个静态的执行方法，在此由于方便理解，就不做封装了。\n\n### 测试结果\n{% codeblock lang:java %}\n转换状态之前的操作\n失败->成功\n转换状态之后的操作\n***************\n转换状态之前的操作\n处理中->成功\n转换状态之后的操作\n{% endcodeblock %}\n\n### 总结\n\n> 以上实现方式能够将所有的状态定义清晰的展现出来，并且所有的状态转换操作都是以StatusDefine(状态定义类)为基础，通过模版方法对状态转换之前和之后的公共代码抽出来，以便我们只关注状态转换的实现。\n\n\n### 提示\n> 以上是博主第一次实现状态机，如有瑕疵还需大家指正。\n\n\n\n\n\n\n","slug":"java-stateMachine","published":1,"updated":"2018-08-12T08:44:32.083Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6m000sm9cgj3wa635j","content":"<blockquote class=\"blockquote-center\"><p>根据公司老大提示，查阅资料发现状态机其实是一种设计模式，能够很大程度上减少我们if else的条件判断，尤其是在做状态转换的时候，本篇文章通过EnumMap做一个状态机的简单实现。</p>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<p>根据公司项目(P2P网关)中的状态，简单实现一个状态机</p>\n</blockquote>\n<h3 id=\"状态定义枚举类\"><a href=\"#状态定义枚举类\" class=\"headerlink\" title=\"状态定义枚举类\"></a>状态定义枚举类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 状态定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> StatusDefine &#123;</span><br><span class=\"line\">    SUCCESS,</span><br><span class=\"line\">    FAILED,</span><br><span class=\"line\">    DEALING,</span><br><span class=\"line\">    UNKNOW;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"具体操作接口\"><a href=\"#具体操作接口\" class=\"headerlink\" title=\"具体操作接口\"></a>具体操作接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体操作接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转换状态方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"状态转换枚举类\"><a href=\"#状态转换枚举类\" class=\"headerlink\" title=\"状态转换枚举类\"></a>状态转换枚举类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> StatusConvert&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 失败转换成成功 */</span></span><br><span class=\"line\">    FAIL_TO_SUCCESS(StatusDefine.FAILED,StatusDefine.SUCCESS)&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doSomething(<span class=\"keyword\">new</span> Action() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"失败-&gt;成功\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    DEALING_TO_SUCCESS(StatusDefine.DEALING,StatusDefine.SUCCESS)&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doSomething(<span class=\"keyword\">new</span> Action() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"处理中-&gt;成功\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UNKNOWN_TO_SUCCESS(StatusDefine.UNKNOW,StatusDefine.SUCCESS)&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doSomething(<span class=\"keyword\">new</span> Action() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"未知-&gt;成功\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 状态转换集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumMap&lt;StatusDefine, EnumMap&lt;StatusDefine, StatusConvert&gt;&gt; ALL_STATUS = <span class=\"keyword\">new</span> EnumMap&lt;StatusDefine, EnumMap&lt;StatusDefine, StatusConvert&gt;&gt;(StatusDefine.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当前状态</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StatusDefine start;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 目标状态</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StatusDefine target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化ALL_STATUS</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StatusDefine statusDefine : StatusDefine.values())&#123;</span><br><span class=\"line\">            ALL_STATUS.put(statusDefine,<span class=\"keyword\">new</span> EnumMap&lt;StatusDefine, StatusConvert&gt;(StatusDefine.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StatusConvert statusConvert : StatusConvert.values()) &#123;</span><br><span class=\"line\">            ALL_STATUS.get(statusConvert.start).put(statusConvert.target, statusConvert);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    StatusConvert(StatusDefine start, StatusDefine target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 状态转换抽象方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模板方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> action</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(Action action)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"转换状态之前的操作\"</span>);</span><br><span class=\"line\">        action.convertStatus();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"转换状态之后的操作\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试方法\"><a href=\"#测试方法\" class=\"headerlink\" title=\"测试方法\"></a>测试方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    StatusConvert.ALL_STATUS.get(StatusDefine.FAILED).get(StatusDefine.SUCCESS).todoConvertStatus()</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"***************\"</span>);</span><br><span class=\"line\">    StatusConvert.DEALING_TO_SUCCESS.todoConvertStatus();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以将上面的调用封装成一个静态的执行方法，在此由于方便理解，就不做封装了。</p>\n</blockquote>\n<h3 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">转换状态之前的操作</span><br><span class=\"line\">失败-&gt;成功</span><br><span class=\"line\">转换状态之后的操作</span><br><span class=\"line\">***************</span><br><span class=\"line\">转换状态之前的操作</span><br><span class=\"line\">处理中-&gt;成功</span><br><span class=\"line\">转换状态之后的操作</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>以上实现方式能够将所有的状态定义清晰的展现出来，并且所有的状态转换操作都是以StatusDefine(状态定义类)为基础，通过模版方法对状态转换之前和之后的公共代码抽出来，以便我们只关注状态转换的实现。</p>\n</blockquote>\n<h3 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h3><blockquote>\n<p>以上是博主第一次实现状态机，如有瑕疵还需大家指正。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>根据公司老大提示，查阅资料发现状态机其实是一种设计模式，能够很大程度上减少我们if else的条件判断，尤其是在做状态转换的时候，本篇文章通过EnumMap做一个状态机的简单实现。</p>\n</blockquote>","more":"<blockquote>\n<p>根据公司项目(P2P网关)中的状态，简单实现一个状态机</p>\n</blockquote>\n<h3 id=\"状态定义枚举类\"><a href=\"#状态定义枚举类\" class=\"headerlink\" title=\"状态定义枚举类\"></a>状态定义枚举类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 状态定义</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> StatusDefine &#123;</span><br><span class=\"line\">    SUCCESS,</span><br><span class=\"line\">    FAILED,</span><br><span class=\"line\">    DEALING,</span><br><span class=\"line\">    UNKNOW;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"具体操作接口\"><a href=\"#具体操作接口\" class=\"headerlink\" title=\"具体操作接口\"></a>具体操作接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 具体操作接口</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 转换状态方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"状态转换枚举类\"><a href=\"#状态转换枚举类\" class=\"headerlink\" title=\"状态转换枚举类\"></a>状态转换枚举类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">enum</span> StatusConvert&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** 失败转换成成功 */</span></span><br><span class=\"line\">    FAIL_TO_SUCCESS(StatusDefine.FAILED,StatusDefine.SUCCESS)&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doSomething(<span class=\"keyword\">new</span> Action() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"失败-&gt;成功\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    DEALING_TO_SUCCESS(StatusDefine.DEALING,StatusDefine.SUCCESS)&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doSomething(<span class=\"keyword\">new</span> Action() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"处理中-&gt;成功\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    UNKNOWN_TO_SUCCESS(StatusDefine.UNKNOW,StatusDefine.SUCCESS)&#123;</span><br><span class=\"line\">        <span class=\"meta\">@Override</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">            doSomething(<span class=\"keyword\">new</span> Action() &#123;</span><br><span class=\"line\">                <span class=\"meta\">@Override</span></span><br><span class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">convertStatus</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                    System.out.println(<span class=\"string\">\"未知-&gt;成功\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 状态转换集合</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> EnumMap&lt;StatusDefine, EnumMap&lt;StatusDefine, StatusConvert&gt;&gt; ALL_STATUS = <span class=\"keyword\">new</span> EnumMap&lt;StatusDefine, EnumMap&lt;StatusDefine, StatusConvert&gt;&gt;(StatusDefine.class);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 当前状态</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StatusDefine start;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 目标状态</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> StatusDefine target;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 初始化ALL_STATUS</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StatusDefine statusDefine : StatusDefine.values())&#123;</span><br><span class=\"line\">            ALL_STATUS.put(statusDefine,<span class=\"keyword\">new</span> EnumMap&lt;StatusDefine, StatusConvert&gt;(StatusDefine.class));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (StatusConvert statusConvert : StatusConvert.values()) &#123;</span><br><span class=\"line\">            ALL_STATUS.get(statusConvert.start).put(statusConvert.target, statusConvert);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    StatusConvert(StatusDefine start, StatusDefine target) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.start = start;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.target = target;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 状态转换抽象方法</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">todoConvertStatus</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模板方法</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> action</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">doSomething</span><span class=\"params\">(Action action)</span></span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"转换状态之前的操作\"</span>);</span><br><span class=\"line\">        action.convertStatus();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"转换状态之后的操作\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"测试方法\"><a href=\"#测试方法\" class=\"headerlink\" title=\"测试方法\"></a>测试方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    StatusConvert.ALL_STATUS.get(StatusDefine.FAILED).get(StatusDefine.SUCCESS).todoConvertStatus()</span><br><span class=\"line\">    System.out.println(<span class=\"string\">\"***************\"</span>);</span><br><span class=\"line\">    StatusConvert.DEALING_TO_SUCCESS.todoConvertStatus();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>可以将上面的调用封装成一个静态的执行方法，在此由于方便理解，就不做封装了。</p>\n</blockquote>\n<h3 id=\"测试结果\"><a href=\"#测试结果\" class=\"headerlink\" title=\"测试结果\"></a>测试结果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">转换状态之前的操作</span><br><span class=\"line\">失败-&gt;成功</span><br><span class=\"line\">转换状态之后的操作</span><br><span class=\"line\">***************</span><br><span class=\"line\">转换状态之前的操作</span><br><span class=\"line\">处理中-&gt;成功</span><br><span class=\"line\">转换状态之后的操作</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><blockquote>\n<p>以上实现方式能够将所有的状态定义清晰的展现出来，并且所有的状态转换操作都是以StatusDefine(状态定义类)为基础，通过模版方法对状态转换之前和之后的公共代码抽出来，以便我们只关注状态转换的实现。</p>\n</blockquote>\n<h3 id=\"提示\"><a href=\"#提示\" class=\"headerlink\" title=\"提示\"></a>提示</h3><blockquote>\n<p>以上是博主第一次实现状态机，如有瑕疵还需大家指正。</p>\n</blockquote>"},{"title":"springIOC分享","date":"2018-08-20T07:20:06.000Z","copyright":true,"_content":"\n{% cq %} \n最近看到一篇关于SpringIOC的博客，源码解读很详尽，因此分享给大家并记录下来。\n{% endcq %}\n<!-- more -->\n\n### 博客地址\n<https://javadoop.com/post/spring-ioc#profile>\n\n>此篇博客篇幅较长，涉及内容很多，阅读时需要对照源码。该博客从获取bean开始对Spring源码进行详细解读，必要时需要多看几遍，理解其中的接口上下文关系，方便我们理解Spring的核心IOC\n\n### 个人认为比较重要的点\n\n#### 附录\n> 附录中讲解了一些我们平时在使用Spring时容易疏忽的点，以及一些陌生的java知识点 \n- Spring配置文件中id和name\n- 配置是否允许 Bean 覆盖、是否允许循环依赖\n- ConversionService用于请求参数转换的类\n- BeanPostProcessor 执行的顺序","source":"_posts/spring-IOC.md","raw":"---\ntitle: springIOC分享\ndate: 2018-08-20 15:20:06\ncopyright: true\ntags:\n - spring\ncategories:\n - spring\n---\n\n{% cq %} \n最近看到一篇关于SpringIOC的博客，源码解读很详尽，因此分享给大家并记录下来。\n{% endcq %}\n<!-- more -->\n\n### 博客地址\n<https://javadoop.com/post/spring-ioc#profile>\n\n>此篇博客篇幅较长，涉及内容很多，阅读时需要对照源码。该博客从获取bean开始对Spring源码进行详细解读，必要时需要多看几遍，理解其中的接口上下文关系，方便我们理解Spring的核心IOC\n\n### 个人认为比较重要的点\n\n#### 附录\n> 附录中讲解了一些我们平时在使用Spring时容易疏忽的点，以及一些陌生的java知识点 \n- Spring配置文件中id和name\n- 配置是否允许 Bean 覆盖、是否允许循环依赖\n- ConversionService用于请求参数转换的类\n- BeanPostProcessor 执行的顺序","slug":"spring-IOC","published":1,"updated":"2018-08-20T08:29:30.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjottiq6n000vm9cglrthaeyj","content":"<blockquote class=\"blockquote-center\"><p>最近看到一篇关于SpringIOC的博客，源码解读很详尽，因此分享给大家并记录下来。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"博客地址\"><a href=\"#博客地址\" class=\"headerlink\" title=\"博客地址\"></a>博客地址</h3><p><a href=\"https://javadoop.com/post/spring-ioc#profile\" target=\"_blank\" rel=\"noopener\">https://javadoop.com/post/spring-ioc#profile</a></p>\n<blockquote>\n<p>此篇博客篇幅较长，涉及内容很多，阅读时需要对照源码。该博客从获取bean开始对Spring源码进行详细解读，必要时需要多看几遍，理解其中的接口上下文关系，方便我们理解Spring的核心IOC</p>\n</blockquote>\n<h3 id=\"个人认为比较重要的点\"><a href=\"#个人认为比较重要的点\" class=\"headerlink\" title=\"个人认为比较重要的点\"></a>个人认为比较重要的点</h3><h4 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h4><blockquote>\n<p>附录中讲解了一些我们平时在使用Spring时容易疏忽的点，以及一些陌生的java知识点 </p>\n<ul>\n<li>Spring配置文件中id和name</li>\n<li>配置是否允许 Bean 覆盖、是否允许循环依赖</li>\n<li>ConversionService用于请求参数转换的类</li>\n<li>BeanPostProcessor 执行的顺序</li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote class=\"blockquote-center\"><p>最近看到一篇关于SpringIOC的博客，源码解读很详尽，因此分享给大家并记录下来。</p>\n</blockquote>","more":"<h3 id=\"博客地址\"><a href=\"#博客地址\" class=\"headerlink\" title=\"博客地址\"></a>博客地址</h3><p><a href=\"https://javadoop.com/post/spring-ioc#profile\" target=\"_blank\" rel=\"noopener\">https://javadoop.com/post/spring-ioc#profile</a></p>\n<blockquote>\n<p>此篇博客篇幅较长，涉及内容很多，阅读时需要对照源码。该博客从获取bean开始对Spring源码进行详细解读，必要时需要多看几遍，理解其中的接口上下文关系，方便我们理解Spring的核心IOC</p>\n</blockquote>\n<h3 id=\"个人认为比较重要的点\"><a href=\"#个人认为比较重要的点\" class=\"headerlink\" title=\"个人认为比较重要的点\"></a>个人认为比较重要的点</h3><h4 id=\"附录\"><a href=\"#附录\" class=\"headerlink\" title=\"附录\"></a>附录</h4><blockquote>\n<p>附录中讲解了一些我们平时在使用Spring时容易疏忽的点，以及一些陌生的java知识点 </p>\n<ul>\n<li>Spring配置文件中id和name</li>\n<li>配置是否允许 Bean 覆盖、是否允许循环依赖</li>\n<li>ConversionService用于请求参数转换的类</li>\n<li>BeanPostProcessor 执行的顺序</li>\n</ul>\n</blockquote>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjottiq270000m9cg0scxozmf","category_id":"cjottiq2b0001m9cgyjs8ylfl","_id":"cjottiq2e0004m9cgtvz2bx1a"},{"post_id":"cjottiq6c000dm9cgfml9vzv9","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6k000lm9cge4asuht9"},{"post_id":"cjottiq640005m9cgv0g9t37g","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6m000qm9cgbv8ppj38"},{"post_id":"cjottiq6d000em9cg63zpfq9k","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6n000tm9cgmxhhxjnb"},{"post_id":"cjottiq6h000im9cg1ma43fkw","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6o000wm9cge5mhrclm"},{"post_id":"cjottiq660007m9cgikhbckhz","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6o000ym9cgubww21nl"},{"post_id":"cjottiq6j000km9cg5dx8xiww","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6p0012m9cg2vgaca9q"},{"post_id":"cjottiq6l000pm9cgje7h1gox","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6p0014m9cgh1a084a9"},{"post_id":"cjottiq6a000bm9cgwr7g808t","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6q0016m9cg00uguhbd"},{"post_id":"cjottiq6m000sm9cgj3wa635j","category_id":"cjottiq690009m9cg80vrs96h","_id":"cjottiq6r0018m9cg32k75xl9"},{"post_id":"cjottiq6n000vm9cglrthaeyj","category_id":"cjottiq6p000zm9cgp2tw77e2","_id":"cjottiq6r0019m9cgc3kwqgti"}],"PostTag":[{"post_id":"cjottiq270000m9cg0scxozmf","tag_id":"cjottiq2c0002m9cgzii52a5r","_id":"cjottiq2d0003m9cgc795oo73"},{"post_id":"cjottiq6c000dm9cgfml9vzv9","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6h000hm9cg0usnbvuj"},{"post_id":"cjottiq640005m9cgv0g9t37g","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6j000jm9cgqp8500n9"},{"post_id":"cjottiq6d000em9cg63zpfq9k","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6l000om9cgmlg4nhp4"},{"post_id":"cjottiq6h000im9cg1ma43fkw","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6m000rm9cg47ovaiaj"},{"post_id":"cjottiq660007m9cgikhbckhz","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6n000um9cgzsp9lob9"},{"post_id":"cjottiq6j000km9cg5dx8xiww","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6o000xm9cggcmg7uuz"},{"post_id":"cjottiq6l000pm9cgje7h1gox","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6p0011m9cgjo36dnb1"},{"post_id":"cjottiq6a000bm9cgwr7g808t","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6p0013m9cgkxx92mcn"},{"post_id":"cjottiq6m000sm9cgj3wa635j","tag_id":"cjottiq69000am9cgco8xtrm2","_id":"cjottiq6q0015m9cgmouxr0ol"},{"post_id":"cjottiq6n000vm9cglrthaeyj","tag_id":"cjottiq6p0010m9cgogt1p0dl","_id":"cjottiq6q0017m9cgktvn2r43"}],"Tag":[{"name":"dataStructure","_id":"cjottiq2c0002m9cgzii52a5r"},{"name":"java","_id":"cjottiq69000am9cgco8xtrm2"},{"name":"spring","_id":"cjottiq6p0010m9cgogt1p0dl"}]}}